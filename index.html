<!--
Changelog
2025-12-04 – v045 – v62 sauber ersetzt & kaputte Fragmente entfernt
- v62-Skriptblock vollständig neu eingesetzt (syntaktisch korrekt, idempotente Hooks).
- Zerhackte Doppel-Fragmente nach v62 entfernt (Ursache für „Unexpected end of input“).
- Globales Script-Pairing erneut ausgeführt (keine offenen <script>-Übergänge).
-->

<!--
Changelog
2025-12-04 – v044 – v62 sauber & Script-Pairing final
- v62-Skriptblock vollständig ersetzt (syntaktisch korrekt, keine Duplikate/Fragmente).
- Doppelter/trunkierter „Daten-Konsolidierung“-Anhang entfernt.
- Globales Script-Pairing erneut ausgeführt (keine offenen <script>-Übergänge).
-->

<!--
Changelog
2025-12-04 – v043 – v62 Segment komplett repariert + Script-Pairing global
- v62-Block vollständig ersetzt (Anzeige-Filter + sichere Daten-Konsolidierung, keine offenen Fragmente mehr).
- Dokumentweit </script>
<script>-Übergänge gepaart (verhindert „Unexpected token '<'“ / „Unexpected end of input“).
- Anzeige: 0-Delta neben echtem ±n (gleiche Sekunde & Artikel) ausgeblendet; perfekte Duplikate in der Ansicht unterdrückt.
- Daten: Entfernt nur in/out (0), wenn im selben Moment eine passende qty±n existiert (idempotent, konservativ).
-->

<!--
Changelog
2025-12-04 – v042 – Script-Pairing (global) & History-Ansicht stabil
- Alle offenen </script>
</script>
<script>-Blöcke zwischen Segmenten automatisch geschlossen (SyntaxError „Unexpected token '<'“ beseitigt).
- Anzeige-Filter für Historie abgesichert (0‑Delta neben echtem ±n wird unterdrückt; Daten bleiben unverändert).
-->

<!--
Changelog
2025-12-04 – v039 – History-Ansicht ohne 0-Delta-Duplikate
- Anzeige-Filter __lv62_histFilter entfernt 0-Deltas, wenn im gleichen Moment für denselben Artikel eine echte Mengenänderung existiert.
- Daten bleiben dabei unverändert; nur die Historie-Ansicht wird bereinigt.
-->

<!--
Changelog
2025-12-04 – v038 – History 0-Delta-Bereinigung & Script-Tags gefixt
- v62: Daten-De-Dup für Historie wieder aktiviert (entfernt nur in/out (0) neben echter qty±n-Buchung pro Item & Sekunde).
- Syntax: Fehlende </script>-Tags bei v62/v73 ergänzt (verhindert „Unexpected token '<'“ in der Konsole).
-->

<!--
Changelog
2025-12-04 – v036 – Syntaxfix & History-Dedupe entschärft
- Defekten ItemOpsLocal-Wrapper (v73) vollständig ersetzt (kein „Unexpected token 'catch'“ mehr).
- v62-History-De-Dup vorsichtig entschärft: keine Sekundengruppierung mehr, Einträge bleiben getrennt sichtbar.
-->

<!--
Changelog
2025-12-04 – v035 – Log-Dedupe entschärft (Historie)
- Cloud-Merge der Log-Einträge überarbeitet: opId-basiert und mit konservativer Duplikaterkennung.
- Echte Aktionen erzeugen nun zuverlässig separate Historien-Einträge, auch bei gleicher Sekunde.
-->

<!--
Changelog
2025-11-30 – v033 – Lokaler Speicher-Reset mit Reload-Hinweis
- Nach dem Löschen der lokalen Lagerdaten wird eine Nachfrage angezeigt, ob die Seite direkt neu geladen werden soll.
-->
<!--
Changelog
2025-11-30 – v032 – Lokaler Speicher-Reset (nur Lagerverwaltung)
- Neuer Button in den Einstellungen („Lokale Lagerdaten löschen“).
- Entfernt nur localStorage/sessionStorage-Keys der Lagerverwaltung (Präfix lv_/lagerverwaltung_).
- Cloud-Daten (Supabase) bleiben unverändert.
-->
<!--
Changelog
2025-11-25 – v024a – Syntaxfix (StartNotice & Sync‑Optionen)
- Beschädigte Codefragmente („...“) im Sync‑Auswahl/Push‑First‑Block ersetzt (manueller Sync + runFullSync‑Wrapper).
- readAppCache()/writeAppCache() korrigiert (localStorage.getItem/setItem).
- Keine Funktions-/UI‑Änderungen.
-->
<!--
Changelog
2025-11-25 – v024 – Start-Hinweis: Login/Sync-Option
- Start-Hinweis-Konfiguration erweitert: getrennte Flags für „Beim Anmelden anzeigen“ und „Bei Standard‑Sync anzeigen“.
- Bestehende Konfigurationen ohne Flags bleiben kompatibel (interpretiert als „Beim Anmelden anzeigen“).
- Standard‑Sync (nicht stumm) zeigt den Hinweis, wenn die Option aktiviert ist.
2025-11-25 – v023 – Start-Hinweis: Rechte + Supabase
- Neues Recht „Start-Hinweis verwalten“ in Gruppen & Rechte (Standard: Admin/Lokaladmin via manage_settings-Fallback).
- Start-Hinweis wird lokal gespeichert und zusätzlich in Supabase (lv_app_settings, key 'start_notice') gespiegelt.
- Beim Login wird der Start-Hinweis aus Supabase (falls konfiguriert) geladen; Fallback: lokale Konfiguration.
- Keine Änderungen an Buchungs-/Bestands-/Sync- oder Historien-Logik.
-->
<!--
Changelog
2025-11-25 – v022 – Start-Hinweis beim Login (lokal)
- Neuer Bereich „Hinweis beim Start“ in den Einstellungen (nur für manage_settings sichtbar).
- Freitext-Hinweis wird nach erfolgreicher Anmeldung einmal angezeigt, solange aktiviert.
- Speicherung lokal in der App (noch ohne Cloud-Sync).
2025-11-25 – v021 – History: Suchfeld im Dialog aktiviert (DOM-only)
- Textsuche im globalen History-Dialog (#histSearch) blendet Zeilen per DOM jetzt ein/aus.
- Zählt sichtbare Einträge neu in #histCount.
- Keine Änderungen an Buchungs-/Bestands-/Sync- oder Logging-Logik.
-->
<!--
Changelog
2025-11-25 – v020 – History: User-Stamp & Benutzer-Filter (vorsichtig)
- Neue History-Einträge werden mit Benutzer-Infos gestempelt (user, user_id) – additiv.
- Globaler History-Filter durchsucht jetzt auch das Feld „Benutzer“.
- Keine Änderungen an Bestands-/Buchungs-/Sync-Logik.
-->
<!--
Changelog
2025-11-25 – v019 – Historie „Benutzer“-Spalte: Gating robuster
- Sichtbarkeit jetzt auch, wenn currentPerms.* Admin-Rolle signalisiert (admin/is_admin/role==='admin').
- Reihenfolge: explizites Recht view_history_usernames > Admin > Lokaladmin.
- Re-apply Hook erweitert (History-Dialog-Open via <details>).
- Keine Änderungen an Buchungs-/Bestands-/Sync-Logik.
-->
<!--
Changelog
2025-11-25 – v018 – Historie: Benutzer-Spalte per Recht (view_history_usernames)
- Neues Gruppenrecht: view_history_usernames (standardmäßig Admin/Lokaladmin).
- „Benutzer“-Spalte in der Historie wird nur angezeigt, wenn isAdmin() ODER Lokaladmin ODER has('view_history_usernames').
- Keine Änderungen an Buchungs-/Bestands-/Sync-Logik. Anzeige-only. Forward-Helper stampHistoryUser(entry) bereit (ohne Hook).
-->
<!--
Changelog
2025-11-25 – v017 – Selftest liest Konfiguration vollständig über readBrConfig()
- URL/Token/Tabellen-IDs werden nicht mehr direkt aus localStorage gelesen (Migration greift jetzt).
- Keine Statusänderung durch Selftest; sonst unverändert.
-->
<!--
Changelog
2025-11-25 – v016 – Selftest stabilisiert (Config aus readBrConfig, kein Status-Flip auf Fehler, kein doppeltes „Gesamt“)
- Selftest nutzt jetzt konsequent readBrConfig() (URL, Token, Tabellen-IDs) statt DOM-Felder – wie Sync/Push.
- Zusammenfassung „Gesamt: …“ wird nur einmal erzeugt (kein Duplicate).
- Selftest beeinflusst Cloud-Status NICHT negativ: setzt bei Erfolg 'online', lässt ihn bei Fehler unverändert.
-->
<!--
Changelog
2025-11-25 – v015 – Verbindung testen & Status-Kopplung
- Selftest: brListAll(..., { size:1 }) statt { limit:1 } + kleine Ergebniszeile („Gesamt: OK/FEHLER“).
- Einheitliches Cloud-Status-Update: setCloudStatus('online'|'offline'|'fehler') aktualisiert #statusCloud UND #cloudStatus.
- Status-Pill „Sync ausstehend: n“ koppelt an Outbox-Zähler; zeigt „0“ oder wird versteckt.
- Keine Änderungen an Buchungen/Verlauf/Sync-Abläufen.
-->
<!--
Changelog
2025-11-25 – v013 – Verbindung testen repariert (Selftest nutzt { size:1 } statt { limit:1 } + Ergebniszeile)
- Selftest ruft brListAll nun mit Option 'size:1' wie übrige Cloud-Funktionen auf.
- Ausgabe ergänzt um eine Zusammenfassung „Gesamt: OK/FEHLER“ (nur Anzeige).
- Keine Änderungen an Sync-/Datenlogik.
-->
<!--
Changelog
2025-11-25 – v012 – Kategorie-Anzeige Fix & Save-Normalisierung (vorsichtig)
- Fix für v10-Regress: Anzeige-Normalisierung überschiebte Karten-Inhalte → jetzt nur [data-cat] & [data-field="category"], 
  und Text wird NUR gesetzt, wenn das Ziel keine Kindelemente hat (nicht-destruktiv).
- Optionaler Save-Guard (aktiv): Beim Speichern wird NUR das Feld „Kategorie“ via normalizeCategory() geglättet (Capture-Phase).
  Abschaltbar über localStorage: lv_cat_save_normalize='0'.
- Keine Änderungen an Buchungen/Verlauf/„Zuletzt geändert“/Sync/Rechten.
-->
<!--
Changelog
2025-11-25 – v010 – Kategorien (vorsichtige Normalisierung Anzeige/Filter)
- Anzeige: Kategorie-Chip/Label über normalizeCategory() + CAT_SHORT abgeleitet (fallback-sicher).
- Filter: Vergleiche nutzen normalizeCategory() für Filterwert und Item-Wert.
- Keine Änderungen an Speichern/Verlauf/Buchungen (History bleibt unberührt).
-->
<!--
Changelog
2025-11-25 – v009 – Toast-Texte konsolidiert & Banner-Status-Badges
- Einheitliche Meldung ohne Rechte: „Keine Berechtigung für Synchronisation.“
- Queue-Banner zeigt kleine Badges: Outbox-Zähler („leer“/Anzahl) und Berechtigungsstatus („berechtigt“/„kein Recht“).
- Keine Dev-/Testschalter, keine Änderungen an Sync/Outbox-Logik.
-->
<!--
Changelog
2025-11-25 – v008 – Outbox-Gating (UI + Handler gehärtet)
- Sichtbarkeit „Warteschlange erneut senden“ & Queue‑Banner strikt an Rechte (sync_basic oder sync_advanced oder Admin/Lokaladmin) UND Outbox‑Inhalt gekoppelt.
- Click‑Guards (Capture) auf „Warteschlange erneut senden“ und „Jetzt senden“ (Banner) – ohne Recht wird sauber abgebrochen.
- Manueller Sync‑Button bleibt wie zuvor an Rechte & Auto‑Sync gekoppelt; zusätzlich Schutz gegen DOM‑Manipulation (Capture).
- Keine Änderungen an Daten, Sync‑Ablauf oder Cloud‑Konfiguration.
-->
<!--
Changelog
2025-11-25 – v007 – Login-UX Polish (Fokus & Enter)
- Fokussteuerung beim Öffnen des Login-Dialogs: zuerst Benutzername (falls leer), sonst Passwort.
- Enter-Taste triggert den Login im gesamten Dialog (nicht nur in den beiden Inputs).
- Schutz gegen Doppelklick: Login-Button ignoriert schnelle Mehrfachklicks.
- Keine Änderungen an Logik, Daten, Rechten, Outbox/Sync.
-->
<!--
Changelog
2025-11-25 – v006 – Passwort‑UX (Minimum 4, Login-Precheck, Konto ändern)
- Login: Mindestlänge 4 Zeichen geprüft, klare Meldung, Enter-Submit in Benutzername/Passwort-Feldern.
- Konto: „Neues Passwort“/„Wiederholen“ prüfen (Länge ≥4, Gleichheit); Toggle „Anzeigen“ verdrahtet.
- Optional: Falls es einen „Benutzer-Passwort setzen“-Button gibt, wird ebenfalls Länge ≥4 geprüft.
- Keine Änderungen an Outbox-Gating/Sync/Cloud – reine UX-Guards.
-->
<!--
Changelog
2025-11-24 – v20ap (sauber, aus v20an) – Gruppen-Cleanup & Supabase-Keys Migration
- Remote-Gruppen-Bereinigung nutzt jetzt Groups_ID statt numerischem id.
- LocalStorage: neue Supabase-Keynamen mit Migration (lesen fällt auf alte baserow-Keys zurück; schreiben nur neue Keys).
- Basis: v20an (Buchungs‑Schnellsuche) – keine weiteren Änderungen.
-->
<!--
Changelog
2025-11-24 – v20an – Buchungs-Schnellsuche (Name/SKU)
- Im Buchungsdialog ein Suchfeld ergänzt: Filtert live nach Bezeichnung, Artikelnummer oder ID.
- Enter im Suchfeld springt in die Auswahlliste; erster Treffer wird vorgewählt.
- Keine Änderung an Buchungs-/Sync-Logik.
-->
<!--
Changelog
2025-11-24 – v20al – Gruppen-Editor Block ersetzt & Fragmente entfernt
- openGroupEditor: Block bis zum nächsten Funktionsheader ersetzt (robust, keine Fragmente).
- Stray 'saveJson(groupsKey, groups);' außerhalb einer Funktion entfernt.
- createNewGroup: 'perms' Schlüssel korrigiert (tolerant gegenüber alten '…'-Artefakten).
- uniqueGroupName: saubere Referenzimplementierung.
-->
<!--
Changelog
2025-11-24 – v20ai – Gruppe speichern Syntaxfix
- openGroupEditor() vollständig ersetzt (keine doppelten Fragmente mehr).
- Zentraler Speichern-Handler saveCurrentGroup() (falls zuvor fehlend) ergänzt.
- Fallback: Click-Delegation für #btnSaveGroup.
-->
<!--
Changelog
2025-11-24 – v20af – Gruppen „Speichern“ robust (saveCurrentGroup)
- Neuer zentraler Speichern-Handler saveCurrentGroup() (nutzt currentGroupId), inkl. Permissions, Persistenz, Cloud-Push.
- openGroupEditor bindet Save-Button direkt auf saveCurrentGroup(); zusätzlich globale Click-Delegation als Fallback.
- Keine Änderungen am Datenformat; UI/Flow unverändert.
-->
<!--
Changelog
2025-11-24 – v20ae – Outbox-Härtung (Rechte-Gate)
- 'Warteschlange erneut senden' und Queue-Banner werden nur angezeigt, wenn sync_basic ODER sync_advanced ODER Admin/Lokaladmin.
- 'Jetzt senden' ist für Unberechtigte deaktiviert und Handler prüft Berechtigung defensiv.
- Keine sonstigen Logikänderungen.
-->
<!--
Changelog
2025-11-24 – v20ac – Gruppen-Buttons endgültig gefixt (Wiring + Gate)
- canManageGroups() vollständig & robust (manage_users || isAdmin() || lv_admin '1'/'true'/'yes').
- DOMContentLoaded: Click-Handler für „Neue Gruppe“ / „Gruppe löschen“ verdrahtet; Sichtbarkeit per Gate.
- openGroupEditor: currentGroupId gesetzt; Delete-Button für System/Admin-Gruppen deaktiviert.
-->
<!--
Changelog
2025-11-24 – v20z – Gruppen-Buttons fix (Wiring + Lokaladmin)
- canManageGroups(): jetzt auch isAdmin() sowie lv_admin '1'/'true'/'yes' akzeptiert.
- Event-Wiring ergänzt: „Neue Gruppe“ und „Gruppe löschen“ werden geklickt → Handler aktiv.
- Delete-Button wird im Editor bei System/Admin-Gruppen deaktiviert (Sicherheit).
-->
<!--
Changelog
2025-11-24 – v20x – Supabase-UI-Wording bereinigt
- Einstellungsdialog „Cloud Sync (Supabase)“: klare Labels „Supabase URL (REST)“ und „Anon Key“.
- Hinweistext konkretisiert: erfordert Supabase URL (REST), Anon Key und Tabellennamen.
- Platzhalter beim Token erläutert („Anon Key (JWT)“). Funktional unverändert.
-->
<!--
Changelog
2025-11-24 – v20w – Supabase-Only Writes + requirePwKey bereinigt
- writeBrConfig(): schreibt nur noch Supabase-Keys (kein Mitschreiben der Legacy-Baserow-Keys).
- Migration bleibt beim Lesen aktiv (lsGetMigrate), Export/Import weiter kompatibel.
- requirePwKey: Doppeldefinition entfernt; readRequirePwFlag() liest Legacy-Key einmalig ein.
-->
<!--
Changelog
2025-11-24 – v20u – Migration Supabase → Supabase (Keys, Import/Export, Selftest)
- Neue Supabase-Keys im LocalStorage; Legacy-Baserow-Keys werden weiterhin gelesen (idempotente Migration).
- writeBrConfig schreibt neue Keys und parallel Legacy-Keys (Kompatibilität).
- Export enthält jetzt 'supabase' UND 'baserow'; Import bevorzugt 'supabase' (fällt auf 'baserow' zurück).
- Selftest liest Konfiguration über readBrConfig(); UI-Wording auf Supabase vereinheitlicht.
-->
<!--
Changelog
2025-11-24 – v20s – Passwort-Minimum auf 4 Zeichen
- Passwort-Validierung für „eigenes Passwort ändern“ und „Benutzer-Passwort setzen“ von 6 → 4 Zeichen reduziert.
- Keine Komplexitätsanforderungen (Groß/Klein/Sonderzeichen) – es zählt nur die Länge.
-->
<!--
Changelog
2025-11-24  v20o – Alerts-IIFE sauber geschlossen (Syntaxfix)
- Am Ende des Alerts-Gating-Skripts exakt eine schließende Zeile '})();' ergänzt
- Vorher: fehlende IIFE-Schließung führte zu „missing } after function body“
-->
<!--
Changelog
2025-11-24  v20n – readLS-Klammer & Syntaxfix
- Funktion readLS(k, def) mit schließender Klammer und Semikolons versehen
- Behebt „missing } after function body“ im Alerts-Gating-Block
-->
<!--
Changelog
2025-11-24  v20m – Doppelte IIFE-Schließung entfernt (Syntaxfix)
- Entfernt überzählige "})();" vor </script> im Alerts-Gating-Block
- Keine Logikänderungen; nur Syntaxstabilität
-->
<!--
Changelog
2025-11-24  v20l – Voll-Sync Report + Syntaxbereinigung
- Syntax-Stabilisierung am Datei-Ende (IIFE/Braces konsistent)
- Voll-Sync Report (Toast) mit Push/Pull-Kurzüberblick, nur für Full-/Push-/Pull-Operationen
-->
<!-- Changelog
2025-11-22, Neu V8 – ItemOps-Debugschalter:
- Sichtbare Einstellung „Mehrbenutzer‑Diagnose (ItemOps)“ in den Einstellungen ergänzt.
- Debug‑Flag (lvDebugItemOps) kann jetzt per Checkbox ein‑/ausgeschaltet und wird in localStorage gespeichert.
- Keine Änderungen an Beständen oder der eigentlichen Sync‑Logik.

-->

<!-- Changelog
2025-11-22, Neu V7 – ItemOps-Rebase lokal:
- ItemOps-Rebase-Hook lvItemOpsRebaseAfterPull erweitert: lokale ItemOps, die bereits in der Cloud-Tabelle stehen, werden aus lv_item_ops_local entfernt.
- Keine Bestandsänderung; Buchungs-/Sync-Logik bleibt unverändert.

-->

<!-- Changelog
2025-11-22, Neu V6 – Konfliktlösung (ItemOps-Rebase Trockenlauf):
- ItemOps-Rebase-Hook lvItemOpsRebaseAfterPull eingebaut; aktuell nur Trockenlauf nach Pull im zentralen Sync (keine Bestandsänderung).

2025-11-22, Neu V5 – Cloud-Sync Mehrbenutzer (zentraler Ablauf):
- Manueller Sync (⇅) nutzt jetzt den zentralen Sync-Ablauf runFullSync (mit ItemOps / Outbox).
- Bei Sync-Fehlern wird kein eigenständiger Cloud-Pull mehr erzwungen, um lokale Änderungen nicht zu überschreiben.
- Bestehende Cloud-Sync-Buttons im Einstellungsbereich (Pull/Push) bleiben unverändert.

2025-11-22, Neu V3 – Verlauf stabilisiert (Dateiversion nachgezogen):
- Inhaltlich identisch zu „Neu V2 – Versionsanzeige entfernt“.
- Dient als neue Arbeitsbasis (Dateiname wie besprochen).

2025-11-22 – v04
- Kategorie-Update wird nicht mehr beim Buchungsdialog ausgelöst, damit „Zuletzt geändert“ nach Buchungen stabil bleibt.
-->

<!--
Changelog
2025-11-22, Neu V2 – Versionsanzeige entfernt:
- Versionsanzeige im Programm entfernt (Kopfbereich, Einstellungen, UI-Prefs für Anzeige).
2025-11-22, Neu V1 – Neu-Basis:
- Dateiname & Arbeitsbasis neu aufgesetzt (Neu V1), keine inhaltlichen Codeänderungen.
-->

<!--
Changelog
2025-11-21, v3 – Admin-Login (lokal) stabilisiert:
- Admin-Login (lokal) setzt jetzt eine echte Sitzung („Admin (lokal)“), damit Login-Gate und PIN-Schutz nicht in einer Schleife hängen.
- Keine Änderung an Cloud-/Sync-Logik.

2025-11-21, v2 – Versionsanzeige & Toggle:
- Version-Anzeige „v1“ im Kopfbereich mit Umschalter in den Einstellungen.
- UI-Voreinstellungen werden in lv_ui_prefs_v1 gespeichert.

2025-11-21, v1 – Neustandard (Basis: v103_RechteReset):
- Technische Grundlage aus Lagerverwaltung_v103_RechteReset übernommen.
- Keine funktionalen Änderungen; nur Versions-Reset und neuer Basisstand.
-->


<!--
Changelog
2025-11-18, v69 – Cloud-Sync-Settings erweitert (ItemOps-Feld sichtbar):
- Neue Felder in den Supabase-Einstellungen: Tabelle „itemops“ (Tabellenname) und SKU-Feldname in Items.
- Werte werden in localStorage gespeichert (lagerverwaltung_supabase_tbl_itemops / lagerverwaltung_supabase_sku_field).
- Export/Import der Cloud-Sync-Einstellungen (JSON) enthält nun auch tblItemOps und skuField.
- Keine Änderungen an Buchungs- oder Sync-Logik.
-->

<!--
Changelog
2025-11-18, v67 – Cloud-Sync-Einstellungen Import (JSON):
- Neues UI: Button „Cloud‑Sync‑Import (JSON)“ + verstecktes Dateifeld im Bereich „Cloud Sync (Supabase)“.
- Neue Funktionen startImportCloudSyncConfig()/importCloudSyncConfigFromText(): lesen eine zuvor exportierte JSON-Datei ein.
- Nach Bestätigung werden nur Cloud-Sync-Einstellungen (URL, Token, Tabellen-IDs, Auto-Sync, Login-Pflicht) in localStorage übernommen.
- Keine Änderungen an Buchungs-/Sync-Logik, Lagerdaten oder Historie.
-->

<!--
Changelog
2025-11-18, v66 – Cloud-Sync-Einstellungen Export (JSON):
- Zusätzlicher Button im Bereich „Cloud Sync (Supabase)“: Cloud‑Sync‑Export (JSON).
- Neue Funktion exportCloudSyncConfig(), die readBrConfig() nutzt und die Konfiguration als JSON-Datei herunterlädt.
- Keine Änderungen an Sync-Logik, Buchungen, Historie oder Berechtigungen.
-->

<!--
Changelog
2025-11-17, v65 – Mehrbenutzer: persistente Pending-Operationen + stabile Rebase/Push.
- Neue Pending-Liste (localStorage 'lv_pending_ops'): qty-Deltas werden dort zwischengespeichert.
- Nach Pull (Rebase): Pending-Deltas additiv anwenden, fehlende qty-Logs ergänzen, als applied markieren.
- Vor Push: Pull → Rebase; Nach erfolgreichem Push: zugehörige Pending-ops entfernen.
- Verhindert „Zurückspringen“ und „verschwundene Buchung nach Sync“, auch bei App-Neustart.
-->

<!--
Changelog
2025-11-17, v64 – Mehrbenutzer (additiver Rebase):
- Nach Pull: lokale 'qty'-Ops mit opId, die serverseitig noch nicht angewendet sind, werden additiv auf den aktuellen Stand gerechnet (pro Artikel).
- Vor Push: Pull → Rebase → Push. Verhindert, dass Bestände nach Sync auf alte Werte zurückspringen.
- Defensiv, nur additiv, keine Änderungen an anderen Flows.
-->

<!--
Changelog
2025-11-17, v63 – Mehrbenutzer Grundgerüst (vorsichtig):
- Pull-vor-Push: cloudPushAll/manualSync rufen vor dem Senden immer cloudPullAll() auf.
- opId-Tags: qty-Logs und Outbox-Jobs erhalten eine eindeutige opId (uuid) für Idempotenz.
- Lokale Idempotenz: pro Item werden angewendete opIds notiert; doppelte Anwendung wird übersprungen.
- Optional: mehrere lokale qty-Ops pro Item werden vor dem Push zusammengefasst.
-->

<!--
Changelog
2025-11-17, v62 – Historie doppel-fest: robustere De-Dup (Anzeige & Daten).
- Anzeige: Gruppierung ignoriert leeren Benutzer; Schlüssel = (Sekunde, Artikel, Aktions-Vorzeichen). 0-Delta wird entfernt, wenn ein passender ±n-Eintrag existiert.
- Daten: Konsolidierung entfernt 'in/out (0)' neben einem 'qty (±n)' in gleicher Sekunde pro Item, unabhängig vom Benutzer.
-->

<!--
Changelog
2025-11-17, v61 – Buchungsschreiber vereinfacht: pro Buchung nur 1 Logeintrag.
- Wrapper für gängige Log-Helfer (addItemLog/logChange/logBooking/pushLog) entfernen 0-Delta in/out-Nebenlogs bei vorhandenen qty±n im selben Zeitpunkt
- Keine Änderungen an UI/Flows; v58/v59 bleiben als Sicherheitsnetz aktiv
-->

<!--
Changelog
2025-11-17, v58 – Historie: Datenebene konsolidiert (0-Delta-Duplikate werden beim Speichern von Items entfernt).
2025-11-17, v57 – Historie (Anzeige) de-dupliziert 0-Delta-Duplikate.
2025-11-17, v55 – Persistenz-Diagnose-Button.
2025-11-17, v53 – Remember-ID-Entflechtung.
2025-11-17, v52 – Sitzungslabel + Status-Refresh.
2025-11-17, v51 – Remember-Login Fix (duplizierte Checkboxen).
-->



<!DOCTYPE html>
<!-- Changelog
2025-11-21 – v04 – Sync: Push ohne verstecktes Vor-Pull
- Pull-vor-Push-Wrapping für cloudPushAll/processOutbox/manualSync entschärft (kein implizites Vor-Pull mehr)
- Keine Änderungen an Datenformaten oder Editor-Logik
-->

<html lang="de">
<head>
<!-- V50: Einstellungen » Sitzung zeigt jetzt 'Anmeldung: Dauerhaft | Nur Sitzung | —'; Init liest Session aus local+sessionStorage; Rest wie V47 -->
<!-- V47: Excel-Export nutzt XLSX.writeFile (robuster Download); Spalte Kategorie bleibt; Rest wie V46 -->
<!-- V46: Excel-Export Handler sauber ersetzt (inkl. Spalte Kategorie); Rest wie V45 -->
<!-- V45: Excel Export/Import – Spalte "Kategorie" exportieren & optional importieren (mit Normalisierung); Rest wie V44 -->
<!-- V44: Import (JSON) behält Kategorie – Mapping ergänzt; sonst wie V43 -->
<!-- V43: Login-Gate UX – klarere Meldungen & Fokusführung; keine Logikänderung -->
<!-- V40: UI-Prefs – Kategorie-Filter merkt Auswahl (localStorage lv_ui_prefs_v1); sonst unverändert zu V39 -->
<!-- V39: Kategorie-Kürzel in Badge integriert (zentriert rechts, farblich adaptiert), keine Größenänderung -->
<!-- V38: Kategorie-Chip Position feinjustiert (leicht weiter links & unten), keine Layoutänderung -->
<!-- V37: Karten – Kategorie-Chip (NW/ZM/VB/ME/WG), keine Layoutänderung; CAT_OPTIONS-Reihenfolge aktualisiert -->
<!-- V36: Sauberer CSV-Export (nur Handler-Body ersetzt) + V34 CSS beibehalten; Rest wie V33 -->
<!-- V33: Karten-Ribbon korrekt in/out gemappt; sonst wie V32 -->
<!-- V32: Karten-Ribbon nutzt nun .badge.in (grün) / .badge.out (blau); Rest wie V31 -->
<!-- V31: Karten-Ribbon Farben korrigiert (Ausgang=blau, Eingang=grün) + Badge CSS sichergestellt; Rest wie V30 -->
<!-- V30: Editor-Verlauf farbig (Badge in/out) – nur renderHistory-Body ersetzt; Rest exakt V23 -->
<!-- V21: Nur Button-Farben getauscht (Eingang=grün .ok, Ausgang=blau .primary); sonst exakt wie V18 -->
<!-- V18: Farben getauscht (Ausgang=blau, Eingang=grün) & Historie-Header korrigiert; sonst unverändert -->
<!-- V17: Historie – Hervorhebung für Zugang/Entnahme (Badges, farbige Deltas); sonst unverändert -->
<!-- V16: Edit-Dialog Menge – nur EIN Logeintrag (qty) + Datum-Autofill; sonst unverändert -->
<!-- V15: Edit-Dialog Menge verhält sich wie Buchung (Log + Eingangs/Ausgangsdatum); sonst unverändert -->
<!-- V14: Editor-Menge: Plus/Minus-Buttons aktiviert; sonst unverändert -->
<!-- V13: Karten-Hintergrund an Farb-Schema gekoppelt (lesbar auf Desktop/Light-Mode); sonst unverändert -->
<!-- V12: Kategorie-Sync automatisch aktivieren, sobald das Cloud-Feld vorhanden ist; sonst unverändert -->
<!-- V11: Historie ergänzt – logge Kategorie-Änderungen (nur bei Änderung); sonst unverändert -->
<!-- V10: Kategorie-Editor gehärtet (ID-basiert, Fallback SKU); sonst unverändert -->
<!-- V9: Mapping-Flag für Kategorie (itemToRow/rowToItem) via Spread; Default=aus; sonst unverändert -->
<!-- V8: Excel-Export ergänzt um Spalte "Kategorie"; sonst unverändert -->
<!-- V7: Print-Ansicht ergänzt um Spalte "Kategorie" (gezielt); Overview-Header bereinigt; sonst unverändert -->
<!-- V6: Print-Ansicht ergänzt um Spalte "Kategorie"; sonst unverändert -->
<!-- V5: Fix Mitgliederliste: Username-Spalte wieder angehängt; sonst unverändert -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" href="kgt-192.png">

  <meta name="description" content="Lagerverwaltung mit Supabase‑Sync, Benutzer & Rechte, Passwort-Login, Offline‑Outbox, Historie und Ein‑Klick‑Cloud‑Backup.">
  <style>
/* V39: Kategorie-Chip – integriert in Badge */
.card > .badge{ position: relative; padding-right: 40px; } /* Platz für Chip rechts */
.card > .badge .chip.cat{
  position: absolute; top: 50%; right: 10px; transform: translateY(-50%);
  padding: 2px 8px; border-radius: 999px;
  border: 1px solid currentColor; background: transparent;
  font-size: 11.5px; line-height: 1; font-weight: 600; opacity:.9;
  pointer-events: none;
}
@media (max-width: 640px){
  .card > .badge{ padding-right: 36px; }
  .card > .badge .chip.cat{ right: 8px; font-size: 11px; padding: 1px 6px; }
}

/* V34: UI-Polish – Karten-Kontrast + Editor-Verlauf (nur CSS) */
.card .meta .lbl{ opacity:.80; }
.card .muted{ opacity:.85; }

#history{ white-space: normal; word-break: break-word; }
#history > div{ margin: 4px 0; line-height: 1.35; }
#history .badge{ vertical-align: baseline; }
#history strong{ font-weight: 600; }


/* V17: History badges */
.badge{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; line-height:1.4; border:1px solid var(--border); background: var(--panel); }
.badge.in{ color:#1c6b59; background: rgba(39,194,157,.15); border-color: rgba(39,194,157,.35); }
.badge.out{ color:#2e4d8b; background: rgba(79,140,255,.12); border-color: rgba(79,140,255,.35); }
td .delta-pos{ color:#1c6b59; font-weight:600; }
td .delta-neg{ color:#2e4d8b; font-weight:600; }

    /* === UI polish: queue banner + blue arrows + spacing === */
    .queue-banner{max-width:1200px;margin:8px auto 0;padding:10px 12px;display:flex;align-items:center;gap:10px;background:rgba(255,176,32,.12);border:1px solid rgba(255,176,32,.45);border-radius:12px;color:#d9a336;box-shadow:var(--shadow)}
    .queue-banner .btn{padding:8px 12px}
    details.settings{margin:10px 0}
    details.settings summary{list-style:none;display:flex;align-items:center;gap:10px;padding:14px 12px;background:var(--panel-2);border:1px solid var(--border);border-radius:12px;cursor:pointer}
    details.settings summary::-webkit-details-marker{display:none}
    details.settings summary::before{content:'▸';color:var(--brand-2);font-weight:900}
    details.settings[open] summary::before{content:'▾';color:var(--brand-2)}
    details.settings > *:not(summary){padding:10px 2px 2px 2px}

    :root{
      --bg: #0b0c0f;
      --panel: #12151a;
      --panel-2: #171b22;
      --text: #e9eef5;
      --muted: #a7b0be;
      --brand: #4f8cff;
      --brand-2: #79a8ff;
      --ok: #27c29d;
      --warn: #ffb020;
      --border: #252a33;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg: #f7f8fb;
        --panel: #ffffff;
        --panel-2: #f3f5f9;
        --text: #0b0c0f;
        --muted: #4b5563;
        --brand: #2563eb;
        --brand-2: #3b82f6;
        --ok: #059669;
        --warn: #d97706;
        --border: #e5e7eb;
        --shadow: 0 10px 30px rgba(2,6,23,.08);
      }
    }
    *{ box-sizing: border-box }
    html,body{ height:100% }
    body{
      margin:0;
      font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans";
      color: var(--text);
      background: var(--bg);
      min-height:100%;
    }
    .app{ max-width: 1200px; margin: 24px auto 60px; padding: 0 16px; }
    header.appbar{
      position: sticky; top:0; z-index: 30; backdrop-filter: blur(8px);
      background: rgba(11,12,15,.7); border-bottom: 1px solid var(--border);
    }
    .appbar-inner{ max-width:1200px; margin:0 auto; padding:12px 16px; display:flex; flex-direction:column; gap:10px; position:relative; }
    .brandline{ display:flex; align-items:center; gap:10px; }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.2px; }
    .brand .logo{ min-width:40px; height:28px; padding:0 8px; border-radius:8px; display:grid; place-items:center;
      background: linear-gradient(135deg, var(--brand), var(--ok)); color:white; box-shadow: var(--shadow); opacity:.9; font-weight:700; letter-spacing:.5px }

    .menu-btn{
      position:absolute; right:16px; top:10px; z-index:5;
      width:40px; height:40px; border-radius:12px; border:1px solid var(--border);
      background: var(--panel-2); color:var(--text);
      display:grid; place-items:center; cursor:pointer; box-shadow: var(--shadow);
      font-size: 20px; font-weight:900;
    }
    .actions{ display:flex; flex-direction:column; gap:10px; margin-top:10px; }
    .row2col{
      display:grid; grid-template-columns: repeat(2, minmax(160px, 1fr)); gap:8px;
      max-width: 760px; margin: 0 auto; width: 100%;
    }
    .row2col .btn{ width:100%; }
    .btn{
      appearance:none; border:1px solid var(--border); background: var(--panel-2); color:var(--text);
      padding:12px 16px; border-radius:12px; cursor:pointer; font-weight:700; box-shadow: var(--shadow);
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      text-align:center;
    }
    .btn[disabled]{ opacity:.55; cursor:not-allowed }
    .btn:hover{ transform: translateY(-1px); }
    .btn.primary{ background: linear-gradient(180deg, var(--brand-2), var(--brand)); border-color: #2d4f94; color:#fff; }
    .btn.ok{ background: linear-gradient(180deg, #5ce4c3, var(--ok)); color: #07221a; border-color: #167e63 }
    .btn.warn{ background: linear-gradient(180deg, #ffd08a, var(--warn)); color:#351f02; border-color: #a3630b }
    .menu-btn.push-btn{ right:64px; background: linear-gradient(180deg, var(--brand-2), var(--brand)); color:#fff }
    .input, select, textarea{
      width:100%; border:1px solid var(--border); background: var(--panel); color: var(--text);
      padding:12px 12px; border-radius:12px; outline:none; box-shadow:var(--shadow);
    }
   .controls{
      display:grid; grid-template-columns: 1fr auto; gap:10px; padding: 12px; background: rgba(23,27,34,.6); border:1px solid var(--border); border-radius:16px; margin-top:12px;
    }
    .cards{ display:grid; gap:14px; margin-top:16px; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); }
    .card{ background: linear-gradient(180deg, var(--panel), var(--panel-2)); border:1px solid var(--border);
      border-radius: var(--radius); padding:14px; box-shadow: var(--shadow); display:flex; flex-direction:column; gap:10px; min-height: 185px; }
    .card:hover{ outline: 2px solid rgba(79,140,255,.3) }
    .card h3{ margin:0; font-size: 18px; line-height:1.2 }
    .muted{ color: var(--muted) }
    .badge{ display:inline-flex; align-items:center; gap:8px; font-weight:700; background: var(--panel); border:1px solid var(--border); border-radius:999px; padding:6px 10px; }
    .badge.ok{ background: rgba(39,194,157,.15); border-color: rgba(39,194,157,.35); color: #1c6b59 }
    .badge.warn{ background: rgba(255,176,32,.15); border-color: rgba(255,176,32,.35); color: #6f4a0a }
    .badge.neutral{ background: rgba(79,140,255,.12); border-color: rgba(79,140,255,.35); color: #2e4d8b }
    .row{ display:flex; flex-wrap:wrap; gap:8px; align-items:center }
    .grow{ flex:1 }
    .kv{ display:grid; grid-template-columns: 120px 1fr; gap:8px; align-items:center }
    .kv strong{ color: var(--muted) }
    .divider{ height:1px; background: var(--border); margin:10px 0 }
    dialog.modal{ width:min(960px, 96vw); border:1px solid var(--border); border-radius: 20px; padding:0; background: var(--panel); color: var(--text); box-shadow: var(--shadow); }
    .modal[open]{ display:block }
    .modal header{ padding:14px 16px; border-bottom:1px solid var(--border); display:flex; align-items:center; justify-content:space-between }
    .modal .content{ padding:16px }
    .grid{ display:grid; gap:12px; grid-template-columns: 1fr }
    @media (min-width: 680px){ .grid.cols-2{ grid-template-columns: 1fr 1fr } }
    .modal footer{ padding:14px 16px; border-top:1px solid var(--border); display:flex; gap:8px; justify-content:flex-end }
    .empty{ text-align:center; padding:40px 10px; color: var(--muted) }
    .toast{ position: fixed; right: 16px; bottom: 20px; z-index: 60; display:none; max-width: 90vw; background: var(--panel); border:1px solid var(--border); border-radius: 12px; padding: 10px 12px; box-shadow: var(--shadow); }
    .toast.show{ display:block; animation: pop .18s ease }
    @keyframes pop{ from{ transform: translateY(6px); opacity:0 } to{ transform:none; opacity:1 } }
    .sr-only{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden }
    .hint{ color: var(--muted); font-size: 14px; }
    .perm-row{ margin-bottom:6px; }
    .perm-hint{ margin-left:26px; }
    .table-wrap{ overflow:auto; border:1px solid var(--border); border-radius:12px; }
    table.list{ border-collapse: collapse; width:100%; min-width: 760px; }
    table.list th, table.list td{ border-bottom:1px solid var(--border); padding:8px 10px; text-align:left; }
    table.list thead th{ background: var(--panel-2); position: sticky; top: 0; z-index: 1; }
    .perm-chk{ width:20px; height:20px; vertical-align: middle; }
    .badge-role{ display:inline-block; padding:2px 8px; border-radius:999px; font-weight:700; font-size:12px; background: var(--panel-2); border:1px solid var(--border); }
    .number{ display:grid; grid-template-columns: auto 1fr auto; gap:6px; align-items:center }
    .number button{ border:1px solid var(--border); background:var(--panel-2); color:var(--text); padding:8px 12px; border-radius:10px; cursor:pointer }
    .number input{ text-align:center }
    .statusbar{ max-width:1200px; margin:8px auto 0; padding:0 16px 8px; color:var(--muted); display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    .pill{ border:1px solid var(--border); background:var(--panel-2); padding:4px 10px; border-radius:999px; font-size:13px }
    .link{ text-decoration: underline; cursor:pointer }

/* compact icon button for header */
.btn.icon{min-width:40px;width:40px;padding:8px;border-radius:12px;display:inline-flex;align-items:center;justify-content:center}


/* header title tidy */
.apptitle{
  font-size: clamp(20px, 5.5vw, 28px);
  line-height: 1.15;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* app version pill */
.appbar .brandline{align-items:center;gap:12px;min-width:0}


/* compact cards */
.card{ padding:10px 12px; gap:6px }
.card .kv{ margin-top:4px }


/* compact meta grid for cards */
.card .meta{ display:grid; grid-template-columns: 1fr 1fr; gap:6px 16px; align-items:start; }
.card .meta .lbl{ font-size:12px; opacity:.7; }
.card .meta .val{ font-weight:600; }
.card .meta .subl{ font-size:11px; opacity:.65; }
.card .meta .subv{ font-variant-numeric: tabular-nums; opacity:.92; }


  .lv-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle}
  .lv-dot-ok{background:#22c55e}.lv-dot-warn{background:#f59e0b}.lv-dot-err{background:#ef4444}

</style>

<script id="lv38-cat-map">
(function(){
  // Zentrales Mapping für Kategorien → Kürzel. Nicht-invasiv, nur Datenobjekt.
  function nrm(s){ return String(s||'').toLowerCase().trim()
    .replace(/[äÄ]/g,'ae').replace(/[öÖ]/g,'oe').replace(/[üÜ]/g,'ue'); }
  var base = {
    "Zusatzmaterial":"ZM",
    "Verbrauchsmaterial":"VBR",
    "Messtechnik Nord":"ME",
    "Werkzeug":"WG",
    "Heizkostenverteiler":"HKV",
    "Rauchwarnmelder":"RWM",
    "Rauchmelder":"RWM",
    "Wärmemengenzähler":"WMZ",
    "Wärmengenzähler":"WMZ",
    "Wärmezähler":"WMZ",
    "Kaltwasserzähler":"KWZ",
    "Warmwasserzähler":"WWZ",
    // Kurzformen direkt
    "ZM":"ZM","VBR":"VBR","ME":"ME","WG":"WG",
    "HKV":"HKV","RWM":"RWM","WMZ":"WMZ","KWZ":"KWZ","WWZ":"WWZ",
    // Legacy
    "VB":"VBR"
  };
  var map = {};
  function add(k, v){
    if (!k) return;
    var u = String(k).toUpperCase();
    var l = nrm(k);
    map[k] = v; map[u] = v; map[l] = v;
  }
  Object.keys(base).forEach(function(k){ add(k, base[k]); });

  // Exponieren (ohne vorhandene User-Definition zu überschreiben)
  if (typeof window.CAT_SHORT !== 'object' || !window.CAT_SHORT){
    window.CAT_SHORT = map;
  } else {
    // Merge sanft
    for (var k in map){ if (!(k in window.CAT_SHORT)) window.CAT_SHORT[k] = map[k]; }
  }
})();</script>


<style id="pwDlgGuardCSS">
  /* v40: Passwort-Dialog standardmäßig verstecken */
  #pwDlg { display: none !important; }
  #pwDlg.lv-visible { display: block !important; }
</style>

</head>
<body>
  <header class="appbar">
    <div class="appbar-inner"><div class="brandline">
        <div class="brand" aria-label="Lagerverwaltung">
          <div class="logo" aria-hidden="true">KGT</div>

      <button id="btnManualPush" class="menu-btn push-btn" title="Manueller Sync (hochladen & aktualisieren)" type="button" aria-label="Manueller Sync (hochladen & aktualisieren)" onclick="manualSync()">⇅</button>
<button id="btnMenu" class="menu-btn" title="Einstellungen" type="button" aria-label="Einstellungen">☰</button>

          <h1 class="apptitle" aria-label="Titel">
            Lagerverwaltung
          </h1>
        </div>
      </div>
      <div class="actions">
        <div class="row2col">
          <button class="btn" id="btnOverview" type="button">Materialübersicht</button>
          <button class="btn" id="btnNew" type="button">Material anlegen</button>
        </div>
        <div class="row2col">
          <button class="btn ok" id="btnBookIn" type="button">Wareneingang buchen</button>
          <button class="btn primary" id="btnBookOut" type="button">Warenausgang buchen</button>
        </div>
      </div>
    </div>
  </header>
  <div id="queueBanner" class="queue-banner" style="display:none"><strong>⚠ Warteschlange:</strong><span id="queueBannerText">Einträge warten auf Übertragung.</span><span class="grow"></span><button class="btn" id="queueSendNow" type="button" onclick="queueSendNowClick()">Jetzt senden</button><button class="btn" id="queueOpenSettings" type="button">Öffnen</button></div>
  <div class="statusbar" id="statusbar">
    <span class="pill" id="statusUser">Benutzer: —</span>
    <span class="pill" id="statusRole">Gruppe: —</span>
    <span class="pill" id="statusCloud">Cloud: offline</span>
    <span class="pill" id="statusQueue" style="display:none">Sync ausstehend: 0</span>
    <span class="pill"><span class="link" id="openHistory">Historie</span></span>
    <span class="pill"><span class="link" id="openAlerts">Warnungen</span></span>
  </div>

  <main class="app">
    <section class="controls" aria-label="Steuerung">
      <input id="search" class="input" type="search" placeholder="Suche nach Bezeichnung oder Artikelnummer ..." />
      <select id="sortSelect" title="Sortierung">
        <option value="updated_desc">Zuletzt geändert</option>
        <option value="name_asc">Bezeichnung (A–Z)</option>
        <option value="sku_asc">Artikelnummer (A–Z)</option>
        <option value="qty_desc">Menge (absteigend)</option>
        <option value="in_asc">Eingangsdatum</option>
        <option value="out_asc">Ausgangsdatum</option>
      </select>
    </section>
    <section id="cards" class="cards" aria-live="polite"></section>
    <div id="empty" class="empty" hidden>
      <p>Noch keine Artikel vorhanden.</p>
      <p class="muted">Lege zuerst Material an.</p>
    </div>
  </main>

  <!-- Toast -->
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <!-- LOGIN (mit Passwort) -->
  <dialog id="login" class="modal">
    <header>
      <strong>Anmeldung</strong>
      <button class="btn" style="padding:8px 12px" id="btnLoginClose" type="button">Schließen</button>
    </header>
    <div class="content">
      <p class="hint">Bitte Benutzername und Passwort eingeben. Benutzer werden vom Admin unter <i>Einstellungen → Benutzer & Zuweisung</i> angelegt.</p>
      <div class="grid cols-2">
        <div class="grid">
          <label for="loginEmail">Benutzername</label>
          <input id="loginEmail" class="input" placeholder="Benutzername" autocomplete="username" type="text">
        </div>
        <div class="grid">
          <label for="loginPass">Passwort</label>
          <input id="loginPass" class="input" type="password" placeholder="••••••••" autocomplete="current-password">
        </div>
        <div class="grid">
          <label>&nbsp;</label>
          <label><input type="checkbox" id="loginRemember"> Angemeldet bleiben</label>
        </div>
      </div>
      <div id="loginInfo" class="hint" style="margin-top:8px; display:none"></div>
    </div>

    <div id="adminPinInline" class="card" style="max-width:360px; margin:16px auto 4px; display:none">
      <h3>Admin (lokal)</h3>
      <p class="hint" style="margin-top:-6px">Zur Sicherheit bitte die PIN eingeben.</p>
      <div class="grid" style="margin-top:10px">
        <label for="adminPinInput">PIN</label>
        <input id="adminPinInput" class="input" type="password" inputmode="numeric" pattern="[0-9]*" maxlength="6" placeholder="••••" autocomplete="off">
      </div>
      <footer class="row">
        <button class="btn" id="adminPinCancel" type="button">Abbrechen</button>
        <span class="grow"></span>
        <button class="btn primary" id="adminPinOk" type="button">Weiter</button>
      </footer>
    </div>

    <footer>
      <button class="btn" id="btnLoginAdminLocal" type="button" title="Nur für Ersteinrichtung">Als Admin (lokal) fortfahren</button>
      <span class="grow"></span>
      <button class="btn primary" id="btnLoginGo" type="button">Anmelden</button>
    </footer>
  </dialog>

  <!-- Material-Editor -->
  <dialog id="modal" class="modal">
    <header>
      <strong id="modalTitle">Material</strong>
      <button class="btn" style="padding:8px 12px" id="btnClose" type="button">Schließen</button>
    </header>
    <div class="content">
      <form id="form" class="grid cols-2" onsubmit="return false">
        <div class="grid">
          <label for="name">Artikelbezeichnung</label>
          <input class="input" id="name" required placeholder="z. B. Wasserzähler DN15" />
        </div>
        <div class="grid">
          <label for="sku">Artikelnummer</label>
          <input class="input" id="sku" required placeholder="z. B. WZ-15-2025" />
          <small id="skuHint" class="muted"></small>
        </div>
        <div class="grid">
          <label for="qty">Menge</label>
          <div class="number">
            <button type="button" id="qtyMinus" title="–1">–</button>
            <input id="qty" type="number" inputmode="numeric" min="0" step="1" value="0" />
            <button type="button" id="qtyPlus" title="+1">+</button>
          </div>
        </div>
        <div class="grid">
          <label for="changeReason">Info zur Mengenänderung (optional)</label>
          <input class="input" id="changeReason" placeholder="z. B. Inventur, Korrektur, Ausbuchung ..." />
        </div>
        <div class="grid">
          <label for="inDate">Eingangsdatum</label>
          <input class="input" id="inDate" type="date" />
        </div>
        <div class="grid">
          <label for="outDate">Ausgangsdatum</label>
          <input class="input" id="outDate" type="date" />
        </div>
        <div class="grid" style="grid-column:1/-1">
          <label for="notes">Notiz (optional)</label>
          <input class="input" id="notes" placeholder="z. B. Lagerort, Besonderheiten ..." />
        </div>
      </form>
      <div class="divider"></div>
      <details id="historyWrap">
        <summary><b>Änderungshistorie</b> (neueste zuerst)</summary>
        <div id="history" class="log"></div>
      </details>
    </div>
    <footer>
      <button class="btn" style="padding:8px 12px" id="btnDelete" type="button" hidden>Löschen</button>
      <span class="grow"></span>
      <button class="btn" style="padding:8px 12px" id="btnCancel" type="button">Abbrechen</button>
      <button class="btn primary" id="btnSave" type="button">Speichern</button>
    </footer>
  </dialog>

  <!-- Buchungsdialog -->
  <dialog id="book" class="modal">
    <header>
      <strong id="bookTitle">Buchen</strong>
      <button class="btn" style="padding:8px 12px" id="btnBookClose" type="button">Schließen</button>
    </header>
    <div class="content">
      <form id="bookForm" class="grid" onsubmit="return false">
        <div class="grid" id="bookItemRow">
          <label for="bookItem">Material</label>
          <input id="bookSearch" class="input" type="search" placeholder="Suchen (Bezeichnung oder Artikelnummer) …" />
<select id="bookItem" class="input"></select>
        </div>
        <div class="grid cols-2">
          <div class="grid">
            <label for="bookDate">Datum</label>
            <input id="bookDate" class="input" type="date" />
          </div>
          <div class="grid">
            <label for="bookQty">Mengenänderung (optional)</label>
            <div class="number">
              <button type="button" id="bookQtyMinus">–</button>
              <input id="bookQty" type="number" inputmode="numeric" min="0" step="1" value="0" />
              <button type="button" id="bookQtyPlus">+</button>
            </div>
            <small class="muted" id="bookQtyHint"></small>
          </div>
        </div>
        <div class="grid">
          <label for="bookReason">Info (optional)</label>
          <input id="bookReason" class="input" placeholder="z. B. Lieferung, Auslieferung, Inventur, Korrektur ..." />
        </div>
      </form>
    </div>
    <footer>
      <span class="grow"></span>
      <button class="btn" id="btnBookSave" type="button">Buchung speichern</button>
    </footer>
  </dialog>

  <!-- Materialübersicht -->
  <dialog id="overview" class="modal">
    <header>
      <strong>Materialübersicht</strong>
      <button class="btn" style="padding:8px 12px" id="btnOverviewClose" type="button">Schließen</button>
    </header>
    <div class="content">
      <div class="row" style="margin-bottom:10px;">
        <input id="overviewSearch" class="input" placeholder="In Übersicht suchen ..." style="max-width:420px;">
<select id="overviewCat" class="input" style="min-width:180px;margin-left:8px"><option value="__ALL__">Alle Kategorien</option><option value="__NONE__">Kategorielos</option><option>Neuware</option><option>Zusatzmaterial</option><option>Werkzeug</option><option>Verbrauchsmaterial</option></select>
        <span class="grow"></span><span class="muted" id="overviewCount"></span>
      </div>
      <div class="table-wrap">
        <table class="list" id="overviewTable">
          <thead>
            <tr>
              <th>Artikelbezeichnung</th>
              <th>Artikelnummer</th>
              <th>Kategorie</th>
<th style="width:120px">Menge</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <footer>
      <button class="btn" style="padding:8px 12px" id="btnOverviewExport" type="button">Export</button>
      <span class="grow"></span>
      <button class="btn primary" id="btnOverviewOk" type="button">OK</button>
    </footer>
  </dialog>

  <!-- Historie (global) -->
  <dialog id="historyDlg" class="modal">
    <header>
      <strong>Historie</strong>
      <button class="btn" style="padding:8px 12px" id="btnHistoryClose" type="button">Schließen</button>
    </header>
    <div class="content">
      <div class="row" style="gap:8px; margin-bottom:8px;">
        <input id="histSearch" class="input" placeholder="Suche (Artikel, Grund, Benutzer)..." style="max-width:360px">
        <select id="histType" class="input" style="max-width:200px">
          <option value="">Alle Aktionen</option>
          <option value="qty">Mengenänderung</option>
          <option value="in">Eingang</option>
          <option value="out">Ausgang</option>
        </select>
        <input id="histFrom" type="date" class="input" style="max-width:170px">
        <input id="histTo" type="date" class="input" style="max-width:170px">
        <span class="grow"></span>
        <span id="histCount" class="muted"></span>
      </div>
      <div class="table-wrap">
        <table class="list" id="historyTable">
          <thead>
            <tr>
              <th>Zeitpunkt</th>
              <th>Benutzer</th>
              <th>Aktion</th>
              <th>Artikel</th>
              <th>Delta</th>
              <th>Info</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
    <footer>
      <button class="btn" id="btnHistoryExport" type="button">Export (CSV)</button>
      <button class="btn" id="btnHistoryClear" type="button" style="margin-left:8px">Historie löschen</button>
      <span class="grow"></span>
      <button class="btn primary" id="btnHistoryOk" type="button">OK</button>
    </footer>
  </dialog>

<dialog id="alertsDlg" class="modal">
  <header>
    <strong>Bestandswarnungen</strong>
    <button class="btn" id="btnAlertsClose" type="button" style="padding:8px 12px">Schließen</button>
  </header>
  <div class="content">
    <div class="row" style="gap:8px; margin-bottom:8px;">
      <select id="alertsFilter" class="input" style="max-width:220px">
        <option value="ALL">ALLE Artikel</option>
        <option value="ACTIVE">AKTIV</option>
        <option value="TRIGGERED">AUSGELÖST</option>
      </select>
      <span id="alertsCount" class="pill">0 Einträge</span>
    </div>
    <table id="alertsTable" class="table" style="width:100%">
      <thead>
        <tr>
          <th style="text-align:left">Artikel</th>
          <th style="text-align:right">Bestand</th>
          <th style="text-align:center">Aktiv</th>
          <th style="text-align:right; min-width:140px">Schwellwert</th>
          <th style="text-align:left">Status</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</dialog>

<dialog id="stockWarnPopup" class="modal">
  <header>
    <strong>Bestandswarnung</strong>
    <button class="btn" id="btnWarnPopupClose" type="button" style="padding:8px 12px">OK</button>
  </header>
  <div class="content">
    <div id="warnList" style="display:flex; flex-direction:column; gap:6px"></div>
  </div>
  <footer style="display:flex; gap:8px; justify-content:flex-end; padding:12px">
    <button class="btn" id="btnWarnPopupOrder" type="button">Bestellt</button>
    <button class="btn" id="btnWarnPopupOk" type="button">OK</button>
  </footer>
</dialog>



  <!-- Backups (Cloud) -->
  <dialog id="backupsDlg" class="modal">
    <header>
      <strong>Cloud‑Backups</strong>
      <button class="btn" style="padding:8px 12px" id="btnBackupsClose" type="button">Schließen</button>
    </header>
    <div class="content">
      <div class="table-wrap">
        <table class="list" id="backupsTable">
          <thead>
            <tr>
              <th>Zeitpunkt</th>
              <th>Autor</th>
              <th>Version</th>
              <th>Größe (KB)</th>
              <th style="width:240px">Aktionen</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <p class="hint" id="backupsInfo"></p>
    </div>
    <footer>
      <button class="btn" id="btnBackupsRefresh" type="button">Aktualisieren</button>
      <span class="grow"></span>
      <button class="btn primary" id="btnBackupsOk" type="button">OK</button>
    </footer>
  </dialog>

  <!-- Einstellungen -->
  <dialog id="settings" class="modal">
    <header>
      <strong>Einstellungen</strong>
      <button class="btn" style="padding:8px 12px" id="btnSettingsClose" type="button">Schließen</button>
    </header>
    <div class="content">
      <!-- Sitzung -->
      <details open class="settings" id="secSession">
        <summary>Sitzung</summary>
        <div class="row" style="align-items:center; gap:10px; margin-bottom:8px">
          <span id="sessionUser" class="badge-role">Benutzer: —</span>
          <span id="sessionGroup" class="badge-role">Gruppe: —</span>
          <span id="sessionPersist" class="badge-role">Anmeldung: —</span>
          <span class="grow"></span>
          <button class="btn warn" id="btnLogout" type="button">Abmelden</button>
        </div>
        <div class="row" style="align-items:center; gap:10px; margin-bottom:4px">
          <span class="hint">Löscht alle <b>lokal gespeicherten</b> Daten dieser Lagerverwaltung auf diesem Gerät (Einstellungen, Cache, Historie, Login-Merkung). Cloud-Daten bleiben erhalten.</span>
          <span class="grow"></span>
          <button class="btn" id="btnClearLocalData" type="button">Lokale Lagerdaten löschen</button>
        </div>
      </details>

      
      <!-- Konto -->
      <details open class="settings" id="secAccount">
        <summary>Konto</summary>
        <div class="row">
          <div class="grid" style="grid-template-columns: 160px 1fr;">
            <label for="accPwNew">Neues Passwort</label>
            <input id="accPwNew" type="password" autocomplete="new-password" placeholder="Neues Passwort">
          </div>
          <div class="grid" style="grid-template-columns: 160px 1fr;">
            <label for="accPwRepeat">Wiederholen</label>
            <input id="accPwRepeat" type="password" autocomplete="new-password" placeholder="Passwort wiederholen">
          </div>
          <div class="row" style="align-items:center; gap:12px;">
            <label><input type="checkbox" id="accPwShow"> Anzeigen</label>
            <button class="btn" id="accPwGen" type="button">Zufällig</button>
            <span class="grow"></span>
            <button class="btn ok" id="accPwSave" type="button">Speichern</button>
          </div>
          <div class="hint">Ändert nur <b>dein eigenes</b> Passwort. Für andere Benutzer bitte in „Mitglieder“ setzen.</div>
        </div>
      </details>

      <div class="divider"></div>

      <!-- Start-Hinweis beim Login -->
      <details class="settings" id="secStartNotice">
        <summary>Hinweis beim Start</summary>

        <div class="grid cols-2">
          <label class="chk" style="margin-bottom:6px;">
            <input type="checkbox" id="startNoticeOnLogin">
            Beim Anmelden anzeigen
          </label>
          <label class="chk" style="margin-bottom:6px;">
            <input type="checkbox" id="startNoticeOnSync">
            Bei jedem Standard‑Sync anzeigen
          </label>
        </div>

        <div class="grid cols-2" style="margin-top:4px">
          <div class="grid">
            <label for="startNoticeTargetGroup">Sichtbare Gruppe</label>
            <select id="startNoticeTargetGroup" class="input">
              <option value="ALL">Alle Gruppen</option>
            </select>
            <div class="hint">
              Optional auf eine einzelne Gruppe einschränken. Neue Gruppen erscheinen automatisch in der Liste.
            </div>
          </div>
        </div>

        <textarea id="startNoticeText" class="input" rows="4"
          placeholder="Freier Hinweistext, z. B. Inventur, Fahrzeuge leerräumen, …"></textarea>

        <div class="hint">
          Wird Benutzern je nach Auswahl beim Anmelden und/oder nach einem Standard‑Sync angezeigt
          (normaler Sync‑Button bzw. Auto‑Sync) und nur für Gruppen, die oben ausgewählt sind.
        </div>
      </details>


<!-- Cloud Sync (Supabase) -->
      <details class="settings" id="secCloud">
        <summary>Cloud Sync (Supabase)</summary>
        <p class="hint">Optional. Synchronisiert Daten zwischen Handy und PC. Erfordert <b>Supabase&nbsp;URL (REST)</b>, <b>Anon&nbsp;Key</b> und <b>Tabellennamen</b>.</p>
        <div class="grid cols-2">
          <div class="grid">
            <label for="brUrl">Supabase URL (REST)</label>
            <input id="brUrl" class="input" placeholder="https://DEINPROJEKT.supabase.co/rest/v1" />
          </div>
          <div class="grid">
            <label for="brToken">Anon Key</label>
            <textarea id="brToken" class="input" placeholder="Anon Key (JWT)"></textarea>
          </div>
        </div>
        <div class="grid cols-2" style="margin-top:8px">
          <div class="grid">
            <label for="tblItems">Tabelle „items“ (Tabellenname)</label>
            <input id="tblItems" class="input" placeholder="z. B. lv_items" />
          </div>
          <div class="grid">
            <label for="tblGroups">Tabelle „groups“ (Tabellenname)</label>
            <input id="tblGroups" class="input" placeholder="z. B. lv_groups" />
          </div>
        </div>
        <div class="grid cols-2" style="margin-top:8px">
          <div class="grid">
            <label for="tblMembers">Tabelle „members“ (Tabellenname)</label>
            <input id="tblMembers" class="input" placeholder="z. B. lv_members" />
          </div>
          <div class="grid">
            <label for="tblItemOps">Tabelle „itemops“ (Tabellenname)</label>
            <input id="tblItemOps" class="input" placeholder="z. B. lv_item_ops" />
          </div>
        </div>
        <div class="grid cols-2" style="margin-top:8px">
          <div class="grid">
            <label for="tblBackups">Tabelle „backups“ (Tabellenname)</label>
            <input id="tblBackups" class="input" placeholder="z. B. lv_backups" />
          </div>
          <div class="grid">
            <label for="tblAppSettings">Tabelle „app_settings“ (Tabellenname)</label>
            <input id="tblAppSettings" class="input" placeholder="z. B. lv_app_settings" />
          </div>
        </div>
        
        <div class="row" style="margin-top:8px; flex-wrap:wrap; gap:8px">
          <button class="btn" id="btnCloudConnect" type="button">Verbinden / Aktualisieren</button>
          <div class="row" style="gap:10px; align-items:center">
            <input type="checkbox" id="autoSyncChk">
            <label for="autoSyncChk">Auto‑Sync nach Aktionen</label>
          </div>
          <span class="grow"></span>
          <span id="cloudStatus" class="hint">Status: offline</span>
        </div>
        <div class="row" style="margin-top:8px; flex-wrap:wrap; gap:8px">
          <button class="btn" id="btnPull" type="button">Alles aus Cloud laden</button>
          <button class="btn" id="btnPush" type="button">Alle lokalen Daten hochladen</button>
  <button class="btn" id="btnCloudSelftest" type="button" onclick="try{cloudSelftest()}catch(e){console&&console.error(e)}">Verbindung testen</button>
  <div id="cloudSelftestResult" class="hint" style="margin-top:8px"></div>
          <button class="btn" id="btnCloudCfgExport" type="button" onclick="try{exportCloudSyncConfig()}catch(e){if(window.console)console.error(e)}">Cloud‑Sync‑Export (JSON)</button>
          <button class="btn" id="btnCloudCfgImport" type="button" onclick="try{startImportCloudSyncConfig()}catch(e){if(window.console)console.error(e)}">Cloud‑Sync‑Import (JSON)</button>
          <input id="cloudCfgImportFile" type="file" accept="application/json,.json" style="display:none" />
          <span class="grow"></span>
          <button class="btn" id="btnRetryOutbox" type="button" title="Fehlgeschlagene Vorgänge erneut senden" style="display:none">Warteschlange erneut senden</button>
        </div>
        <div id="outboxInfo" class="hint" style="margin-top:6px"></div>
      </details>

      <details class="settings" id="syncOptionsDetails">
        <summary>Sync‑Optionen</summary>
        <div class="hint">
          Lege fest, welche Datenbereiche beim Standard‑Sync (Tagesbetrieb) und beim Voll‑Sync (Admin‑Aktionen) berücksichtigt werden.
        </div>
        <div class="grid cols-2" style="margin-top:8px">
          <div class="grid">
            <h4>Standard‑Sync</h4>
            <label class="row">
              <input type="checkbox" id="syncStdMaterialChk">
              <span>Material &amp; Bewegungen einbeziehen</span>
            </label>
          </div>
          <div class="grid">
            <h4>Voll‑Sync / Admin‑Sync</h4>
            <label class="row">
              <input type="checkbox" id="syncFullMaterialChk">
              <span>Material &amp; Bewegungen einbeziehen</span>
            </label>
            <label class="row">
              <input type="checkbox" id="syncFullGroupsChk">
              <span>Gruppen &amp; Rechte einbeziehen</span>
            </label>
            <label class="row">
              <input type="checkbox" id="syncFullMembersChk">
              <span>Benutzerkonten einbeziehen</span>
            </label>
            <label class="row">
              <input type="checkbox" id="syncFullAppCfgChk">
              <span>App‑Einstellungen einbeziehen (Reserve)</span>
            </label>
          </div>
        </div>
      
<details class="settings" id="alertsOptionsDetails">
  <summary>Warnungen & Mindestbestände (Anzeige)</summary>
  <div class="hint">Steuert, wer Bestandswarnungen sieht. „Bestellt“ bleibt immer global – die Warnung verschwindet für alle.</div>
  <div class="grid cols-2" style="margin-top:8px">
    <div class="grid">
      <h4>Bereich</h4>
      <label class="row"><input type="radio" name="alertsScope" id="alertsScopeLocal" value="local"> <span>Nur bei mir</span></label>
      <label class="row"><input type="radio" name="alertsScope" id="alertsScopeGlobal" value="global"> <span>Global (Gruppen)</span></label>
      <div class="grid" id="alertsOwnerRow" style="margin-top:8px">
        <label for="alertsOwner">Besitzer (nur „Nur bei mir“)</label>
        <select id="alertsOwner" class="input"></select>
        <small class="hint">Nur dieser Benutzer sieht Warnungen, wenn „Nur bei mir“ aktiv ist.</small>
      </div>
    </div>
    <div class="grid">
      <h4>Gruppen (bei „Global“)</h4>
      <div id="alertsGroupMask" class="grid" style="grid-template-columns: 1fr; gap:6px">
        <div class="hint">Wähle, welche Gruppen Warnungen sehen dürfen.</div>
      </div>
    </div>
  </div>
</details>
</details>

<div class="divider"></div>

<!-- 
      <div class="divider"></div>

      <!-- Gruppenverwaltung -->
      <details class="settings" id="secGroups">
        <summary>Benutzergruppen & Rechte</summary>
        <div class="hint-row" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
          <p class="hint" style="margin:0">Lege Gruppen (z. B. Lagerverwalter, Monteur) an und setze Häkchen, was sie dürfen.</p>
          <button type="button" class="btn btn-xs btn-outline-danger" onclick="resetSecurityConfig()" style="margin-left:auto">
            Rechte zurücksetzen
          </button>
        </div>
        <p class="hint" style="display:none">Lege Gruppen (z. B. Lagerverwalter, Monteur) an und setze Häkchen, was sie dürfen.</p>
        <div class="table-wrap" style="margin-bottom:10px">
          <table class="list" id="groupsTable">
            <thead>
              <tr>
                <th style="width:40px">#</th>
                <th>Gruppenname</th>
                <th>Rechte (Kurz)</th>
                <th style="width:120px">System</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div id="groupEditor" class="grid" style="display:none">
          <div class="grid cols-2">
            <div class="grid">
              <label for="groupName">Gruppenname</label>
              <input id="groupName" class="input" placeholder="z. B. Monteur" />
            </div>
            <div class="grid">
              <label>Status</label>
              <div><span id="groupStatus" class="badge-role">—</span></div>
            </div>
          </div>
          <div class="divider"></div>
          <div class="grid cols-2">
            <div>
              <h4>Material & Buchung</h4>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="book"> Darf buchen (Eingang/Ausgang)</label>
                <div class="hint perm-hint">Wareneingang und Warenausgang buchen; schreibt Einträge in die Historie.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="edit_items"> Darf Material anlegen/bearbeiten</label>
                <div class="hint perm-hint">Artikelstammdaten bearbeiten (Bezeichnung, Art.-Nr., Kategorie, Notiz).</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="adjust_qty"> Darf Menge ± Buttons nutzen</label>
                <div class="hint perm-hint">Schnelle Bestandskorrekturen über die ± Buttons; schreibt Einträge in die Historie.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="delete_items"> Darf löschen</label>
                <div class="hint perm-hint">Artikel vollständig löschen (inkl. Historie dieses Artikels).</div>
              </div>
            </div>
            <div>
              <h4>Einstellungen & Verwaltung</h4>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="manage_settings"> Cloud-Einstellungen verwalten</label>
                <div class="hint perm-hint">Supabase-URL/Token, Tabellen, Auto-Sync und Cloud-Sync im Einstellungsbereich.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="manage_users"> Benutzer verwalten</label>
                <div class="hint perm-hint">Gruppen &amp; Benutzer pflegen, Rechte vergeben.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="export_import"> Export/Import</label>
                <div class="hint perm-hint">Daten als JSON exportieren/importieren und Excel-Import (XLSX) verwenden.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="print_excel"> Drucken/Excel</label>
                <div class="hint perm-hint">Excel-Export und Druckansicht der Übersicht.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="backup"> Backups</label>
                <div class="hint perm-hint">Lokale und Cloud-Backups (Snapshots) anlegen und wiederherstellen.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="sync_basic"> Sync: Standard-Sync auslösen</label>
                <div class="hint perm-hint">Darf den manuellen Standard-Sync (⇅) und das erneute Senden der Warteschlange auslösen.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="sync_advanced"> Sync: Voll-Sync / Admin-Aktionen</label>
                <div class="hint perm-hint">Darf „Alles aus Cloud laden“ und „Alle lokalen Daten hochladen“ starten (bewusste Admin-Aktionen).</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="sync_manage_options"> Sync-Optionen verwalten</label>
                <div class="hint perm-hint">Darf die Sync-Optionen in den Einstellungen sehen und ändern (welche Bereiche Standard-/Voll-Sync betreffen).</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="view_history"> Historie ansehen</label>
                <div class="hint perm-hint">Historie im Programm einsehen (Dialog). Kein CSV-Export.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="export_history"> Historie exportieren (CSV)</label>
                <div class="hint perm-hint">Historie als CSV-Datei exportieren.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="clear_history"> Historie löschen</label>
                <div class="hint perm-hint">Löscht die komplette Historie (global & pro Artikel). Sehr mächtig – nur für Admins empfohlen.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="view_alerts"> Warnungen ansehen</label>
                <div class="hint perm-hint">Bestandswarnungen öffnen und ansehen.</div>
              </div>
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="edit_alerts"> Warnungen bearbeiten</label>
                <div class="hint perm-hint">Aktiv-Status und Schwellwert ändern; „Bestellt“-Markierung setzen.</div>
              
              <div class="perm-row">
                <label><input type="checkbox" class="perm-chk" data-perm="view_history_usernames"> Historie: Benutzernamen einsehen</label>
                <div class="hint perm-hint">Zeigt in der Historie die Spalte „Benutzer“ mit dem Anmelde­namen.</div>
              </div>
</div>
          </div>
          
    <div class="row" style="margin-top:8px; gap:8px;">
      <span class="grow"></span>
      <button class="btn" id="btnGroupNew" type="button" title="Neue Gruppe anlegen">Neue Gruppe</button>
      <button class="btn" id="btnGroupDelete" type="button" title="Ausgewählte Gruppe löschen" style="background:#c62828;color:#fff">Gruppe löschen</button>
      <button class="btn primary" id="btnSaveGroup" type="button">Gruppe speichern</button>
    </div>

        </div>
      </details>

      <div class="divider"></div>

      <!-- Benutzer & Zuweisung -->
      <details class="settings" id="secUsers">
        <summary>Benutzer & Zuweisung</summary>
        <p class="hint">Benutzername eintragen (Pflicht), Gruppe wählen und hinzufügen. <b>Passwort setzen</b> erstellt einen Hash (PBKDF2) – kein Klartext.</p>
        <div id="membersAdminUi">
          <div class="row">
            <input id="memberUsername" class="input" placeholder="benutzername" style="max-width:200px; margin-right:8px"> <select id="memberGroup" class="input" style="max-width:240px"></select>
            <button class="btn" id="btnAddMember" type="button">Hinzufügen</button>
          </div>
        </div>
        <div id="membersReadonlyUi" class="hint" style="display:none; margin-bottom:8px">Keine Admin‑Rechte. Nutzerliste nur zur Ansicht.</div>

        <div class="table-wrap" style="margin-top:8px">
          <table class="list" id="membersTable">
            <thead>
              <tr>
                <th>Benutzer</th>
                <th>Gruppe</th>
                <th>Zusatzrechte</th>
                <th>Passwort</th>
                <th style="width:160px">Aktion</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </details>

      <div class="divider"></div>

      <!-- Daten -->
      <details class="settings" id="secData">
        <summary>Daten (Export / Import)</summary>
        <div class="row">
          <button class="btn" id="btnDataExport" type="button">Export (JSON, lokal)</button>
          <div>
            <input class="sr-only" type="file" id="dataImportFile" accept="application/json" />
            <button class="btn" id="btnDataImport" type="button">Import (JSON, lokal)</button>
          </div>
        </div>
      </details>

      <div class="divider"></div>

      <!-- Druck & Excel -->
      <details class="settings" id="secPrint">
        <summary>Druck & Excel</summary>
        <div class="row">
          <button class="btn" id="btnExcel" type="button">Als Excel (XLSX) herunterladen</button>
          <button class="btn" id="btnPrint" type="button">Druckansicht (Tabelle)</button>

          <input class="sr-only" type="file" id="excelImportFile" accept=".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />
          <button class="btn" id="btnExcelImport" type="button">Import (Excel, XLSX)</button>
        </div>
      </details>

      <div class="divider"></div>

      <!-- Backup -->
      <details class="settings" id="secBackup">
        <summary>Ein‑Klick‑Backup (Cloud)</summary>
        <div class="row" style="gap:8px; flex-wrap:wrap">
          <button class="btn primary" id="btnBackupCloud" type="button">Jetzt sichern (Cloud)</button>
          <button class="btn" id="btnBackupsShow" type="button">Backups anzeigen / herunterladen</button>
          <span class="grow"></span>
          <label class="hint"><input type="checkbox" id="chkIncludeToken"> API‑Token mit sichern (nicht empfohlen)</label>
        </div>
        <p class="hint">Sichert <b>alles</b> (Material, Historien, Gruppen, Benutzer, Einstellungen) als Snapshot in der Supabase‑Tabelle „backups“. Standardmäßig <b>ohne</b> API‑Token.</p>
      </details>
    </div>
    <footer>
      <button class="btn primary" id="btnSettingsOk" type="button">Speichern</button>
    </footer></dialog>

  <!-- Start-Hinweis-Dialog -->
  <dialog id="startNoticeDlg" class="modal">
    <header>
      <strong>Hinweis</strong>
    </header>
    <div class="content">
      <p id="startNoticeBody"></p>
    </div>
    <footer class="actions">
      <button class="btn ok" type="button" onclick="try{ this.closest('dialog').close(); }catch(_){ this.closest('dialog').open=false; }">OK</button>
    </footer>
  </dialog>

  <script>
// Helper: Kategorie-Sync-Flag (opt-in)
function _capCategorySync(){ try{ return localStorage.getItem('lagerverwaltung_cap_category_sync')==='1' }catch(e){ return false } }

function _autoEnableCategorySyncIfSupported(rows){
  try{
    if (typeof _capCategorySync === 'function' && _capCategorySync()) return;
    if (!rows || !rows.length) return;
    var hasCategory = false;
    for (var i = 0; i < rows.length; i++){
      var r = rows[i];
      if (r && typeof r.category !== 'undefined'){
        hasCategory = true;
        break;
      }
    }
    if (hasCategory){
      try{ localStorage.setItem('lagerverwaltung_cap_category_sync','1'); }catch(_){}
    }
  }catch(_){}
}

    // Polyfill for dialog in very old browsers
    (function(){ var supported = typeof HTMLDialogElement === 'function' && HTMLDialogElement.prototype && HTMLDialogElement.prototype.showModal; if (supported) return;
      document.querySelectorAll('dialog').forEach(function(d){ d.showModal = function(){ d.setAttribute('open',''); }; d.close = function(){ d.removeAttribute('open'); }; }); })();

    // Helpers
    async function manualSync(){
      if (typeof has === 'function' && !has('sync_basic')){
        try{ if (typeof toast === 'function'){ toast('Kein Recht für Standard-Sync (sync_basic)'); } }catch(_){}
        return;
      }
      var b = document.getElementById('btnManualPush');
      if(b){ if(b.disabled) return; b.disabled = true; var prev = b.textContent; b.textContent = '...'; }
      try{
        $('#cloudStatus').textContent = 'Status: Sync läuft ...';
        $('#statusCloud').textContent = 'Cloud: Sync läuft ...';
        toast('Manueller Sync gestartet');

        if (typeof runFullSync === 'function'){
          // Zentraler Mehrbenutzer‑Ablauf (inkl. ItemOps / Outbox, Push‑first‑Logik)
          await runFullSync({mode:'standard', silent:false});
        }else{
          // Fallback: bisheriges Verhalten (Push + Pull)
          await cloudPushAll();
          await cloudPullAll();
        }

        $('#cloudStatus').textContent = 'Status: online';
        $('#statusCloud').textContent = 'Cloud: online';
        toast('Sync abgeschlossen');
        try{ if(typeof window!=='undefined' && typeof window.maybeShowStartNotice==='function'){ window.maybeShowStartNotice('sync'); } }catch(_){ }
      }catch(e){
        $('#cloudStatus').textContent = 'Status: Fehler';
        $('#statusCloud').textContent = 'Cloud: Fehler';
        toast('Sync fehlgeschlagen (Details ggf. in der Konsole)');
      }finally{

        if(b){ b.disabled = false; b.textContent = '⇅'; }
      }
    }
// Helpers
    function updateManualPushVisibility(){
      try{
        var btn = document.getElementById('btnManualPush');
        if(!btn) return;
        var cfg = (typeof readBrConfig === 'function') ? readBrConfig() : {};
        var canBasic = !!(currentPerms && currentPerms.sync_basic);
        if(!canBasic){
          btn.style.display = 'none';
        }else{
          btn.style.display = 'grid';
          btn.disabled = false;
        }
      }catch(e){}
    }

    function $(sel){ return document.querySelector(sel) }
    function $all(sel){ return Array.from(document.querySelectorAll(sel)) }
    function todayStr(){ var d = new Date(); return d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,'0')+"-"+String(d.getDate()).padStart(2,'0') }
    function fmtDate(s){ if(!s) return "—"; var d = new Date(s); if(isNaN(d)) d = new Date(s+"T00:00:00"); if(isNaN(d)) return s; return d.toLocaleString('de-DE') }
    
    function fmtBookingDateFromLog(it, kind){
      if(!it) return "—";
      var log = Array.isArray(it.log) ? it.log : [];
      var ts = null;
      for(var i = log.length - 1; i >= 0; i--){
        var L = log[i] || {};
        var delta = Number(L.delta) || 0;
        if(kind === 'in'){
          if(L.type === 'in' || (L.type === 'qty' && delta > 0)){ ts = L.ts; break; }
        }else if(kind === 'out'){
          if(L.type === 'out' || (L.type === 'qty' && delta < 0)){ ts = L.ts; break; }
        }
      }
      if(ts){
        var d = new Date(ts);
        if(!isNaN(d)){ return d.toLocaleString('de-DE'); }
      }
      // Fallback: alte Datumsspalten verwenden (z.B. wenn Log noch alt ist)
      if(kind === 'in'){ return fmtDate(it.inDate); }
      if(kind === 'out'){ return fmtDate(it.outDate); }
      return "—";
    }
function uid(){ return 'id-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2,8) }
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g,function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]) }) }
    function toast(msg){ var t = $('#toast'); t.textContent = msg; t.classList.add('show'); clearTimeout(toast._t); toast._t = setTimeout(function(){ t.classList.remove('show') }, 2200) }

    // LocalStorage keys
    try{ window.lvDebugItemOps = localStorage.getItem('lagerverwaltung_itemops_debug')==='1'; }catch(_){}
    var storageKey = "lagerverwaltung_items_v12";
    var groupsKey = "lagerverwaltung_groups_v3";
    var membersKey = "lagerverwaltung_members_v2";
    var outboxKey  = "lagerverwaltung_outbox_v1";
    var autoSyncKey = "lagerverwaltung_baserow_autosync";
    var brUrlKey = "lagerverwaltung_baserow_url";
    var brTokenKey = "lagerverwaltung_baserow_token";
    var brTblItemsKey = "lagerverwaltung_baserow_tbl_items";
    var brTblGroupsKey = "lagerverwaltung_baserow_tbl_groups";
    var brTblMembersKey = "lagerverwaltung_baserow_tbl_members";
    var brTblBackupsKey = "lagerverwaltung_baserow_tbl_backups";
    var brTblAppSettingsKey = "lagerverwaltung_baserow_tbl_app_settings";
    var brTblItemOpsKey = "lagerverwaltung_baserow_tbl_itemops";
    var brSkuFieldKey = "lagerverwaltung_baserow_sku_field";

// === Supabase Key-Constants (neu) + Migrations-Helper ===
var sbAutoSyncKey       = "lagerverwaltung_baserow_autosync";
var sbUrlKey            = "lagerverwaltung_baserow_url";
var sbTokenKey          = "lagerverwaltung_supabase_anon_key";
var sbTblItemsKey       = "lagerverwaltung_baserow_tbl_items";
var sbTblGroupsKey      = "lagerverwaltung_baserow_tbl_groups";
var sbTblMembersKey     = "lagerverwaltung_baserow_tbl_members";
var sbTblBackupsKey     = "lagerverwaltung_baserow_tbl_backups";
var sbTblAppSettingsKey = "lagerverwaltung_baserow_tbl_app_settings";
var sbTblItemOpsKey     = "lagerverwaltung_baserow_tbl_itemops";
var sbSkuFieldKey       = "lagerverwaltung_baserow_sku_field";

function lsGetMigrate(newKey, oldKey, def){
  var v = localStorage.getItem(newKey);
  if (v===null || v===undefined || v===""){
    var old = localStorage.getItem(oldKey);
    if (old!==null && old!==undefined && old!==""){
      // einmalig neue Keys befüllen (idempotent)
      try{ localStorage.setItem(newKey, old); }catch(_){}
      return old;
    }
    return def;
  }
  return v;
}
function lsSetBoth(newKey, oldKey, value){
  try{ localStorage.setItem(newKey, value); }catch(_){}
  try{ localStorage.setItem(oldKey, value); }catch(_){}
}
    var itemOpsDebugKey = "lagerverwaltung_itemops_debug";
    var requirePwKey = "lagerverwaltung_require_pw";
    
var requirePwKeyLegacy = 'lagerverwaltung_requirePw';
function readRequirePwFlag(){
  try{
    var v = localStorage.getItem(requirePwKey);
    if (v===null || v===undefined || v===''){
      var old = localStorage.getItem(requirePwKeyLegacy);
      if (old!==null && old!==undefined && old!==''){
        try{ localStorage.setItem(requirePwKey, old); }catch(_){}
        return old === '1';
      }
      return false;
    }
    return v === '1';
  }catch(_){ return false; }
}
var sessionKey = "lagerverwaltung_session_email";

    // Data state
    var items = loadJson(storageKey, []);
    var groups = loadJson(groupsKey, null);
    var members = loadJson(membersKey, []);
    var outbox = loadJson(outboxKey, []);
    
  // v70 addition: local ItemOps container
  var itemOpsLocalKey = 'lv_item_ops_local';
  var itemOpsLocal = JSON.parse(localStorage.getItem(itemOpsLocalKey) || '[]');
var filterText="", sortMode="updated_desc", editId=null;
    var currentUserEmail='—', currentGroupName=

'—', currentGroupId=null, currentPerms={};

    var PERM_KEYS = ['book','edit_items','adjust_qty','delete_items','manage_settings','manage_users','export_import','print_excel','backup','view_history','view_alerts','export_history', 'clear_history', 'edit_alerts', 'settings.open','security.requirePw.manage','account.password.set_self','members.password.set_others','session.logout','session.switch_user','sync_basic','sync_advanced','sync_manage_options'];

    // ===== Utilities =====
    function loadJson(key, def){ try{ var raw=localStorage.getItem(key); return raw?JSON.parse(raw):def }catch(e){ return def } }
    function saveJson(key, val){ localStorage.setItem(key, JSON.stringify(val)) }
    function permSummary(perms){ if(!perms) return '—'; var keys=PERM_KEYS.filter(function(k){ return !!perms[k] }); if(!keys.length) return 'keine'; return keys.slice(0,5).join(', ')+(keys.length>5?' ...':'') }
    function mergePerms(base, overrides){ var p=Object.assign({}, base||{}); if(overrides&&typeof overrides==='object'){ PERM_KEYS.forEach(function(k){ if(overrides.hasOwnProperty(k)) p[k]=!!overrides[k] }) } return p }
    function has(k){ return !!currentPerms[k] }

    // Sicherheits-Reset für Benutzer & Rechte
    function resetSecurityConfig(){
      try{
        localStorage.removeItem(groupsKey);
        localStorage.removeItem(membersKey);
        localStorage.removeItem(requirePwKey);
        localStorage.removeItem(sessionKey);
      }catch(e){}
      groups = seedDefaultGroups();
      members = [];
      saveJson(membersKey, members);
      currentUserEmail = '—';
      currentGroupName = '—';
      currentPerms = {};
      updateSessionUI();
      setSectionsByPerms();
      if (typeof refreshGroupUI === 'function'){ refreshGroupUI(); }
      if (typeof refreshMembersUI === 'function'){ refreshMembersUI(); }
      alert('Benutzer & Rechte wurden zurückgesetzt. Standard-Gruppen wurden neu angelegt. Bitte Benutzer neu zuweisen.');
    }

    // ===== Default groups on first start =====
    function seedDefaultGroups(){
      return [
        {id:'g-admin', name:'Admin (Eigentümer)', perms: allPerms(true), is_system:true, is_owner_admin:true},
        {id:'g-manager', name:'Lagerverwalter', perms:{
          book:true, edit_items:true, adjust_qty:true, delete_items:true,
          manage_settings:false,
          edit_alerts:true, manage_users:false,
          export_import:true, print_excel:true, backup:true,
          view_history:true, view_alerts:true, export_history:true,
          clear_history:false,
          sync_basic:true, sync_advanced:false, sync_manage_options:false
        }, is_system:true, is_owner_admin:false},
        {id:'g-write', name:'Schreiben', perms:{
          book:true, edit_items:true, adjust_qty:true, delete_items:false,
          edit_alerts:false,
          manage_settings:false, manage_users:false,
          export_import:false, print_excel:false, backup:false,
          view_history:true, view_alerts:true, export_history:false,
          sync_basic:true, sync_advanced:false, sync_manage_options:false
        }, is_system:true, is_owner_admin:false},
        {id:'g-read', name:'Lesen', perms:{
          book:false,
          edit_alerts:false, edit_items:false, adjust_qty:false, delete_items:false,
          manage_settings:false, manage_users:false,
          export_import:false, print_excel:false, backup:false,
          view_history:true, view_alerts:true, export_history:false,
          sync_basic:false, sync_advanced:false, sync_manage_options:false
        }, is_system:true, is_owner_admin:false}
      ];
    }

    function allPerms(includeMgmt){
      var p = {};
      PERM_KEYS.forEach(function(k){ p[k] = true; });
      if (!includeMgmt){
        p.manage_settings = false;
        p.manage_users = false;
      }
      return p;
    }

if(!groups){ groups = seedDefaultGroups(); saveJson(groupsKey, groups) }

    // ====== Session & perms ======
    function computePermsFor(id){
  var def = { name:'Admin (lokal)', perms: allPerms(true) };
  if(!id){
    return { user:'Admin (lokal)', group:def.name, perms:def.perms };
  }
  var idStr = String(id||'').toLowerCase();
  var m = members.find(function(x){
    return (x.username||'').toLowerCase()===idStr;
  });
  if(!m){
    return { user:id, group:def.name, perms:def.perms };
  }
  var g = groups.find(function(x){ return x.id===m.group_id }) ||
          groups.find(function(x){ return x.is_owner_admin }) ||
          { name:'—', perms:{} };
  var merged = mergePerms(g.perms||{}, m.perm||{});
  return { user:(m.username||'—'), group:(g.name||'—'), perms: merged };
}
    function setSession(email, remember){
      currentUserEmail = email || '—';
      var info = computePermsFor(email);
      currentGroupName = info.group;
      currentPerms = info.perms;
      // Aktuelle Gruppen-ID für Start-Hinweis merken
      try {
        currentGroupId = null;
        var emailNorm = String(email || '').toLowerCase();
        var mems = Array.isArray(window.members) ? window.members : [];
        for (var i = 0; i < mems.length; i++) {
          var m = mems[i];
          if (String(m.username || '').toLowerCase() === emailNorm) {
            currentGroupId = m.group_id || null;
            break;
          }
        }
      } catch(_) {}
      try{
  if(remember) localStorage.setItem(sessionKey, email||'');
  else { sessionStorage.setItem(sessionKey, email||''); localStorage.removeItem(sessionKey); }
}catch(_){ localStorage.setItem(sessionKey, email||''); }
      updateBadges();
      setSectionsByPerms();
      render();
      refreshMembersUI();
    }
    function updateBadges(){
  $('#statusUser').textContent = 'Benutzer: '+(currentUserEmail||'—');
  $('#statusRole').textContent = 'Gruppe: '+currentGroupName;
  $('#sessionUser').textContent = 'Benutzer: '+(currentUserEmail||'—');
  $('#sessionGroup').textContent = 'Gruppe: '+currentGroupName;
  try{
    var hasLocal = !!localStorage.getItem(sessionKey);
    var hasSess  = !!sessionStorage.getItem(sessionKey);
    var label = 'Anmeldung: —';
    if (currentUserEmail && (hasLocal||hasSess)){
      label = 'Anmeldung: ' + (hasLocal ? 'Dauerhaft' : 'Nur Sitzung');
    }
    var el = document.getElementById('sessionPersist');
    if (el) el.textContent = label;
  }catch(_){}
}

    // ====== Supabase config ======
    

function readBrConfig(){
  try{
    return {
      url:       lsGetMigrate(sbUrlKey, brUrlKey, ''),
      token:     lsGetMigrate(sbTokenKey, brTokenKey, ''),
      tblItems:  lsGetMigrate(sbTblItemsKey, brTblItemsKey, ''),
      tblGroups: lsGetMigrate(sbTblGroupsKey, brTblGroupsKey, ''),
      tblMembers:lsGetMigrate(sbTblMembersKey, brTblMembersKey, ''),
      tblBackups:lsGetMigrate(sbTblBackupsKey, brTblBackupsKey, ''),
      tblAppSettings: lsGetMigrate(sbTblAppSettingsKey, brTblAppSettingsKey, ''),
      tblItemOps: lsGetMigrate(sbTblItemOpsKey, brTblItemOpsKey, ''),
      skuField:  lsGetMigrate(sbSkuFieldKey, brSkuFieldKey, 'sku'),
      autoSync:  lsGetMigrate(sbAutoSyncKey, 'lagerverwaltung_baserow_autosync', '0')
    };
  }catch(_){
    return { url:'', token:'', tblItems:'', tblGroups:'', tblMembers:'', tblBackups:'', tblAppSettings:'', tblItemOps:'', skuField:'sku', autoSync:'0' };
  }
}
function writeBrConfig(){
  try{
    var el;
    el = document.getElementById('brUrl');        localStorage.setItem(sbUrlKey, (el&&el.value||'').trim());
    el = document.getElementById('brToken');      localStorage.setItem(sbTokenKey, (el&&el.value||'').trim());
    el = document.getElementById('tblItems');     localStorage.setItem(sbTblItemsKey, (el&&el.value||'').trim());
    el = document.getElementById('tblGroups');    localStorage.setItem(sbTblGroupsKey, (el&&el.value||'').trim());
    el = document.getElementById('tblMembers');   localStorage.setItem(sbTblMembersKey, (el&&el.value||'').trim());
    el = document.getElementById('tblBackups');   localStorage.setItem(sbTblBackupsKey, (el&&el.value||'').trim());
    el = document.getElementById('tblAppSettings'); if (el) localStorage.setItem(sbTblAppSettingsKey, (el.value||'').trim());
    el = document.getElementById('tblItemOps');     if (el) localStorage.setItem(sbTblItemOpsKey, (el.value||'').trim());
    el = document.getElementById('skuField');       if (el) localStorage.setItem(sbSkuFieldKey, ((el.value||'').trim()||'sku'));
    var chk = document.getElementById('autoSyncChk'); if (chk) localStorage.setItem(sbAutoSyncKey, (chk.checked ? '1' : '0'));
    if (typeof toast==='function') toast('Cloud-Einstellungen gespeichert');
  }catch(e){
    try{ if (window.console) console.error(e); }catch(_){}
    alert('Speichern der Cloud-Einstellungen fehlgeschlagen');
  }
}
    // Sync-Optionen (Standard-Sync / Voll-Sync)
    var SYNC_STD_MATERIAL_KEY   = 'lagerverwaltung_sync_std_material';
    var SYNC_STD_ALERTS_KEY     = 'lagerverwaltung_sync_std_alerts';
    var SYNC_FULL_MATERIAL_KEY  = 'lagerverwaltung_sync_full_material';
    var SYNC_FULL_ALERTS_KEY    = 'lagerverwaltung_sync_full_alerts';
    var SYNC_FULL_GROUPS_KEY    = 'lagerverwaltung_sync_full_groups';
    var SYNC_FULL_MEMBERS_KEY   = 'lagerverwaltung_sync_full_members';
    var SYNC_FULL_APPCFG_KEY    = 'lagerverwaltung_sync_full_appsettings';

    function readSyncOptions(){
      function getBool(key, defVal){
        try{
          var v = localStorage.getItem(key);
          if(v === null || v === '') return defVal;
          return v === '1';
        }catch(_){
          return defVal;
        }
      }
      return {
        stdMaterial:  getBool(SYNC_STD_MATERIAL_KEY,  true),
        fullMaterial: getBool(SYNC_FULL_MATERIAL_KEY, true),
        fullGroups:   getBool(SYNC_FULL_GROUPS_KEY,   true),
        fullMembers:  getBool(SYNC_FULL_MEMBERS_KEY,  true),
        fullAppCfg:   getBool(SYNC_FULL_APPCFG_KEY,   false)
      };
    }

    function writeSyncOptions(opts){
      opts = opts || {};
      function setBool(key, val){
        try{ localStorage.setItem(key, val ? '1' : '0'); }catch(_){}
      }
      var cfg = readSyncOptions();
      Object.keys(opts).forEach(function(k){
        if(Object.prototype.hasOwnProperty.call(opts, k)){
          cfg[k] = !!opts[k];
        }
      });
      setBool(SYNC_STD_MATERIAL_KEY,  cfg.stdMaterial);
      setBool(SYNC_FULL_MATERIAL_KEY, cfg.fullMaterial);
      setBool(SYNC_FULL_GROUPS_KEY,   cfg.fullGroups);
      setBool(SYNC_FULL_MEMBERS_KEY,  cfg.fullMembers);
      setBool(SYNC_FULL_APPCFG_KEY,   cfg.fullAppCfg);
    }

function initSyncOptionsUI(){
      try{
        if(window.__syncOptionsInitialized) return;
        var details = document.getElementById('syncOptionsDetails');
        if(!details) return;
        window.__syncOptionsInitialized = true;

        var cfg = readSyncOptions();
        var map = [
          { id:'syncStdMaterialChk', key:'stdMaterial'  },
          { id:'syncFullMaterialChk',key:'fullMaterial' },
          { id:'syncFullGroupsChk',  key:'fullGroups'   },
          { id:'syncFullMembersChk', key:'fullMembers'  },
          { id:'syncFullAppCfgChk',  key:'fullAppCfg'   }
        ];

        map.forEach(function(entry){
          var el = document.getElementById(entry.id);
          if(!el) return;
          if(typeof cfg[entry.key] !== 'undefined'){
            el.checked = !!cfg[entry.key];
          }
          el.addEventListener('change', function(){
            var upd = {};
            upd[entry.key] = !!this.checked;
            writeSyncOptions(upd);
          });
        });
      }catch(_){}
    }

    function exportCloudSyncConfig(){
      var cfg;
      try{
        cfg = readBrConfig();
      }catch(e){
        try{ toast('Cloud-Konfiguration konnte nicht gelesen werden.'); }catch(_){}
        return;
      }
      if (!cfg){ try{ toast('Keine Cloud-Konfiguration vorhanden.'); }catch(_){}
        return;
      }
      var exportObj = {
        version: '1',
        supabase: {
          url: cfg.url || '',
          token: cfg.token || '',
          tblItems: cfg.tblItems || '',
          tblGroups: cfg.tblGroups || '',
          tblMembers: cfg.tblMembers || '',
          tblBackups: cfg.tblBackups || '',
          tblAppSettings: cfg.tblAppSettings || '',
          tblItemOps: cfg.tblItemOps || '',
          skuField: cfg.skuField || 'sku'
        },
        autoSync: !!cfg.autoSync,
        requirePw: !!cfg.requirePw
      };
      var json;
      try{
        json = JSON.stringify(exportObj, null, 2);
      }catch(e){
        try{ toast('Export nicht möglich (JSON-Fehler).'); }catch(_){}
        return;
      }
      try{
        var blob = new Blob([json], {type:'application/json'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'lagerverwaltung_cloudsync_config.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        try{ toast('Cloud-Sync-Einstellungen exportiert.'); }catch(_){}
      }catch(e){
        try{ toast('Export nicht unterstützt in diesem Browser.'); }catch(_){}
      }
    }
    function startImportCloudSyncConfig(){
      var input = document.getElementById('cloudCfgImportFile');
      if (!input){
        try{ toast('Import nicht verfügbar (keine Dateiauswahl gefunden).'); }catch(_){}
        return;
      }
      // Reset event & Wert
      input.value = '';
      input.onchange = function(ev){
        try{
          var file = ev && ev.target && ev.target.files && ev.target.files[0];
          if (!file) return;
          var reader = new FileReader();
          reader.onload = function(){
            try{
              importCloudSyncConfigFromText(reader.result || '');
            }catch(e){
              if (window.console) console.error(e);
              try{ toast('Import fehlgeschlagen.'); }catch(_){}
            } finally {
              input.value = '';
            }
          };
          reader.onerror = function(){
            try{ toast('Datei konnte nicht gelesen werden.'); }catch(_){}
            input.value = '';
          };
          reader.readAsText(file);
        }catch(e){
          if (window.console) console.error(e);
          try{ toast('Import nicht möglich.'); }catch(_){}
        }
      };
      try{
        input.click();
      }catch(e){
        if (window.console) console.error(e);
        try{ toast('Dateiauswahl nicht möglich.'); }catch(_){}
      }
    }

    function importCloudSyncConfigFromText(text){
      var data;
      try{
        data = JSON.parse(text);
      }catch(e){
        try{ toast('Ungültige JSON-Datei.'); }catch(_){}
        return;
      }
      if (!data || data.version !== '1' || !data.supabase){
        try{ toast('Inkompatibles Konfig-Format.'); }catch(_){}
        return;
      }
      var cfg = (typeof readBrConfig === 'function') ? readBrConfig() : {};
      if (!cfg) cfg = {};
      var newCfg = {
        url: cfg.url || '',
        token: cfg.token || '',
        tblItems: cfg.tblItems || '',
        tblGroups: cfg.tblGroups || '',
        tblMembers: cfg.tblMembers || '',
        tblBackups: cfg.tblBackups || '',
        tblAppSettings: cfg.tblAppSettings || '',
        tblItemOps: cfg.tblItemOps || '',
        skuField: cfg.skuField || 'sku',
        autoSync: !!cfg.autoSync,
        requirePw: !!cfg.requirePw
      };
      var b = data.supabase || {};
      if (b.url) newCfg.url = String(b.url);
      if (b.token) newCfg.token = String(b.token);
      if (b.tblItems) newCfg.tblItems = String(b.tblItems);
      if (b.tblGroups) newCfg.tblGroups = String(b.tblGroups);
      if (b.tblMembers) newCfg.tblMembers = String(b.tblMembers);
      if (b.tblBackups) newCfg.tblBackups = String(b.tblBackups);
      if (b.tblAppSettings) newCfg.tblAppSettings = String(b.tblAppSettings);
      if (b.tblItemOps) newCfg.tblItemOps = String(b.tblItemOps);
      if (b.skuField) newCfg.skuField = String(b.skuField);
      if (typeof data.autoSync === 'boolean') newCfg.autoSync = data.autoSync;
      if (typeof data.requirePw === 'boolean') newCfg.requirePw = data.requirePw;

      var summary = 'URL: ' + (newCfg.url||'') +
        '\nItems: ' + (newCfg.tblItems||'') +
        '\nGroups: ' + (newCfg.tblGroups||'') +
        '\nMembers: ' + (newCfg.tblMembers||'') +
        '\nBackups: ' + (newCfg.tblBackups||'') +
        '\nAppSettings: ' + (newCfg.tblAppSettings||'') +
        '\nItemOps: ' + (newCfg.tblItemOps||'') +
        '\nSKU-Feld: ' + (newCfg.skuField||'') +
        '\nAuto-Sync: ' + (newCfg.autoSync ? 'an' : 'aus') +
        '\nLogin-Pflicht: ' + (newCfg.requirePw ? 'ja' : 'nein');

      var ok = window.confirm('Diese Cloud-Sync-Einstellungen aus der Datei übernehmen und bestehende Einstellungen überschreiben?\n\n' + summary);
      if (!ok) return;

      try{
        localStorage.setItem(brUrlKey, newCfg.url);
        localStorage.setItem(brTokenKey, newCfg.token);
        localStorage.setItem(brTblItemsKey, newCfg.tblItems);
        localStorage.setItem(brTblGroupsKey, newCfg.tblGroups);
        localStorage.setItem(brTblMembersKey, newCfg.tblMembers);
        localStorage.setItem(brTblBackupsKey, newCfg.tblBackups);
        localStorage.setItem(brTblAppSettingsKey, newCfg.tblAppSettings);
        localStorage.setItem(brTblItemOpsKey, newCfg.tblItemOps);
        localStorage.setItem(brSkuFieldKey, newCfg.skuField);
        localStorage.setItem(autoSyncKey, newCfg.autoSync ? '1' : '0');
        localStorage.setItem(requirePwKey, newCfg.requirePw ? '1' : '0');
      }catch(e){
        if (window.console) console.error(e);
        try{ toast('Einstellungen konnten nicht gespeichert werden.'); }catch(_){}
        return;
      }

      try{
        if (typeof applyBrConfigToUi === 'function'){
          applyBrConfigToUi();
        }
      }catch(e){
        if (window.console) console.error(e);
      }

      try{ toast('Cloud-Sync-Einstellungen importiert.'); }catch(_){}
    }


    function applyBrConfigToUi(){
  updateManualPushVisibility();
  try{ initSyncOptionsUI(); }catch(_){ }

  // Konfiguration konsistent über readBrConfig holen
  var cfg = {};
  try{
    cfg = readBrConfig() || {};
  }catch(_){
    cfg = {};
  }

  // Supabase-Einstellungen in die UI schreiben
  $('#brUrl').value      = cfg.url        || '';
  $('#brToken').value    = cfg.token      || '';
  $('#tblItems').value   = cfg.tblItems   || '';
  $('#tblGroups').value  = cfg.tblGroups  || '';
  $('#tblMembers').value = cfg.tblMembers || '';
  $('#tblBackups').value = cfg.tblBackups || '';

  if (document.getElementById('tblAppSettings')){
    $('#tblAppSettings').value = cfg.tblAppSettings || '';
  }
  if (document.getElementById('tblItemOps')){
    $('#tblItemOps').value = cfg.tblItemOps || '';
  }
  if (document.getElementById('skuField')){
    $('#skuField').value = cfg.skuField || 'sku';
  }

  // Auto-Sync-Checkbox
  $('#autoSyncChk').checked = String(cfg.autoSync || '0') === '1';

  // ItemOps-Debug-Flag aus localStorage lesen (wie vorher)
  var dbg = localStorage.getItem(itemOpsDebugKey)==='1';
  var chkDbg = document.getElementById('chkItemOpsDebug');
  if(chkDbg){ chkDbg.checked = dbg; }
  try{ window.lvDebugItemOps = !!dbg; }catch(_){}

  updateManualPushVisibility();
  updateOutboxUi();
}

    // ====== Supabase client (ehemals Supabase client) ======
    function getSupabaseConfig(){
      if (typeof readBrConfig !== 'function'){
        throw new Error('Supabase nicht konfiguriert (readBrConfig fehlt)');
      }
      var cfg = readBrConfig() || {};
      if (!cfg.url || !cfg.token){
        throw new Error('Supabase nicht konfiguriert (URL oder Token fehlt)');
      }
      return cfg;
    }

    function getSupabaseBaseUrl(){
      var cfg = getSupabaseConfig();
      var u = String(cfg.url || '').trim();
      if (!u){
        throw new Error('Supabase URL fehlt');
      }
      // Wenn der Benutzer nur die Projekt-URL eingibt, /rest/v1 automatisch ergänzen
      if (!/\/rest\/v1\b/.test(u)){
        u = u.replace(/\/+$/,'') + '/rest/v1';
      }
      return u.replace(/\/+$/,'');
    }

    function getSupabaseHeaders(){
      var cfg = getSupabaseConfig();
      return {
        apikey       : cfg.token,
        Authorization: 'Bearer ' + cfg.token,
        'Content-Type': 'application/json',
        Accept       : 'application/json'
      };
    }

    // brFetch bleibt zentraler HTTP-Wrapper, arbeitet jetzt gegen Supabase
    async function brFetch(path, opts){
      var base = getSupabaseBaseUrl();
      var url  = base + path;
      var res = await fetch(url, Object.assign({ headers: getSupabaseHeaders() }, opts || {}));
      if (!res.ok){
        var t = '';
        try{ t = await res.text(); }catch(_){}
        throw new Error('HTTP ' + res.status + ': ' + t);
      }
      var ct = res.headers.get('content-type') || '';
      if (ct.indexOf('application/json') >= 0){
        return res.json();
      }
      return res.text();
    }

    // brListAll: liest alle Zeilen einer Supabase-Tabelle (tableName) mit optionalem order_by
    async function brListAll(tableName, params){
      var base = getSupabaseBaseUrl();
      var headers = getSupabaseHeaders();
      var page = 1, size = 200, out = [];

      while (true){
        var query = '?select=*';
        query += '&limit=' + size;
        query += '&offset=' + (size * (page - 1));

        if (params && params.order_by){
          var ob = String(params.order_by);
          var asc = true;
          if (ob.charAt(0) === '-'){
            asc = false;
            ob = ob.slice(1);
          }
          query += '&order=' + encodeURIComponent(ob + (asc ? '.asc' : '.desc'));
        }

        var url = base + '/' + encodeURIComponent(tableName) + query;
        var res = await fetch(url, { method: 'GET', headers: headers });
        if (!res.ok){
          var t = '';
          try{ t = await res.text(); }catch(_){}
          throw new Error('Supabase brListAll HTTP ' + res.status + ': ' + t);
        }
        var data = await res.json();
        if (!Array.isArray(data) || !data.length){
          break;
        }
        out = out.concat(data);
        if (data.length < size){
          break;
        }
        page++;
        if (page > 50){
          break;
        }
      }
      return out;
    }

    // brCreate: fügt eine Zeile in einer Supabase-Tabelle ein
    async function brCreate(tableName, row){
      var base = getSupabaseBaseUrl();
      var headers = getSupabaseHeaders();
      headers.Prefer = 'return=representation';
      var url = base + '/' + encodeURIComponent(tableName);
      var res = await fetch(url, {
        method : 'POST',
        headers: headers,
        body   : JSON.stringify(row || {})
      });
      if (!res.ok){
        var t = '';
        try{ t = await res.text(); }catch(_){}
        throw new Error('Supabase brCreate HTTP ' + res.status + ': ' + t);
      }
      var data = await res.json();
      return Array.isArray(data) ? (data[0] || null) : data;
    }

    // brUpdate: aktualisiert eine Zeile anhand ihrer id
    async function brUpdate(tableName, rowId, row){
  var base = getSupabaseBaseUrl();
  var headers = getSupabaseHeaders();
  headers.Prefer = 'return=representation';
  var url = base + '/' + encodeURIComponent(tableName) + '?id=eq.' + encodeURIComponent(rowId);
  var res = await fetch(url, {
    method: 'PATCH',
    headers: headers,
    body: JSON.stringify(row || {})
  });
  if (!res.ok){
    var t = '';
    try{ t = await res.text(); }catch(_){}
    throw new Error('Supabase brUpdate HTTP ' + res.status + ': ' + t);
  }
  var data = await res.json();
  return Array.isArray(data) ? (data[0] || null) : data;
}

async function brDelete(tableName, rowId){
  var base = getSupabaseBaseUrl();
  var headers = getSupabaseHeaders();
  var url = base + '/' + encodeURIComponent(tableName) + '?id=eq.' + encodeURIComponent(rowId);
  var res = await fetch(url, { method: 'DELETE', headers: headers });
  if (!res.ok){
    var t = '';
    try{ t = await res.text(); }catch(_){}
    throw new Error('Supabase brDelete HTTP ' + res.status + ': ' + t);
  }
  return true;
}
// ===== Items/Groups/Members row mapping =====
function normalizeCategory(v){
// v26 normalizeCategory – behält Geräte-Abkürzungen & Longforms bei; kein Neutralisieren unbekannter Werte
var s = String(v||'').trim();
if (!s) return '';
// UI-Kategorien (voll)
var UI = ['Neuware','Zusatzmaterial','Verbrauchsmaterial','Messtechnik Nord','Werkzeug'];
// Geräte-Abkürzungen (Chips)
var DEV = ['WMZ','KWZ','WWZ','HKV','RWM'];
// Shortcodes → UI-Kategorien
var MAP_SHORT = { 'NW':'Neuware','ZM':'Zusatzmaterial','VB':'Verbrauchsmaterial','ME':'Messtechnik Nord','WG':'Werkzeug' };
// Longforms → Geräte-Abkürzungen
var MAP_DEV_LONG = {
  'wärmemengenzähler':'WMZ','waermemengenzaehler':'WMZ','wärmezähler':'WMZ','waermezaehler':'WMZ',
  'kaltwasserzähler':'KWZ','kaltwasserzaehler':'KWZ',
  'warmwasserzähler':'WWZ','warmwasserzaehler':'WWZ',
  'heizkostenverteiler':'HKV',
  'rauchwarnmelder':'RWM','rauchmelder':'RWM'
};
var sLower = s.toLowerCase();

// 1) Shortcodes für UI-Kategorien
if (MAP_SHORT[s.toUpperCase()]) return MAP_SHORT[s.toUpperCase()];

// 2) Longforms für Geräte-Abkürzungen
if (MAP_DEV_LONG[sLower]) return MAP_DEV_LONG[sLower];

// 3) Exakte (case-insensitive) Treffer in UI-Kategorien
for (var i=0;i<UI.length;i++){ if (UI[i].toLowerCase()===sLower) return UI[i]; }

// 4) Exakte (case-insensitive) Treffer in Geräte-Abkürzungen
for (var j=0;j<DEV.length;j++){ if (DEV[j].toLowerCase()===sLower) return DEV[j]; }

// 5) Unbekanntes NICHT neutralisieren → original zurückgeben (bewusst tolerant)
return s;
}

// === v10: Zentraler Entry-Point für Kategorie-Normalisierung (kompatibel) ===
/**
 * normalizeCategoryUnified – zentrale Kompatibilitäts-API für die Kategorie-Normalisierung.
 * strategy: 'v26' | 'modern' | 'v06' | 'legacy'  (Default: 'v26')
 * Diese Funktion ändert keine Bestandslogik: Sie delegiert an die vorhandenen Implementierungen.
 */
function normalizeCategoryUnified(v, strategy){
  var mode = String(strategy || 'v26').toLowerCase();
  try{
    if (mode === 'v06' || mode === 'legacy') {
      return normalizeCategoryV06(v);
    } else {
      // default 'v26' / 'modern'
      return normalizeCategory(v);
    }
  }catch(_){
    // Fallback: möglichst defensiv, niemals Kategorien löschen
    try { return normalizeCategory(v); } catch(__){ return String(v||'').trim(); }
  }
}

// Komfort-Alias (neu): verwendet Default-Strategie 'v26'
function toCategoryNormalized(v){
  return normalizeCategoryUnified(v, 'v26');
}
// === /v10 ===

    function itemToRow(x){ return { app_id:x.id, name:x.name||'', sku:x.sku||'', qty:Number(x.qty)||0, notes:x.notes||'', in_date:x.inDate||null, out_date:x.outDate||null, log: JSON.stringify(Array.isArray(x.log)?x.log:[]), updated_at: new Date(x.updatedAt||Date.now()).toISOString(), ...(_capCategorySync()? { category : (x.category||'') } : {} ) } }
    function rowToItem(r){
      var log=[]; try{ log = r.log ? JSON.parse(r.log) : [] }catch(e){}
      return { id:r.app_id, name:r.name||'', sku:r.sku||'', qty:Number(r.qty)||0, notes:r.notes||'', inDate:r.in_date||'', outDate:r.out_date||'', log: Array.isArray(log)?log:[], createdAt: Date.now(), updatedAt: r.updated_at ? new Date(r.updated_at).getTime() : Date.now() , ...(_capCategorySync()? { category : (r.category||'') } : {} ) }
    }
    function safeJson(s, fallback){ try{ return s ? JSON.parse(s) : fallback }catch(e){ return fallback } }
    function memberToRow(m){
  return {
    username: (m.username||'').trim(),
    group_id: m.group_id || m.groupId || '',
    perms: JSON.stringify(m.perm || m.perms || {}),
    pw_salt: m.pw_salt || null,
    pw_hash: m.pw_hash || null
  };
}

async function cloudPullAll(){
      try{
        var cfg=readBrConfig(); if(!cfg.tblItems){ toast('Items‑Tabelle fehlt'); return }
        $('#cloudStatus').textContent='Status: lade ...'; $('#statusCloud').textContent = 'Cloud: lädt ...';
        var rows = await brListAll(cfg.tblItems);
        _autoEnableCategorySyncIfSupported(rows);
        items = rows.map(rowToItem).sort(function(a,b){ return (b.updatedAt||0)-(a.updatedAt||0) });
        saveJson(storageKey, items); render();
        if(cfg.tblGroups){
        var gr = await brListAll(cfg.tblGroups);
        groups = gr.map(function(g){
          var appId = g.Groups_ID || g.Groups_id || g.groups_id || g.id;
          return {
            id: appId,
            name: g.name,
            perms: safeJson(g.perms, {}),
            is_system: !!g.is_system,
            is_owner_admin: !!g.is_owner_admin
          };
        });
        refreshGroupUI();
      }
        if(cfg.tblMembers){
        var mem = await brListAll(cfg.tblMembers);
        members = mem.map(function(r){
          return {
            username: (r.username||'').trim(),
            group_id: r.group_id || r.groupId || '',
            perm: safeJson(r.perms, {}),
            pw_salt: r.pw_salt || null,
            pw_hash: r.pw_hash || null
          };
        });
        saveJson(membersKey, members);
        refreshMembersUI();
      }
        $('#cloudStatus').textContent='Status: online'; $('#statusCloud').textContent = 'Cloud: online';
        toast('Cloud‑Daten geladen');
      }catch(err){
        console.error(err);
        var msg = (err && err.message) ? err.message : String(err);
        $('#cloudStatus').textContent='Status: Fehler ('+msg+')';
        $('#statusCloud').textContent = 'Cloud: Fehler';
        toast('Cloud‑Download fehlgeschlagen: '+msg);
      }
    }
    async function cloudPushAll(){
      try{
        await cloudPushAllInternal();
      }catch(e){
        try{
          if(typeof queueTask === 'function'){
            queueTask('pushAll');
          }
          if(typeof toast === 'function'){
            toast('Cloud nicht erreichbar – in Warteschlange abgelegt');
          }
          try{
            var st = document.getElementById('cloudStatus');
            if(st) st.textContent = 'Status: offline (Warteschlange)';
            var sc = document.getElementById('statusCloud');
            if(sc) sc.textContent = 'Cloud: offline (Warteschlange)';
          }catch(_){}
        }catch(_){}
        throw e;
      }
    }
    async function cloudPushAllInternal(){
      var cfg=readBrConfig(); if(!cfg.tblItems) throw new Error('Items‑Tabelle fehlt');
      $('#cloudStatus').textContent='Status: schreibe ...'; $('#statusCloud').textContent = 'Cloud: schreibt ...';

      try{
        if(localStorage.getItem('lagerverwaltung_cap_category_sync')!=='1'){
          var probe = await brListAll(cfg.tblItems, { size:1 });
          _autoEnableCategorySyncIfSupported(probe);
        }
      }catch(_){}
      var rows = await brListAll(cfg.tblItems);
      var idx = {}; rows.forEach(function(r){ idx[r.app_id]=r.id });
      for(var i=0;i<items.length;i++){
        var it=items[i]; var payload=itemToRow(it);
        if(idx[it.id]){ await brUpdate(cfg.tblItems, idx[it.id], payload) } else { await brCreate(cfg.tblItems, payload) }
      }
      await pushGroupsOnly();
      await pushMembersOnly();
      $('#cloudStatus').textContent='Status: online'; $('#statusCloud').textContent = 'Cloud: online';
    }
    async function pushGroupsOnly(){
      var cfg=readBrConfig(); if(!(cfg.tblGroups)) return;
      var remote = await brListAll(cfg.tblGroups);
      // Index: lokale Gruppen-ID -> Supabase-Row-ID
      var idx = {};
      remote.forEach(function(r){
        var appId = r.Groups_ID || r.Groups_id || r.groups_id || r.id;
        if(appId){
          idx[String(appId)] = r.id;
        }
      });
      for(var i=0;i<groups.length;i++){
        var g = groups[i];
        var key = String(g.id || '');
        var payload = {
          Groups_ID: key,
          name: g.name,
          perms: JSON.stringify(g.perms || {}),
          is_system: !!g.is_system,
          is_owner_admin: !!g.is_owner_admin
        };
        if(idx[key]){
          await brUpdate(cfg.tblGroups, idx[key], payload);
        }else{
          await brCreate(cfg.tblGroups, payload);
        }
      }
    
              try{
                var remoteAll = await brListAll(cfg.tblGroups);
                var localIds = new Set((groups||[]).map(function(g){ return String(g && g.id || ''); }));
                for (var i=0;i<remoteAll.length;i++){
                  var r = remoteAll[i] || {}; var rid = String(r.id||'');
                  if (rid && !localIds.has(rid) && rid.indexOf('g-')===0){
                    try{ await brDelete(cfg.tblGroups, rid); }catch(_){ }
                  }
                }
              }catch(_){ }
    
}
    async function pushMembersOnly(){
      var cfg=readBrConfig(); if(!(cfg.tblMembers)) return;
      var remote = await brListAll(cfg.tblMembers);
      var idx = {}; remote.forEach(function(r){ idx[(String(r.username||'').toLowerCase())]=r.id });
      for(var i=0;i<members.length;i++){
        var m=members[i]; var payload=memberToRow(m);
        var key=(String(m.username||'').toLowerCase());
        if(idx[key]){ await brUpdate(cfg.tblMembers, idx[key], payload) } else { await brCreate(cfg.tblMembers, payload) }
      }
    }

    // ===== Password hashing (PBKDF2‑SHA256) =====
    function b64(buf){ var b = new Uint8Array(buf); var s=''; for(var i=0;i<b.length;i++){ s+=String.fromCharCode(b[i]) } return btoa(s) }
    function b64toBytes(b){ var s=atob(b); var arr=new Uint8Array(s.length); for(var i=0;i<s.length;i++){ arr[i]=s.charCodeAt(i) } return arr }
    function randomSalt(len){ var u=new Uint8Array(len); crypto.getRandomValues(u); return b64(u) }
    async function pbkdf2Hash(password, saltB64, iter){
      var enc=new TextEncoder();
      var key = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveBits']);
      var bits = await crypto.subtle.deriveBits({name:'PBKDF2', hash:'SHA-256', salt: b64toBytes(saltB64), iterations: iter||200000}, key, 256);
      return b64(bits);
    }

    // ===== App rendering & UI =====
    function render(){
      var view = items.slice();
      var q = (filterText||"").trim().toLowerCase();
      if(q){ view = view.filter(function(x){ return (String(x.name||"").toLowerCase().indexOf(q)>=0) || (String(x.sku||"").toLowerCase().indexOf(q)>=0) }) }
      function dateOrNull(v){ return v ? new Date(v).getTime() : 0 }
      view.sort(function(a,b){
        if(sortMode==="updated_desc") return (b.updatedAt||0) - (a.updatedAt||0);
        if(sortMode==="name_asc") return String(a.name||"").localeCompare(String(b.name||""));
        if(sortMode==="sku_asc") return String(a.sku||"").localeCompare(String(b.sku||""));
        if(sortMode==="qty_desc") return (Number(b.qty)||0) - (Number(a.qty)||0);
        if(sortMode==="in_asc") return dateOrNull(a.inDate)-dateOrNull(b.inDate);
        if(sortMode==="out_asc") return dateOrNull(a.outDate)-dateOrNull(b.outDate);
        return 0;
      });
      var wrap = $('#cards'); wrap.innerHTML = "";
      $('#empty').hidden = !!view.length;
      view.forEach(function(it){
        var card = document.createElement('article'); card.className='card'; card.setAttribute('data-id', (it&&it.id)||''); card.tabIndex=0; card.setAttribute('role','group');
        var badge=document.createElement('div'); var hasIn=!!it.inDate, hasOut=!!it.outDate; var badgeClass='neutral', status='Ohne Datum';
        if(hasOut){ badgeClass='out'; status='Ausgang gebucht'; } else if(hasIn){ badgeClass='ok'; status='Eingang gebucht'; } else { badgeClass='warn' }
        badge.className='badge '+badgeClass; badge.textContent=status;
        var title=document.createElement('h3'); title.textContent=it.name||'—';
        var meta=document.createElement('div'); meta.className='meta';
meta.innerHTML = '<div class="cell">'
  + '<div class="lbl">Art.-Nr.</div>'
  + '<div class="val">'+escapeHtml(it.sku||'—')+'</div>'
  + '<div class="subl">Ein</div>'
  + '<div class="subv">'+fmtBookingDateFromLog(it, "in")+'</div>'
  + '</div>'
  + '<div class="cell">'
  + '<div class="lbl">Menge</div>'
  + '<div class="val">'+(Number(it.qty)||0)+'</div>'
  + '<div class="subl">Aus</div>'
  + '<div class="subv">'+fmtBookingDateFromLog(it, "out")+'</div>'
  + '</div>';
card.append(badge, title, meta);
// V37: Kategorie-Chip (absolut positioniert, keine Layout-Änderung)
(function(){
  var catName = String(it.category||'').trim();
  // toleriert Schreibweisen mit/ohne Bindestrich
  if(catName === 'Messtechnik-Nord'){ catName = 'Messtechnik Nord'; }
  var CAT_SHORT = { 'Neuware':'NW', 'Zusatzmaterial':'ZM', 'Verbrauchsmaterial':'VBR', 'Messtechnik Nord':'ME', 'Werkzeug':'WG', 'Wärmezähler':'WMZ', 'Kaltwasserzähler':'KWZ', 'Warmwasserzähler':'WWZ', 'Heizkostenverteiler':'HKV', 'Rauchmelder':'RWM' };;
  var short = CAT_SHORT[catName] || '';
  if(short){
    var chip = document.createElement('div');
    chip.className = 'chip cat';
    chip.textContent = short;
    chip.title = 'Kategorie: ' + catName;
    badge.appendChild(chip);
  }
})();

        /* Aktionszeile entfernt – Karte bleibt klickbar */

        card.addEventListener('click',function(){ if(has('edit_items')) openEdit(it.id) });
        card.addEventListener('keydown',function(e){ if((e.key==='Enter'||e.key===' ')&& has('edit_items')){ e.preventDefault(); openEdit(it.id) } });
        wrap.appendChild(card);
      });
      $('#btnNew').disabled=!has('edit_items');
      $('#btnBookIn').disabled=!has('book');
      $('#btnBookOut').disabled=!has('book');
    }

    function renderOverview(filter){
      var q=(filter||'').trim().toLowerCase(); var wrap=$('#overviewTable').querySelector('tbody'); wrap.innerHTML='';
      var view=items.slice();
      if(q){ view=view.filter(function(x){ return (String(x.name||'').toLowerCase().indexOf(q)>=0)||(String(x.sku||'').toLowerCase().indexOf(q)>=0) }) }
      view.sort(function(a,b){ var n=String(a.name||'').localeCompare(String(b.name||'')); if(n!==0) return n; return String(a.sku||'').localeCompare(String(b.sku||'')) });
      view.forEach(function(it){ var tr=document.createElement('tr'); var td1=document.createElement('td'); td1.textContent=it.name||'—'; var td2=document.createElement('td'); td2.textContent=it.sku||'—'; var td3=document.createElement('td'); td3.textContent=String(Number(it.qty)||0); tr.append(td1,td2,td3); tr.addEventListener('click',function(){ $('#overview').close(); if(has('edit_items')) openEdit(it.id) }); wrap.appendChild(tr) });
      $('#overviewCount').textContent=view.length+' Einträge';
    }

    // ===== Editor / Buchen =====
    var dlg=$('#modal'), form=$('#form');
    var $name=$('#name'), $sku=$('#sku'), $qty=$('#qty'), $reason=$('#changeReason'), $notes=$('#notes'), $in=$('#inDate'), $out=$('#outDate');
    var $skuHint=$('#skuHint'), $history=$('#history');
    function openNew(){ if(!has('edit_items')){ toast('Keine Berechtigung'); return } editId=null; $('#modalTitle').textContent='Material anlegen'; $('#btnDelete').hidden=true; form.reset(); $skuHint.textContent=''; $qty.value=0; $reason.value=''; renderHistory([]); dlg.showModal(); setTimeout(function(){ $name.focus() },50) }
    function openEdit(id){
      if(!has('edit_items')){ toast('Keine Berechtigung'); return }
      var it=items.find(function(x){ return x.id===id }); if(!it) return;
      editId=id; $('#modalTitle').textContent='Material bearbeiten'; $('#btnDelete').hidden=!has('delete_items');
      $name.value=it.name||''; $sku.value=it.sku||''; $qty.value=Number(it.qty)||0; $notes.value=it.notes||''; $in.value=it.inDate||''; $out.value=it.outDate||''; $reason.value=''; $skuHint.textContent='';
      renderHistory(it.log||[]); dlg.showModal(); setTimeout(function(){ $name.focus() },50);
    }
    function renderHistory(log){

  try{
    var box = document.getElementById('history');
    if(!box){ return; }
    box.innerHTML = '';
    if(!Array.isArray(log) || !log.length){
      box.innerHTML = '<div class="muted">Keine Einträge</div>';
      return;
    }
    log.slice().sort(function(a,b){ return b.ts - a.ts }).forEach(function(L){
      var row   = document.createElement('div');
      var date  = new Date(L.ts).toLocaleString('de-DE');
      var delta = Number(L.delta)||0;
      var isQty = (L.type === 'qty');
var t = String(L.type||'').toLowerCase();
var inAliases  = ['in','bookin','eingang','accession'];
var outAliases = ['out','bookout','ausgang','withdraw'];
var d = 0; try { d = Number(String(L.delta==null?0:L.delta).toString().replace(',', '.')) || 0 } catch(_) { d = 0 }
var isIn  = (inAliases.indexOf(t)  >= 0) || (isQty && d > 0);
var isOut = (outAliases.indexOf(t) >= 0) || (isQty && d < 0);
if(!isIn && !isOut){ var r = String(L.reason||'').toLowerCase(); if(/eingang|zugang/.test(r)) isIn = true; else if(/ausgang|entnahme/.test(r)) isOut = true; }


      var label = isQty
        ? (delta > 0 ? 'Zugang' : 'Entnahme')
        : (L.type === 'in' ? 'Eingang' : (L.type === 'out' ? 'Ausgang' : String(L.type||'')));

      var who = L.user ? (' · ' + L.user) : '';

      var sDate = document.createElement('span');
      sDate.className = 'muted';
      sDate.textContent = date + who;

      var badge = document.createElement('span');
      badge.className = 'badge ' + (isIn ? 'in' : (isOut ? 'out' : ''));
      badge.textContent = label;

      var strong = document.createElement('strong');
      var deltaTxt = (L.type==='in'||L.type==='out')
        ? (L.type==='in' ? 'Eingang' : 'Ausgang')
        : ((delta>=0?'+':'')+delta);
      strong.textContent = deltaTxt;

      row.appendChild(sDate);
      row.appendChild(document.createTextNode(' · '));
      row.appendChild(badge);
      row.appendChild(document.createTextNode(' · '));
      row.appendChild(strong);

      if (L.reason){
        row.appendChild(document.createTextNode(' · '));
        var r = document.createElement('span');
        r.textContent = L.reason;
        row.appendChild(r);
      }

      box.appendChild(row);
    });
  }catch(e){
    try{
      var box = document.getElementById('history');
      if(box){ box.innerHTML = '<div class="muted">Keine Einträge</div>'; }
    }catch(_){}
    console.error('renderHistory failed:', e);
  }

}
    function closeModal(){ dlg.close() }
    function saveFromModal(){
      if(!has('edit_items')){ toast('Keine Berechtigung'); return }
      var name=($name.value||'').trim(); var sku=($sku.value||'').trim(); var qty=Math.max(0, Math.floor(Number($qty.value||0)));
      var notes=($notes.value||'').trim(); var inDate=$in.value||''; var outDate=$out.value||''; var reason=($reason.value||'').trim();
      if(!name||!sku){ toast('Bezeichnung und Artikelnummer sind Pflichtfelder'); return }
      var duplicate=items.find(function(x){ return x.sku && x.sku.toLowerCase()===sku.toLowerCase() && x.id!==editId }); if(duplicate){ $skuHint.textContent='Achtung: Diese Artikelnummer existiert bereits.'; toast('Artikelnummer bereits vorhanden'); return }
      if(editId){
        var idx=items.findIndex(function(x){ return x.id===editId });
        if(idx>=0){
          var old=items[idx]; var log=old.log?old.log.slice():[]; var delta=qty-(Number(old.qty)||0);
          if(delta!==0){
          var signedKind = delta>0 ? 'in' : 'out';
          var qtyReason = reason || (delta>0 ? 'Zugang' : 'Entnahme');
          // qty log (like booking)
          var entryEditQty = { ts: Date.now(), type: 'qty', delta: delta, reason: qtyReason, user: currentUserEmail, itemId: (old && (old.id || old.sku || old.code)) || null, sku: (old && old.sku) || '' }; log.push(entryEditQty); try{ addLog(old, entryEditQty); }catch(_){};
          // ensure date fields are set (if empty)
          if(delta>0){ if(!inDate){ inDate = todayStr() } }
          if(delta<0){ if(!outDate){ outDate = todayStr() } }
          // extra semantic log entry (like saveBook: 'in'/'out')
          var entryEditKind = { ts: Date.now(), type: signedKind, delta: 0, reason: (reason || (signedKind === 'in' ? 'Eingang' : 'Ausgang')), user: currentUserEmail, itemId: (old && (old.id || old.sku || old.code)) || null, sku: (old && old.sku) || '' }; log.push(entryEditKind); try{ addLog(old, entryEditKind); }catch(_){};

        }items[idx]={ id:old.id, name, sku, qty, notes, inDate, outDate, log, createdAt:old.createdAt||Date.now(), updatedAt:Date.now() };
        }
        toast('Material gespeichert');
      }else{
        var initLog=[]; if(qty!==0){ initLog.push({ts:Date.now(), type:'qty', delta:qty, reason:reason||'Erstbestand', user: currentUserEmail}) }
        if(inDate){ initLog.push({ts:Date.now(), type:'in', delta:0, reason:'Eingang gesetzt', user: currentUserEmail}) }
        if(outDate){ initLog.push({ts:Date.now(), type:'out', delta:0, reason:'Ausgang gesetzt', user: currentUserEmail}) }
        items.unshift({ id:uid(), name, sku, qty, notes, inDate, outDate, log:initLog, createdAt:Date.now(), updatedAt:Date.now() });
        toast('Material angelegt');
      }
      saveJson(storageKey, items); render(); maybeCloudPushAll(); closeModal();
    }

    var bookDlg=$('#book');
    var $bookItemRow=$('#bookItemRow'), $bookItem=$('#bookItem'), $bookTitle=$('#bookTitle'), $bookDate=$('#bookDate'), $bookQty=$('#bookQty'), $bookQtyMinus=$('#bookQtyMinus'), $bookQtyPlus=$('#bookQtyPlus'), $bookQtyHint=$('#bookQtyHint'), $bookReason=$('#bookReason');
    var currentBookKind='in', currentBookId=null;

    function openBook(kind, id){
      if(!has('book')){ toast('Keine Berechtigung'); return }
      currentBookKind=kind; currentBookId=id||null; $bookTitle.textContent=(kind==='in'?'Wareneingang buchen':'Warenausgang buchen');
      $bookDate.value=todayStr(); $bookReason.value=''; $bookQty.value=0; $bookQtyHint.textContent=(kind==='in'?'Positive Zahl = Zugang':'Positive Zahl = Entnahme');
      $bookItem.innerHTML=''; items.forEach(function(it){ var opt=document.createElement('option'); opt.value=it.id; opt.textContent=(it.name||'—')+' · '+(it.sku||'—')+' · Bestand: '+(Number(it.qty)||0); $bookItem.appendChild(opt) });
      $bookItemRow.style.display = currentBookId ? 'none':'block'; if(!currentBookId && items.length){ $bookItem.value=items[0].id }
      
      // Button-Farbe je nach Buchungsart setzen (Eingang = grün, Ausgang = blau)
      (function(){
        var btn = document.getElementById('btnBookSave');
        if(btn){
          btn.classList.remove('primary','ok');
          btn.classList.add(kind==='in' ? 'ok' : 'primary');
        }
      })();
      bookDlg.showModal();
    }
    function saveBook(){
      if(!has('book')){ toast('Keine Berechtigung'); return }
      var id=currentBookId || $bookItem.value; if(!id){ toast('Bitte Material wählen'); return }
      var idx=items.findIndex(function(x){ return x.id===id }); if(idx<0){ toast('Material nicht gefunden'); return }
      var it=items[idx]; var d=$bookDate.value||todayStr(); var qtyChange=Math.max(0, Math.floor(Number($bookQty.value||0))); var reason=($bookReason.value||'').trim();
      if(currentBookKind==='in'){ it.inDate=d } else { it.outDate=d }
      if(qtyChange>0){
        var signed=currentBookKind==='in'?qtyChange:-qtyChange;
        var before=Number(it.qty)||0; var after=Math.max(0,before+signed); var delta=after-before; it.qty=after;
        var entryQty = {ts:Date.now(), type:'qty', delta:delta, reason:(reason|| (currentBookKind==='in'?'Zugang':'Entnahme')), user: currentUserEmail, itemId: (it && (it.id || it.sku || it.code)) || null, sku: (it && it.sku) || ''}; addLog(it, entryQty);
      }
      var entryKind = {ts:Date.now(), type:currentBookKind, delta:0, reason:reason || (currentBookKind==='in'?'Eingang':'Ausgang'), user: currentUserEmail, itemId: (it && (it.id || it.sku || it.code)) || null, sku: (it && it.sku) || ''}; addLog(it, entryKind);
      it.updatedAt=Date.now();
      saveJson(storageKey, items); render(); maybeCloudPushAll(); bookDlg.close(); toast('Buchung gespeichert');
    }

    function addLog(it, entry){ if(!it.log) it.log=[]; it.log.push(entry) }

    function adjustQty(id, by){
      if(!has('adjust_qty')){ toast('Keine Berechtigung'); return }
      var idx=items.findIndex(function(x){ return x.id===id }); if(idx<0) return;
      var it=items[idx]; var reason=window.prompt("Info zur Mengenänderung (optional):",(by<0?"Entnahme":"Zugang"));
      var before=Number(it.qty)||0; var after=Math.max(0,before+by); var delta=after-before; if(delta===0){ toast('Menge unverändert'); return }
      it.qty=after; var entryAdj = {ts:Date.now(),type:'qty',delta:delta,reason:reason|| (by<0?'Entnahme':'Zugang'), user: currentUserEmail, itemId: (it && (it.id || it.sku || it.code)) || null, sku: (it && it.sku) || ''}; addLog(it, entryAdj); it.updatedAt=Date.now();
      saveJson(storageKey, items); render(); maybeCloudPushAll(); toast('Menge aktualisiert');
    }

    function removeItem(id){
      if(!has('delete_items')){ toast('Keine Berechtigung'); return }
      var it=items.find(function(x){ return x.id===id }); if(!it) return;
      if(!confirm('„'+(it.name||it.sku)+'“ wirklich löschen?')) return;
      items=items.filter(function(x){ return x.id!==id }); saveJson(storageKey, items); render(); maybeCloudPushAll(); toast('Artikel gelöscht');
    }

    // ===== Global history =====
    function aggregateHistory(){
      var rows=[];
      items.forEach(function(it){
        (it.log||[]).forEach(function(L){
          rows.push({
            ts:L.ts||0, user:L.user||'—', type:L.type||'?', itemName: it.name||'—', sku: it.sku||'—', delta: Number(L.delta)||0, reason: L.reason||''
          });
        });
      });
      rows.sort(function(a,b){ return b.ts - a.ts });
      return rows;
    }

function openHistory(){
      try{ if(!(typeof hasRight==='function' ? hasRight('view_history') : (window.currentPerms && currentPerms.view_history))){ if(typeof toast==='function') toast('Keine Berechtigung'); else alert('Keine Berechtigung'); return; } }catch(_){ /* fallback: no-op */ }

      var tbody = $('#historyTable').querySelector('tbody'); tbody.innerHTML='';
      var rows = aggregateHistory();
      $('#histCount').textContent = rows.length+' Einträge';
      rows.forEach(function(r){
        var tr=document.createElement('tr');
        var isQty = (r.type==='qty');
var t = String(r.type||'').toLowerCase();
var inAliases  = ['in','bookin','eingang','accession'];
var outAliases = ['out','bookout','ausgang','withdraw'];
var d = 0; try{ d = Number(String(r.delta==null?0:r.delta).toString().replace(',', '.'))||0 }catch(_){ d=0 }
var isIn  = (inAliases.indexOf(t)>=0) || (isQty && d>0);
var isOut = (outAliases.indexOf(t)>=0) || (isQty && d<0);

        var typeLabel = (isQty ? (Number(r.delta)>0 ? 'Zugang' : 'Entnahme') : (r.type==='in'?'Eingang':(r.type==='out'?'Ausgang':String(r.type||'?'))));
        var typeCell = (isQty||r.type==='in'||r.type==='out')
          ? '<span class="badge '+(isIn?'in':(isOut?'out':''))+'">'+escapeHtml(typeLabel)+'</span>'
          : escapeHtml(typeLabel);
        var deltaVal = Number(r.delta)||0;
        var deltaCell = '<span class="'+(deltaVal>0?'delta-pos':(deltaVal<0?'delta-neg':''))+'">'+((deltaVal>=0?'+':'')+deltaVal)+'</span>';
        tr.innerHTML =
            '<td>'+escapeHtml(new Date(r.ts).toLocaleString('de-DE'))+'</td>'
          + '<td>'+escapeHtml(r.user)+'</td>'
          + '<td>'+typeCell+'</td>'
          + '<td>'+escapeHtml((r.itemName||'')+' · '+(r.sku||''))+'</td>'
          + '<td>'+deltaCell+'</td>'
          + '<td>'+escapeHtml(r.reason||'')+'</td>';
        tbody.appendChild(tr);
      });
      $('#historyDlg').showModal();
    }

    // ===== Groups / Members UI (password set) =====
    // === Gruppen & Rechte – Editor (bereinigt v20ad) ===
function refreshGroupUI(){
  try{
    var tbody = $('#groupsTable').querySelector('tbody'); tbody.innerHTML='';
    if (!Array.isArray(groups) || !groups.length){
      tbody.innerHTML = '<tr><td colspan="4" class="hint">Keine Gruppen vorhanden</td></tr>';
    } else {
      groups.forEach(function(g, idx){
        var tr = document.createElement('tr');
        tr.innerHTML = '<td>'+(idx+1)+'</td>'
          + '<td>'+escapeHtml(g.name||'')+'</td>'
          + '<td>'+(g.is_owner_admin? 'Admin' : (g.is_system ? 'System' : '—'))+'</td>'
          + '<td>'+ (g.perms ? Object.keys(g.perms).filter(function(k){ return g.perms[k]; }).length : 0) +'</td>';
        tr.addEventListener('click', function(){ openGroupEditor(g.id); });
        tbody.appendChild(tr);
      });
    }
    var sel = $('#memberGroup');
    if (sel){
      sel.innerHTML = '<option value="">Nicht zugeordnet</option>';
      (groups||[]).forEach(function(g){
        if (!g) return;
        var o = document.createElement('option');
        o.value = g.id; o.textContent = g.name||'';
        sel.appendChild(o);
      });
    }
  }catch(_){}
}

// Robust: zentrales Speichern der aktuell geöffneten Gruppe
function saveCurrentGroup(){
  try{
    var id = window.currentGroupId;
    var g = (groups||[]).find(function(x){ return x && x.id===id; });
    if (!g){ toast('Keine Gruppe gewählt'); return; }
    // Name übernehmen
    try{ g.name = ($('#groupName') ? $('#groupName').value.trim() : g.name) || g.name; }catch(_){}
    // Rechte übernehmen (wenn erlaubt)
    var canEditPerms = false;
    try{ canEditPerms = !!((typeof isAdmin==='function' && isAdmin()) || (typeof has==='function' && has('manage_users'))); }catch(_){}
    if (canEditPerms){
      try{
        $all('#groupEditor .perm-chk').forEach(function(chk){
          var key = chk.getAttribute('data-perm');
          if (!g.perms) g.perms = {};
          g.perms[key] = !!chk.checked;
        });
      }catch(_){}
    }
    // Persistieren
    saveJson(groupsKey, groups);
    refreshGroupUI();
    toast('Gruppe gespeichert');
    try { if (typeof maybeCloudPushGroups==='function') { maybeCloudPushGroups(); } } catch(e) {}
  }catch(e){
    try{ if (window.console) console.error(e); }catch(_){}
    alert('Speichern fehlgeschlagen');
  }
}

function openGroupEditor(id){
  try{
    window.currentGroupId = id;
    var g = (groups||[]).find(function(x){ return x && x.id===id; });
    if (!g){ $('#groupEditor').style.display = 'none'; return; }
    $('#groupEditor').style.display = 'grid';
    $('#groupName').value = g.name || '';
    var canEditPerms = !!((typeof isAdmin==='function' && isAdmin()) || (typeof has==='function' && has('manage_users')));
    $('#groupStatus').textContent = g.is_owner_admin ? 'Admin' : (g.is_system ? 'System' : 'Benutzerdefiniert');
    try{ var delBtn=document.getElementById('btnGroupDelete'); if(delBtn){ delBtn.disabled = !!(g.is_owner_admin || g.is_system); } }catch(_){}

    // Perm-Checkboxen setzen
    $all('#groupEditor .perm-chk').forEach(function(chk){
      var key = chk.getAttribute('data-perm');
      chk.checked = !!(g.perms && g.perms[key]);
      chk.disabled = !canEditPerms;
    });

    // Speichern-Handler zentral
    $('#btnSaveGroup').onclick = saveCurrentGroup;
  }catch(_){}
}

function canManageGroups(){
  try{
    if (typeof has==='function' && has('manage_users')) return true;
    if (typeof isAdmin==='function' && isAdmin()) return true;
    var v = String(localStorage.getItem('lv_admin')||'').toLowerCase();
    if (v==='1' || v==='true' || v==='yes') return true;
  }catch(_){}
  return false;
}

function basePermsNewGroup(){
  var perms = {};
  try{
    var SAMPLE = (groups && groups[0] && groups[0].perms) ? groups[0].perms : null;
    if (SAMPLE){ Object.keys(SAMPLE).forEach(function(k){ perms[k] = false; }); }
  }catch(_){}
  perms.view_history = true;
  perms.view_alerts = true;
  return perms;
}

function uniqueGroupName(base){
  var name = String(base||'Neue Gruppe').trim() || 'Neue Gruppe';
  var n = name, i = 2;
  var exists = function(v){ 
    return (groups||[]).some(function(g){ 
      return String(g.name||'').toLowerCase()===String(v).toLowerCase(); 
    }); 
  };
  while (exists(n)){ n = name + ' ' + i; i++; if (i>999) break; }
  return n;
}

function createNewGroup(){
  if (!canManageGroups()){ toast('Keine Berechtigung'); return; }
  var id = 'g-' + (typeof uid==='function' ? String(uid()).replace(/^id-?/, '') : (Date.now().toString(36)));
  var g = { id:id, name: uniqueGroupName('Neue Gruppe'), perms: basePermsNewGroup(), is_system:false, is_owner_admin:false };
  groups = Array.isArray(groups) ? groups.slice() : [];
  groups.push(g);
  saveJson(groupsKey, groups);
  refreshGroupUI();
  openGroupEditor(id);
  toast('Gruppe angelegt');
  try { if (typeof maybeCloudPushGroups==='function') { maybeCloudPushGroups(); } } catch(e) {}
}

function removeFromAlertsMaskByName(groupName){
  try{
    var raw = localStorage.getItem('alerts_group_mask')||'';
    var mask = []; try{ mask = JSON.parse(raw||'[]'); }catch(_){ mask = []; }
    if (!Array.isArray(mask)) mask = [];
    var before = mask.length;
    mask = mask.filter(function(n){ return String(n)!==String(groupName); });
    if (mask.length !== before){
      localStorage.setItem('alerts_group_mask', JSON.stringify(mask));
      if (typeof upsertAppSetting==='function'){
        upsertAppSetting('alerts_group_mask', mask).catch(function(_){ });
      }
    }
  }catch(_){}
}

function deleteCurrentGroup(){
  if (!canManageGroups()){ toast('Keine Berechtigung'); return; }
  var id = window.currentGroupId;
  var g = (groups||[]).find(function(x){ return x && x.id===id; });
  if (!g){ toast('Keine Gruppe gewählt'); return; }
  if (g.is_owner_admin || g.is_system){ alert('System-/Admin-Gruppe kann nicht gelöscht werden'); return; }
  if (!confirm('Gruppe "'+(g.name||'')+'" wirklich löschen?')) return;

  try{
    members = Array.isArray(members) ? members : [];
    for (var i=0;i<members.length;i++){ if (members[i] && members[i].group_id===id){ members[i].group_id = null; } }
    saveJson(membersKey, members);
  }catch(_){}

  try{ removeFromAlertsMaskByName(g.name||''); }catch(_){}

  try{
    groups = (groups||[]).filter(function(x){ return x && x.id!==id; });
    saveJson(groupsKey, groups);
  }catch(_){}

  try{ refreshGroupUI(); var ed=document.getElementById('groupEditor'); if(ed) ed.style.display='none'; }catch(_){}

  toast('Gruppe gelöscht');

  try { if (typeof maybeCloudPushGroups==='function') { maybeCloudPushGroups(); } } catch(e) {}
  try{ if (typeof maybeCloudPushMembers==='function') maybeCloudPushMembers(); }catch(_){}
  try{
    if (typeof upsertAppSetting==='function'){
      var raw = localStorage.getItem('alerts_group_mask')||'[]';
      var mask = []; try{ mask = JSON.parse(raw); }catch(_){ mask = []; }
      upsertAppSetting('alerts_group_mask', mask).catch(function(_){ });
    }
  }catch(_){}
}

// Wiring (einmalig)
document.addEventListener('DOMContentLoaded', function(){
  var n = document.getElementById('btnGroupNew');
  var d = document.getElementById('btnGroupDelete');
  if (n && !n.__wired){ n.addEventListener('click', createNewGroup); n.__wired=true; }
  if (d && !d.__wired){ d.addEventListener('click', deleteCurrentGroup); d.__wired=true; }
  try{
    var allowed = canManageGroups();
    if (n) n.style.display = allowed ? '' : 'none';
    if (d) d.style.display = allowed ? '' : 'none';
  }catch(_){}
});

function refreshMembersUI(){
      var tbody = $('#membersTable').querySelector('tbody');
      tbody.innerHTML = '';
      if(!members.length){
        tbody.innerHTML = '<tr><td colspan="5" class="hint">Keine Benutzer vorhanden</td></tr>';
        $('#membersAdminUi').style.display = has('manage_users') ? 'block' : 'none';
        $('#membersReadonlyUi').style.display = has('manage_users') ? 'none' : 'block';
        return;
      }
      members.forEach(function(m){
        var tr = document.createElement('tr');
        tr.setAttribute('data-username', (m.username||'').trim());
        var tdU = document.createElement('td');
        tdU.textContent = (m.username || '—');

        var sel = document.createElement('select');
        sel.className = 'input';
        sel.style.maxWidth = '240px';
        sel.innerHTML = '<option value="">Nicht zugeordnet</option>';
        groups.forEach(function(g){
          var o = document.createElement('option');
          o.value = g.id;
          o.textContent = g.name;
          sel.appendChild(o);
        });
        sel.value = m.group_id || '';
        sel.addEventListener('change', function(){
          m.group_id = sel.value || null;
          saveJson(membersKey, members);
          if(typeof toast === 'function'){ toast('Gruppe zugewiesen'); }
          if(typeof maybeCloudPushMembers === 'function'){ maybeCloudPushMembers(); }
        });
        var tdG = document.createElement('td');
        tdG.appendChild(sel);

        // Zusatzrechte werden hier nicht mehr pro Benutzer bearbeitet – Steuerung läuft über Gruppen.
        var tdP = document.createElement('td');
        tdP.textContent = '—';

        // Passwort-Button (wird von späterem Patch auf __openPwForUser umgebogen)
        var tdPw = document.createElement('td');
        var btnPw = document.createElement('button');
        btnPw.className = 'btn';
        btnPw.textContent = 'Setzen / Ändern';
        tdPw.appendChild(btnPw);

        var tdA = document.createElement('td');
        var btnDel = document.createElement('button');
        btnDel.className = 'btn warn';
        btnDel.textContent = 'Entfernen';
        btnDel.addEventListener('click', function(){
          if(!confirm('Benutzer wirklich entfernen?')) return;
          members = members.filter(function(x){
            return (x.username||'') !== (m.username||'');
          });
          saveJson(membersKey, members);
          refreshMembersUI();
          if(typeof maybeCloudPushMembers === 'function'){ maybeCloudPushMembers(); }
        });
        tdA.appendChild(btnDel);

        tr.append(tdU, tdG, tdP, tdPw, tdA);
        tbody.appendChild(tr);
      });
      $('#membersAdminUi').style.display = has('manage_users') ? 'block' : 'none';
      $('#membersReadonlyUi').style.display = has('manage_users') ? 'none' : 'block';
    }

    $('#btnAddMember') && $('#btnAddMember').addEventListener('click', function(){
  if(!has('manage_users')){ toast('Keine Berechtigung'); return }
  var uname=$('#memberUsername')? $('#memberUsername').value.trim() : '';
  var gid=$('#memberGroup').value||null;
  if(!uname){ toast('Benutzername eingeben'); return }
  var existsUser = members.find(function(x){ return (x.username||'').toLowerCase()===uname.toLowerCase() });
  if(existsUser){ toast('Benutzername existiert bereits'); return }
  members.push({username:uname, group_id:gid, perm:{}, pw_salt:null, pw_hash:null});
  saveJson(membersKey, members);
  refreshMembersUI(); maybeCloudPushMembers(); toast('Benutzer erfasst');
});

    // ===== Login (with password) =====
    function requireLoginNow(){ return true }
    async function tryLogin(loginId, password){
  var loginStr = String(loginId||'').trim().toLowerCase();
  var m = members.find(function(x){ return (x.username||'').toLowerCase()===loginStr });
  if(!m){ throw new Error('Unbekannter Benutzer'); }
  if(!(m.pw_salt && m.pw_hash)){ throw new Error('Kein Passwort gesetzt. Admin muss es setzen.'); }
  // Passwort prüfen (PBKDF2, wie vorhanden)
  return pbkdf2Hash(String(password||''), m.pw_salt, 200000).then(function(hash){
    if(hash !== m.pw_hash){ throw new Error('Passwort falsch'); }
    setSession(m.username, document.getElementById('loginRemember') && document.getElementById('loginRemember').checked);
    toast('Angemeldet: ' + (m.username || '—'));
  });
}

    // ===== Backup (Cloud) =====
    function buildFullBackup(includeToken){
      var cfg=readBrConfig();
      return {
        _type: 'lagerverwaltung_backup',
        _version: 13,
        createdAt: new Date().toISOString(),
        author: currentUserEmail || '—',
        config: {
          url: cfg.url || '',
          token: includeToken ? (cfg.token||'') : null,
          tables: { items: cfg.tblItems||'', groups: cfg.tblGroups||'', members: cfg.tblMembers||'', backups: cfg.tblBackups||'', app_settings: cfg.tblAppSettings||'' },
          autoSync: !!cfg.autoSync,
          requirePw: !!cfg.requirePw
        },
        storage: {
          items: items,
          groups: groups,
          members: members,
          outbox: outbox
        }
      };
    }
    async function cloudBackupNow(includeToken){
      try{ await cloudBackupNowInternal(includeToken); toast('Cloud‑Backup gespeichert') }
      catch(e){ queueTask('backupCloud',{includeToken:includeToken}); toast('Cloud nicht erreichbar – Backup in Warteschlange') }
    }
    async function cloudBackupNowInternal(includeToken){
      var cfg=readBrConfig(); if(!cfg.tblBackups) throw new Error('Backups‑Tabelle fehlt');
      var backup = buildFullBackup(!!includeToken);
      var payload = { created_at: backup.createdAt, author: backup.author, version: backup._version, data: JSON.stringify(backup) };
      await brCreate(cfg.tblBackups, payload);
    }
    async function cloudBackupsList(){
      var cfg=readBrConfig(); if(!cfg.tblBackups) throw new Error('Backups‑Tabelle fehlt');
      var rows = await brListAll(cfg.tblBackups, { order_by:'-created_at' });
      return rows.map(function(r){
        var dataStr = r.data || '{}'; var sizeKb = Math.round((dataStr.length/1024)*10)/10;
        return { id:r.id, created_at:r.created_at || '', author:r.author||'—', version:r.version||'?', sizeKb:sizeKb, dataStr:dataStr };
      });
    }
    function renderBackups(rows){
      var tbody=$('#backupsTable').querySelector('tbody'); tbody.innerHTML='';
      if(!rows.length){ tbody.innerHTML = '<tr><td colspan="6" class="hint">Keine Backups gefunden</td></tr>'; return }
      rows.forEach(function(r){
        var tr=document.createElement('tr');
        tr.innerHTML = '<td>'+escapeHtml(new Date(r.created_at).toLocaleString('de-DE'))+'</td>'
          + '<td>'+escapeHtml(r.author)+'</td>'
          + '<td>'+escapeHtml(String(r.version||''))+'</td>'
          + '<td>'+escapeHtml(String(r.sizeKb))+'</td>'
          + '<td></td>';
        var tdActions = tr.lastChild;
        var btnDl = document.createElement('button'); btnDl.className='btn'; btnDl.textContent='Herunterladen';
        btnDl.addEventListener('click', function(){
          var blob=new Blob([r.dataStr],{type:'application/json'});
          var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='lager-backup-'+(r.created_at.replace(/[:.]/g,'-'))+'.json'; a.click(); setTimeout(function(){ URL.revokeObjectURL(a.href) },1500);
        });
        var btnRestore = document.createElement('button'); btnRestore.className='btn warn'; btnRestore.textContent='Wiederherstellen';
        btnRestore.addEventListener('click', function(){
          if(!confirm('Lokale Daten und Einstellungen durch dieses Backup ersetzen?')) return;
          try{
            var bk = JSON.parse(r.dataStr);
            if(!(bk && bk._type==='lagerverwaltung_backup')) throw new Error('Ungültiges Backup');
            // Restore storage
            items = Array.isArray(bk.storage&&bk.storage.items) ? bk.storage.items : items;
            groups = Array.isArray(bk.storage&&bk.storage.groups) ? bk.storage.groups : groups;
            members = Array.isArray(bk.storage&&bk.storage.members) ? bk.storage.members : members;
            outbox = Array.isArray(bk.storage&&bk.storage.outbox) ? bk.storage.outbox : outbox;
            saveJson(storageKey, items); saveJson(groupsKey, groups); saveJson(membersKey, members); saveJson(outboxKey, outbox);
            // Restore config (without token if null)
            var cfg=bk.config||{};
            if(cfg.url) localStorage.setItem(brUrlKey, cfg.url);
            if(cfg.tables){
              if(cfg.tables.items) localStorage.setItem(brTblItemsKey, cfg.tables.items);
              if(cfg.tables.groups) localStorage.setItem(brTblGroupsKey, cfg.tables.groups);
              if(cfg.tables.members) localStorage.setItem(brTblMembersKey, cfg.tables.members);
              if(cfg.tables.backups) localStorage.setItem(brTblBackupsKey, cfg.tables.backups);
            }
            if(typeof cfg.autoSync==='boolean') localStorage.setItem(autoSyncKey, cfg.autoSync?'1':'0');
            if(typeof cfg.requirePw==='boolean') localStorage.setItem(requirePwKey, cfg.requirePw?'1':'0');
            if(cfg.token){ localStorage.setItem(brTokenKey, cfg.token) } // only if present in backup
            applyBrConfigToUi(); render(); refreshGroupUI(); refreshMembersUI(); setSectionsByPerms();
            toast('Backup wiederhergestellt');
          }catch(e){ console.error(e); toast('Wiederherstellung fehlgeschlagen') }
        });
        tdActions.appendChild(btnDl); tdActions.appendChild(document.createTextNode(' ')); tdActions.appendChild(btnRestore);
        tbody.appendChild(tr);
      });
      $('#backupsInfo').textContent = rows.length+' Backup(s) gefunden.';
    }
    // ===== Init & bindings =====
    function setSectionsByPerms(){
      var any = !!(currentPerms.manage_settings || currentPerms.manage_users || currentPerms.export_import || currentPerms.print_excel || currentPerms.backup);
      // Menü-Button immer anzeigen (Logout & Einstellungen zugänglich)
      $('#btnMenu').style.display = 'grid';
      $('#secCloud').style.display   = currentPerms.manage_settings ? 'block' : 'none';
      $('#secGroups').style.display  = currentPerms.manage_users ? 'block' : 'none';
      $('#secUsers').style.display   = currentPerms.manage_users ? 'block' : 'none';
      $('#secData').style.display    = currentPerms.export_import ? 'block' : 'none';
      $('#secPrint').style.display   = currentPerms.print_excel ? 'block' : 'none';
      $('#secBackup').style.display  = currentPerms.backup ? 'block' : 'none';

      var histLink = document.getElementById('openHistory');
      if (histLink && histLink.parentElement){
        histLink.parentElement.style.display = currentPerms.view_history ? '' : 'none';
      
      var expBtn = document.getElementById('btnHistoryExport');
      if (expBtn){
        expBtn.style.display = (currentPerms && currentPerms.export_history) ? '' : 'none';
      }

    }
      var alertsLink = document.getElementById('openAlerts');
      if (alertsLink && alertsLink.parentElement){
        alertsLink.parentElement.style.display = currentPerms.view_alerts ? '' : 'none';
      }
    
      // Sync-spezifische UI (Buttons & Optionen)
      try{
        if (typeof updateManualPushVisibility === 'function'){
          updateManualPushVisibility();
        }
      }catch(_){}

      var btnPull = document.getElementById('btnPull');
      var btnPush = document.getElementById('btnPush');
      var canAdvanced = !!(currentPerms && (currentPerms.sync_advanced || currentPerms.manage_settings));
      if (btnPull){
        btnPull.disabled = !canAdvanced;
      }
      if (btnPush){
        btnPush.disabled = !canAdvanced;
      }

      var btnRetry = document.getElementById('btnRetryOutbox');
      if (btnRetry){
        var canOutbox = !!(currentPerms && (currentPerms.sync_basic || currentPerms.sync_advanced));
        btnRetry.style.display = canOutbox ? '' : 'none';
      }

      var syncDetails = document.getElementById('syncOptionsDetails');
      if (syncDetails){
        var canManageSync = !!(currentPerms && currentPerms.sync_manage_options);
        syncDetails.style.display = canManageSync ? 'block' : 'none';
      }
}function init(){

      var stored = localStorage.getItem(sessionKey) || '';
      if(stored){ setSession(stored, true) } else { setSession('') }
      render(); refreshGroupUI(); refreshMembersUI();
      applyBrConfigToUi(); updateOutboxUi(); updateManualPushVisibility();

        var btnMP = document.getElementById('btnManualPush'); if(btnMP){ btnMP.addEventListener('click', function(){ manualSync(); }); }
      if(requireLoginNow() && !stored){ $('#login').showModal() }
      
    }

    // Bindings (main UI)

    // v26: bind cloud selftest button (idempotent)
    (function(){
      try{
        var el = document.getElementById('btnCloudSelftest');
        if(el && !el.__lv_bind){
          el.addEventListener('click', function(){ try{ cloudSelftest(); }catch(e){ console && console.error(e); } });
          el.__lv_bind = true;
        }
      }catch(_){}
    })();

    // v25: Settings save binding (stores Cloud + general settings and closes dialog)
    $('#btnSettingsOk') && $('#btnSettingsOk').addEventListener('click', function(){
      try {
        if (typeof writeBrConfig === 'function') writeBrConfig();
        if (typeof applyBrConfigToUi === 'function') applyBrConfigToUi();
        if (typeof setSectionsByPerms === 'function') setSectionsByPerms();
        if (typeof updateOutboxUi === 'function') updateOutboxUi();
      } catch(e) { console && console.warn('Settings save failed', e); }
      try { $('#settings').close(); } catch(_) {}
    });
    $('#btnOverview') && $('#btnOverview').addEventListener('click', function(){ renderOverview(''); $('#overview').showModal(); setTimeout(function(){ $('#overviewSearch').focus() },50) });
    $('#btnOverviewClose') && $('#btnOverviewClose').addEventListener('click', function(){ $('#overview').close() });
    $('#btnOverviewOk') && $('#btnOverviewOk').addEventListener('click', function(){ $('#overview').close() });
    $('#btnOverviewExport') && $('#btnOverviewExport').addEventListener('click', function(){ var data={version:12,exportedAt:new Date().toISOString(),items:items}; var blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='lager-export.json'; a.click(); setTimeout(function(){ URL.revokeObjectURL(a.href) },1500) });

    $('#btnNew') && $('#btnNew').addEventListener('click', openNew);
    $('#btnBookIn') && $('#btnBookIn').addEventListener('click', function(){ openBook('in',null) });
    $('#btnBookOut') && $('#btnBookOut').addEventListener('click', function(){ openBook('out',null) });
    $('#btnClose') && $('#btnClose').addEventListener('click', function(){ $('#modal').close() });
    $('#btnCancel') && $('#btnCancel').addEventListener('click', function(){ $('#modal').close() });
    $('#btnSave') && $('#btnSave').addEventListener('click', saveFromModal);
    $('#btnDelete') && $('#btnDelete').addEventListener('click', function(){ if(editId) removeItem(editId); $('#modal').close(); maybeCloudPushAll() });

    $('#btnBookClose') && $('#btnBookClose').addEventListener('click', function(){ $('#book').close() });
    $('#btnBookSave') && $('#btnBookSave').addEventListener('click', saveBook);
    $('#bookQtyPlus') && $('#bookQtyPlus').addEventListener('click', function(){ $('#bookQty').value=Math.max(0, Math.floor(Number($('#bookQty').value||0)+1)) });
    $('#bookQtyMinus') && $('#bookQtyMinus').addEventListener('click', function(){ $('#bookQty').value=Math.max(0, Math.floor(Number($('#bookQty').value||0)-1)) });
    // Edit dialog: Menge +/- buttons
    $('#qtyPlus') && $('#qtyPlus').addEventListener('click', function(){
      var el = $('#qty'); if(!el) return;
      var step = Math.abs(Number(el.step)||1);
      var min = Number(el.min)||0;
      var val = Math.floor(Number(el.value||0) + step);
      el.value = Math.max(min, val);
      try{ el.dispatchEvent(new Event('input', { bubbles:true })) }catch(_){}
    });
    $('#qtyMinus') && $('#qtyMinus').addEventListener('click', function(){
      var el = $('#qty'); if(!el) return;
      var step = Math.abs(Number(el.step)||1);
      var min = Number(el.min)||0;
      var val = Math.floor(Number(el.value||0) - step);
      el.value = Math.max(min, val);
      try{ el.dispatchEvent(new Event('input', { bubbles:true })) }catch(_){}
    });


    $('#search') && $('#search').addEventListener('input', function(e){ filterText=e.target.value; render() });
    $('#sortSelect') && $('#sortSelect').addEventListener('change', function(e){ sortMode=e.target.value; render() });

    $('#btnMenu') && $('#btnMenu').addEventListener('click', function(){ $('#settings').showModal() });
    $('#btnSettingsClose') && $('#btnSettingsClose').addEventListener('click', function(){ $('#settings').close() });
    $('#btnSettingsOk') && $('#btnSettingsOk').addEventListener('click', function(){ writeBrConfig(); updateManualPushVisibility(); $('#settings').close(); toast('Einstellungen gespeichert') });

    $('#btnSwitchUser') && $('#btnSwitchUser').addEventListener('click', function(){ $('#login').showModal() });
    $('#btnLogout') && $('#btnLogout').addEventListener('click', function(){ localStorage.removeItem(sessionKey); setSession(''); if(requireLoginNow()){ $('#login').showModal() } else { toast('Abgemeldet') } });

    // Lokale Lagerdaten löschen
    $('#btnClearLocalData') && $('#btnClearLocalData').addEventListener('click', function(){
      try{
        if(!confirm('Alle lokal gespeicherten Daten dieser Lagerverwaltung auf diesem Gerät löschen?\n\nCloud-Daten (Supabase) bleiben erhalten.')) return;
        // Nur Schlüssel entfernen, die eindeutig zur Lagerverwaltung gehören
        var prefixes = ['lv_', 'lagerverwaltung_'];
        try{
          var toRemove = [];
          for(var i=0;i<localStorage.length;i++){
            var k = localStorage.key(i);
            if(!k) continue;
            for(var p=0;p<prefixes.length;p++){
              if(k.indexOf(prefixes[p]) === 0){
                toRemove.push(k);
                break;
              }
            }
          }
          for(var j=0;j<toRemove.length;j++){
            try{ localStorage.removeItem(toRemove[j]); }catch(_){}
          }
        }catch(_){}
        try{
          var toRemoveS = [];
          for(var i2=0;i2<sessionStorage.length;i2++){
            var k2 = sessionStorage.key(i2);
            if(!k2) continue;
            for(var p2=0;p2<prefixes.length;p2++){
              if(k2.indexOf(prefixes[p2]) === 0){
                toRemoveS.push(k2);
                break;
              }
            }
          }
          for(var j2=0;j2<toRemoveS.length;j2++){
            try{ sessionStorage.removeItem(toRemoveS[j2]); }catch(_){}
          }
        }catch(_){}
        if(typeof toast === 'function'){
          toast('Lokale Lagerdaten wurden gelöscht. Bitte die Seite neu laden.');
        }else{
          alert('Lokale Lagerdaten wurden gelöscht. Bitte die Seite neu laden.');
        }
        // Nach erfolgreichem Löschen optional Reload anbieten
        try{
          if(confirm('Lokale Lagerdaten wurden gelöscht.\n\nSeite jetzt neu laden?')){
            window.location.reload();
          }
        }catch(_){}
      }catch(e){
        try{ console.error(e); }catch(_){}
        alert('Fehler beim Löschen der lokalen Daten: ' + e);
      }
    });

    // Data Export/Import (local)

    $('#btnDataExport') && $('#btnDataExport').addEventListener('click', function(){ if(!has('export_import')){ toast('Keine Berechtigung'); return } var data={version:12,exportedAt:new Date().toISOString(),items:items, groups:groups, members:members}; var blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'}); var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='lager-export.json'; a.click(); setTimeout(function(){ URL.revokeObjectURL(a.href) },1500) });
    $('#btnDataImport') && $('#btnDataImport').addEventListener('click', function(){ if(!has('export_import')){ toast('Keine Berechtigung'); return } $('#dataImportFile').click() });
    $('#dataImportFile') && $('#dataImportFile').addEventListener('change', function(e){ var f=e.target.files&&e.target.files[0]; if(!f) return; var r=new FileReader(); r.onload=function(){ try{ var j=JSON.parse(String(r.result||'')); if(!j.items||!Array.isArray(j.items)) throw new Error('Ungültiges Format'); if(!confirm('Bestehende lokale Daten werden ersetzt. Fortfahren?')) return; items=j.items.map(function(x){ return { id:x.id||uid(), name:x.name||'', sku:x.sku||'', qty:Math.max(0, Math.floor(Number(x.qty||0))), notes:x.notes||'', inDate:x.inDate||'', outDate:x.outDate||'', log:Array.isArray(x.log)?x.log:[], createdAt:x.createdAt||Date.now(), updatedAt:Date.now() , category: keepCategory(x.category)}
  }) ; if(j.groups) groups=j.groups; if(j.members) members=j.members; saveJson(storageKey, items); saveJson(groupsKey, groups); saveJson(membersKey, members); render(); refreshGroupUI(); refreshMembersUI(); maybeCloudPushAll(); toast('Import erfolgreich') }catch(err){ console.error(err); toast('Import fehlgeschlagen') } finally{ e.target.value='' } }; r.readAsText(f) });

    // Excel & Print
    $('#btnExcel') && $('#btnExcel').addEventListener('click', function(){
      if(!has('print_excel')){ toast('Keine Berechtigung'); return }
      try{
        var rows = items.map(function(x){
          return {
            'Artikelbezeichnung': (x.name||''),
            'Art.-Nr.': (x.sku||''),
            'Kategorie': (x.category||''),
            'Menge': Number(x.qty)||0,
            'Eingang': (x.inDate||''),
            'Ausgang': (x.outDate||''),
            'Notiz': (x.notes||''),
            'Zuletzt geändert': new Date(x.updatedAt||Date.now()).toLocaleString('de-DE')
          };
        });
        
        // Offline-Fallback: Wenn XLSX nicht geladen, sichere CSV
        if (typeof XLSX === 'undefined' || !XLSX.utils || !XLSX.writeFile) {
          try{
            var headers = Object.keys(rows[0] || {
              'Artikelbezeichnung':'','Art.-Nr.':'','Kategorie':'','Menge':0,'Eingang':'','Ausgang':'','Notiz':'','Zuletzt geändert':''
            });
            function csvEscape(v){
              if(v===undefined||v===null) v='';
              v = String(v);
              // Excel-robust: Ersetze CR/LF, maskiere Anführungszeichen, immer in Quotes setzen
              v = v.replace(/\r?\n/g,' ');
              v = '"' + v.replace(/"/g,'""') + '"';
              return v;
            }
            var pre = 'sep=;\r\n';
            var csv = pre + headers.join(';') + '\r\n' + rows.map(function(r){
              return headers.map(function(h){ return csvEscape(r[h]); }).join(';');
            }).join('\r\n');
            // UTF-16LE erzeugen (Excel-sicher)
            function toUTF16LE(str){
              var buf = new Uint8Array(2 + str.length*2); // BOM + 2 Bytes pro Codeunit
              buf[0] = 0xFF; buf[1] = 0xFE; // BOM
              for(var i=0, j=2; i<str.length; i++, j+=2){
                var code = str.charCodeAt(i);
                buf[j] = code & 0xFF;        // low byte
                buf[j+1] = code >> 8;        // high byte
              }
              return buf;
            }
            var u16 = toUTF16LE(csv);
            var blob = new Blob([u16], {type:'text/csv;charset=utf-16le'});

            var a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'lager.csv';
            a.click();
            setTimeout(function(){ URL.revokeObjectURL(a.href) }, 1500);
            toast('CSV-Export gespeichert (XLSX offline nicht verfügbar)');
            return;
          }catch(csvErr){
            console.error(csvErr);
            // Fällt durch in den XLSX-Pfad (der ohnehin fehlt) -> catch unten zeigt Toast
          }
        }
    var wb = XLSX.utils.book_new();
        var ws = XLSX.utils.json_to_sheet(rows);
        XLSX.utils.book_append_sheet(wb, ws, 'Lager');
        XLSX.writeFile(wb, 'lager.xlsx');
      }catch(e){
        console.error(e);
        toast('Excel-Export fehlgeschlagen');
      }
    });
    $('#btnPrint') && $('#btnPrint').addEventListener('click', function(){
      if(!has('print_excel')){ toast('Keine Berechtigung'); return }
      var html='<head>\1\2 – v20an\3<meta charset="utf-8"><style>body{font-family:system-ui,Segoe UI,Arial;margin:16px}table{border-collapse:collapse;width:100%}th,td{border:1px solid #ccc;padding:6px 8px}th{background:#f2f2f2;position:sticky;top:0}</style></head>'; html+='<h2>Lager – Übersicht</h2><table><thead><tr><th>Bezeichnung</th><th>Artikelnummer</th><th>Kategorie</th><th>Menge</th><th>Eingang</th><th>Ausgang</th><th>Notiz</th></tr></thead><tbody>'; items.forEach(function(x){ html+='<tr><td>'+escapeHtml(x.name||'')+'</td><td>'+escapeHtml(x.sku||'')+'</td><td>'+escapeHtml(x.category||'')+'</td><td>'+String(Number(x.qty)||0)+'</td><td>'+escapeHtml(x.inDate||'')+'</td><td>'+escapeHtml(x.outDate||'')+'</td><td>'+escapeHtml(x.notes||'')+'</td></tr>' });
    // Excel Import (XLSX) – optional
    $('#btnExcelImport') && $('#btnExcelImport').addEventListener('click', function(){
      if(!has('export_import')){ toast('Keine Berechtigung'); return }
      var inp = document.getElementById('excelImportFile'); if(inp) inp.click();
    });
    $('#excelImportFile') && $('#excelImportFile').addEventListener('change', function(e){
      try{
        if(!has('export_import')){ toast('Keine Berechtigung'); return }
        var f = e.target.files && e.target.files[0];
        if(!f){ return }
        var r = new FileReader();
        r.onload = function(ev){
          try{
            var data = new Uint8Array(ev.target.result);
            var wb = XLSX.read(data, {type:'array'});
            var name = (wb.SheetNames.indexOf('Lager')>=0) ? 'Lager' : wb.SheetNames[0];
            var ws = wb.Sheets[name];
            var arr = XLSX.utils.sheet_to_json(ws, {defval:''});
            var imported = arr.map(function(row){
              return {
                id: uid(),
                name: String(row['Artikelbezeichnung']||'').trim(),
                sku: String(row['Art.-Nr.']||'').trim(),
                qty: Number(row['Menge'])||0,
                inDate: row['Eingang']||'',
                outDate: row['Ausgang']||'',
                notes: String(row['Notiz']||''),
                log: [],
                createdAt: Date.now(),
                updatedAt: Date.now(),
                category: keepCategory(row['Kategorie'])
              };
            }).filter(function(x){ return x.name || x.sku; });
            if(imported && imported.length){
              writeItems(imported);
              renderOverview('');
              toast('Excel importiert');
            }else{
              toast('Keine importierbaren Zeilen gefunden');
            }
          }catch(err){
            console.error(err);
            toast('Excel-Import fehlgeschlagen');
    $('#btnPrint') && $('#btnPrint').addEventListener('click', function(){
      if(!has('print_excel')){ toast('Keine Berechtigung'); return }
      try{
        var rows = (Array.isArray(items)?items:[]).slice();
        var css = "" +
          "<style>body{font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Helvetica,Arial}">"+
          "table{border-collapse:collapse;width:100%}">"+
          "th,td{border:1px solid #ddd;padding:6px 8px;text-align:left}">"+
          "thead th{background:#f2f2f2;position:sticky;top:0}">"+
          "h2{margin:6px 0 10px 0}</style>";
        var html = "<!doctype html><html><head><meta charset='utf-8'><title>Lager – Übersicht</title>" + css + "</head><body>";
        html += "<h2>Lager – Übersicht</h2>";
        html += "<table><thead><tr>" +
                "<th>Artikelbezeichnung</th><th>Art.-Nr.</th><th>Kategorie</th><th>Menge</th><th>Eingang</th><th>Ausgang</th><th>Notiz</th>" +
                "</tr></thead><tbody>";
        rows.forEach(function(x){
          var r = [
            escapeHtml(x.name||''),
            escapeHtml(x.sku||''),
            escapeHtml(x.category||''),
            String(Number(x.qty)||0),
            escapeHtml(x.inDate||''),
            escapeHtml(x.outDate||''),
            escapeHtml(x.notes||'')
          ];
          html += "<tr><td>"+r[0]+"</td><td>"+r[1]+"</td><td>"+r[2]+"</td><td>"+r[3]+"</td><td>"+r[4]+"</td><td>"+r[5]+"</td><td>"+r[6]+"</td></tr>";
        });
        html += "</tbody></table></body></html>";
        var w = window.open('', 'printLager');
        if(w){ w.document.open(); w.document.write(html); w.document.close(); w.focus(); }
      }catch(e){
        console.error(e);
        toast('Druckansicht konnte nicht erzeugt werden');
      }
    });
    });
 html+='</tbody></table>'; var w=window.open('','_blank'); if(!w){ toast('Popup blockiert'); return } w.document.write(html); w.document.close(); w.focus(); w.print()
    });

    // Queue banner buttons
    $('#queueSendNow') && $('#queueSendNow').addEventListener('click', function(){ processOutbox() });
    $('#queueOpenSettings') && $('#queueOpenSettings').addEventListener('click', function(){ $('#settings').showModal(); document.querySelector('#secCloud').open = true; });

    // Cloud buttons
    $('#btnCloudConnect') && $('#btnCloudConnect').addEventListener('click', function(){ writeBrConfig(); updateManualPushVisibility(); cloudPullAll() });
    $('#btnPull') && $('#btnPull').addEventListener('click', function(){
      // zentraler Sync-Ablauf für „Alles aus Cloud laden“
      if (typeof runFullSync === 'function'){
        runFullSync({mode:'pull'});
      } else if (typeof cloudPullAll === 'function'){
        cloudPullAll();
      }
    });
    $('#autoSyncChk') && $('#autoSyncChk').addEventListener('change', function(){ writeBrConfig(); updateManualPushVisibility(); });
    $('#btnPush') && $('#btnPush').addEventListener('click', function(){
      // zentraler Sync-Ablauf für „Alle lokalen Daten hochladen“
      if (typeof runFullSync === 'function'){
        runFullSync({mode:'push'});
      } else if (typeof cloudPushAll === 'function'){
        cloudPushAll();
      }
    });
    $('#btnRetryOutbox') && $('#btnRetryOutbox').addEventListener('click', function(){ processOutbox() });

    // Backup UI
    $('#btnBackupCloud') && $('#btnBackupCloud').addEventListener('click', function(){ writeBrConfig(); var includeToken=$('#chkIncludeToken').checked; cloudBackupNow(includeToken) });
    $('#btnBackupsShow') && $('#btnBackupsShow').addEventListener('click', async function(){
      try{ writeBrConfig(); var rows=await cloudBackupsList(); renderBackups(rows); $('#backupsDlg').showModal() }
      catch(e){ toast('Backups konnten nicht geladen werden') }
    });
    $('#btnBackupsClose') && $('#btnBackupsClose').addEventListener('click', function(){ $('#backupsDlg').close() });
    $('#btnBackupsOk') && $('#btnBackupsOk').addEventListener('click', function(){ $('#backupsDlg').close() });
    $('#btnBackupsRefresh') && $('#btnBackupsRefresh').addEventListener('click', async function(){ try{ var rows=await cloudBackupsList(); renderBackups(rows) }catch(e){ toast('Aktualisierung fehlgeschlagen') } });

    // Overview & history search
    $('#overviewSearch') && $('#overviewSearch').addEventListener('input', (function(){
  // v41 – Mehrfachsuche stabil: eigene Filterfunktion + Observer (unabhängig von v29/v30)
  function $$(sel, root){ return Array.prototype.slice.call((root||document).querySelectorAll(sel)); }
  function parseTokens(s){
    s = String(s||'');
    var out=[], cur='', q=null;
    for (var i=0;i<s.length;i++){
      var ch=s[i];
      if (q){ if (ch===q){ q=null; cur+=ch; } else cur+=ch; }
      else { if (ch==='"'||ch==="'"){ q=ch; cur+=ch; } else if (ch===','){ if (cur.trim()) out.push(cur.trim()); cur=''; } else cur+=ch; }
    }
    if (cur.trim()) out.push(cur.trim());
    return out.slice(0,50);
  }
  var FIELD_ALIAS = {'sku':'sku','artikelnummer':'sku','artnr':'sku','name':'name','bezeichnung':'name','titel':'name','title':'name','cat':'cat','kategorie':'cat','category':'cat','loc':'loc','lagerort':'loc','ort':'loc','location':'loc','note':'note','notiz':'note','hinweis':'note','remarks':'note'};
  function unq(s){ s=String(s||'').trim(); if ((s.startsWith('"')&&s.endsWith('"'))||(s.startsWith("'")&&s.endsWith("'"))) return s.slice(1,-1); return s; }
  function parsePrefixed(list){
    return list.map(function(p){
      var m = p.match(/^([^:]+):\s*(.+)$/);
      if (m){ var f=(FIELD_ALIAS[String(m[1]||'').toLowerCase().trim()]||'').trim(); var v=unq(m[2]); if (f&&v) return {field:f, value:v}; }
      return {value:p};
    });
  }
  function headerMap(){
    var thead = document.querySelector('#overviewTable thead') || document.querySelector('#overview table thead');
    var map = {}; if (!thead) return map;
    var ths = $$('#overviewTable thead th') ; if(!ths.length) ths = $$('thead th', thead.parentNode || thead);
    for (var i=0;i<ths.length;i++){
      var t = String((ths[i].textContent||'').trim()).toLowerCase();
      if (t.includes('sku') || t.includes('artikel')) map.sku = i;
      else if (t.includes('name') || t.includes('bezeichnung')) map.name = (map.name==null?i:map.name);
      else if (t.includes('kategorie') || t.includes('category')) map.cat = i;
      else if (t.includes('ort') || t.includes('lager')) map.loc = i;
      else if (t.includes('notiz') || t.includes('hinweis')) map.note = i;
    }
    return map;
  }
  function getRows(){
    var tb = document.querySelector('#overviewTable tbody') || document.querySelector('#overview table tbody');
    if (tb) return $$('#overviewTable tbody tr').concat($$('#overview table tbody tr'));
    var root = document.getElementById('overview') || document.body;
    return $$('#tr,.card,.ov-card,li,article,.row', root);
  }
  function rowFields(row, map){
    var tds = $$('td,th', row);
    function cell(i){ return (i!=null && tds[i]) ? (tds[i].textContent||'') : ''; }
    var f = { sku:cell(map.sku), name:cell(map.name), cat:cell(map.cat), loc:cell(map.loc), note:cell(map.note), full:(row.textContent||'') };
    f.sku  = f.sku  || row.getAttribute('data-sku')  || '';
    f.name = f.name || row.getAttribute('data-name') || '';
    f.cat  = f.cat  || row.getAttribute('data-cat')  || row.getAttribute('data-category') || '';
    f.loc  = f.loc  || row.getAttribute('data-loc')  || row.getAttribute('data-location') || row.getAttribute('data-ort') || '';
    f.note = f.note || row.getAttribute('data-note') || row.getAttribute('data-notiz') || '';
    return f;
  }
  function applyTokens(tokens){
    var rows = getRows();
    var map = headerMap();
    var hasField = tokens.some(function(t){ return !!t.field; });
    rows.forEach(function(r){
      var show = true;
      if (tokens.length>1){
        show = false;
        var f = hasField ? rowFields(r, map) : null;
        for (var i=0;i<tokens.length;i++){
          var t = tokens[i]; var needle = String((t.value||t)||'').toLowerCase();
          if (!needle) continue;
          if (t.field){
            if (String((f||rowFields(r,map))[t.field]||'').toLowerCase().indexOf(needle)!==-1){ show = true; break; }
          } else {
            if (String(r.textContent||'').toLowerCase().indexOf(needle)!==-1){ show = true; break; }
          }
        }
      } else if (tokens.length===1){
        var t0 = tokens[0]; var needle0 = String((t0.value||t0)||'').toLowerCase();
        if (t0.field){
          var f0 = rowFields(r, map);
          show = String(f0[t0.field]||'').toLowerCase().indexOf(needle0)!==-1;
        } else {
          show = String(r.textContent||'').toLowerCase().indexOf(needle0)!==-1;
        }
      }
      r.hidden = !show;
    });
  }

  var mo = null, lastTokens = null;
  function reapplyWithObserver(tokens){
    if (mo){ try{ mo.disconnect(); }catch(_){} mo = null; }
    var root = document.querySelector('#overviewTable tbody') || document.querySelector('#overview') || document.body;
    lastTokens = tokens;
    setTimeout(function(){ try{ applyTokens(tokens); }catch(_){ } }, 0);
    if (window.MutationObserver){
      mo = new MutationObserver(function(){ if (!lastTokens) return; try{ applyTokens(lastTokens); }catch(_){ } });
      try{ mo.observe(root, {childList:true, subtree:true}); }catch(_){}
      setTimeout(function(){ if (mo){ try{ mo.disconnect(); }catch(_){ } mo=null; } }, 8000);
    }
  }

  return function(ev){
    try{
      var v = String(this.value||'');
      var raw = parseTokens(v);
      var tokens = parsePrefixed(raw);
      var isMulti = (tokens.length>1);
      if (!isMulti){
        renderOverview(v);
        lastTokens = null;
        if (mo){ try{ mo.disconnect(); }catch(_){ } mo=null; }
        return;
      }
      renderOverview('');
      reapplyWithObserver(tokens);
    }catch(_){}
  };
})());
var _oc=document.getElementById('overviewCat');
if(_oc){
  function readUIPrefs(){ try{ return JSON.parse(localStorage.getItem('lv_ui_prefs_v1')||'{}') }catch(_){ return {} } }
  function writeUIPrefs(p){ try{ localStorage.setItem('lv_ui_prefs_v1', JSON.stringify(p||{})) }catch(_){ } }
  _oc.addEventListener('change', function(){
    try{
      var p = readUIPrefs(); p.overviewCat = this.value; writeUIPrefs(p);
      renderOverview('')
    }catch(e){}
  });
  // Auswahl beim Start wiederherstellen
  (function(){
    try{
      var p = readUIPrefs(); var v = p.overviewCat;
      if(typeof v==='string' && v.length){
        // nur setzen, wenn Option existiert
        var ok=false; for(var i=0;i<_oc.options.length;i++){ if(_oc.options[i].value===v){ ok=true; break; } }
        if(ok){ _oc.value = v; }
      }
      renderOverview('')
    }catch(e){}
  })();
}

    $('#openHistory') && $('#openHistory').addEventListener('click', function(){ if(!has('view_history')){ toast('Keine Berechtigung'); return } openHistory(); });
    $('#btnHistoryOk') && $('#btnHistoryOk').addEventListener('click', function(){ $('#historyDlg').close() });
    $('#btnHistoryClose') && $('#btnHistoryClose').addEventListener('click', function(){ $('#historyDlg').close() });
    $('#btnHistoryExport') && $('#btnHistoryExport').addEventListener('click', function(){
  try{ if(!(typeof hasRight==='function' ? hasRight('export_history') : (window.currentPerms && currentPerms.export_history))){ if(typeof toast==='function') toast('Keine Berechtigung'); else alert('Keine Berechtigung'); return; } }catch(_){} var rows = aggregateHistory();
  var csv = 'Zeitpunkt;Benutzer;Aktion;Artikel;Delta;Info\n' + rows.map(function(r){
    var delta = Number(r.delta); if(!isFinite(delta)) delta = 0;
    var action;
    if (r.type === 'qty') {
      action = (delta > 0 ? 'Zugang' : (delta < 0 ? 'Entnahme' : 'Mengenänderung'));
    } else if (r.type === 'in') {
      action = 'Eingang';
    } else if (r.type === 'out') {
      action = 'Ausgang';
    } else {
      action = String(r.type||'');
    }
    var deltaStr = (delta > 0 ? '+'+delta : (delta < 0 ? String(delta) : '0'));
    var rowArr = [
      new Date(r.ts).toLocaleString('de-DE'),
      r.user,
      action,
      (r.itemName + ' · ' + r.sku),
      deltaStr,
      (r.reason || '')
    ];
    return rowArr.map(function(x){ return '"' + String(x).replace(/"/g,'""') + '"' }).join(';');
  }).join('\n');
  var blob=new Blob([csv],{type:'text/csv'});
  var a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download='lager-historie.csv';
  a.click();
  setTimeout(function(){ URL.revokeObjectURL(a.href) },1500);
});

    // Login dialog buttons
    $('#btnLoginClose') && $('#btnLoginClose').addEventListener('click', function(){ if(requireLoginNow()){ toast('Bitte anmelden, um fortzufahren.'); } else { $('#login').close() } });
    $('#btnLoginGo') && $('#btnLoginGo').addEventListener('click', async function(){
      var uname = $('#loginEmail').value.trim(); var pass = $('#loginPass').value; try{ await tryLogin(uname, pass); $('#login').close(); }catch(e){ $('#loginInfo').style.display='block'; $('#loginInfo').textContent = e.message || 'Login fehlgeschlagen'; try{ setTimeout(function(){ var pw=document.getElementById('loginPass'); if(pw){ pw.focus(); pw.select && pw.select(); } }, 0); }catch(_){ } }
    });
    $('#btnLoginAdminLocal') && $('#btnLoginAdminLocal').addEventListener('click', function(){ if(confirm('Nur zur Ersteinrichtung gedacht. Fortfahren?')){ setSession('Admin (lokal)'); $('#login').close(); toast('Als Admin (lokal) angemeldet') } });

    // Maybe push on changes (autosync)
    function maybeCloudPushAll(){ var cfg=readBrConfig(); if(cfg.autoSync){ cloudPushAll().catch(function(e){ /* bereits in Warteschlange erfasst */ }) } }
    async function maybeCloudPushGroups(){ var cfg=readBrConfig(); if(cfg.autoSync){ try{ await pushGroupsOnly() }catch(e){ queueTask('pushGroups') } } }
    async function maybeCloudPushMembers(){ var cfg=readBrConfig(); if(cfg.autoSync){ try{ await pushMembersOnly() }catch(e){ queueTask('pushMembers') } } }

    // Start
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function(){
    // --- Step3: Manual Sync & Auto-Sync toggle ---
    (function(){
      const CFG_KEY = 'lv_cfg_v1';
      function readCfg(){ try{ return JSON.parse(localStorage.getItem(CFG_KEY)||'{}') }catch(_){ return {} } }
      function writeCfg(c){ localStorage.setItem(CFG_KEY, JSON.stringify(c||{})) }
      function updateManualSyncVisibility(){
        var cfg = readCfg();
        var b = document.getElementById('btnManualSync');
        if(!b) return;
        b.style.display = (cfg.autoSync ? 'none' : '');
      }
      // Init checkbox with current value
      var chk = document.getElementById('cfgAutoSync');
      if(chk){
        var _cfg = readCfg();
        chk.checked = !!_cfg.autoSync;
        chk.addEventListener('change', function(){
          var c = readCfg(); c.autoSync = !!this.checked; writeCfg(c); updateManualSyncVisibility();
        });
      }
      // Manual sync click
      var ms = document.getElementById('btnManualSync');
      if(ms){
        ms.addEventListener('click', function(ev){
          try{
            if(requireLoginNow && requireLoginNow() && !localStorage.getItem(sessionKey)){
              ev.preventDefault(); ev.stopPropagation();
              var dlg = document.getElementById('login');
              try{ dlg.showModal() }catch(_){ dlg.open = true }
              return;
            }
          }catch(_){}
          // Placeholder sync: simulate processing and show toast / debug log
          dbg && dbg.log && dbg.log('Manuelle Synchronisation gestartet ...');
          setTimeout(function(){
            toast && toast('Synchronisierung abgeschlossen');
            dbg && dbg.log && dbg.log('Synchronisierung abgeschlossen');
          }, 600);
        });
      }
      // Ensure correct visibility on startup
      updateManualSyncVisibility();
    })();

    // --- Login-Gate (capture) für mutierende Aktionen ---
    (function(){
      function showLoginDialog(fromId){
        var dlg = document.getElementById('login');
        if(!dlg) return;
        try{ dlg.showModal(); }catch(_){ dlg.open = true; }
        try{
          setTimeout(function(){
            var email = document.getElementById('loginEmail');
            var pass  = document.getElementById('loginPass');
            if(email && (!email.value || !email.value.trim())){ email.focus(); email.select && email.select(); }
            else if(pass){ pass.focus(); pass.select && pass.select(); }
          }, 0);
        }catch(_){}
      }
      function gate(id){
        var el = document.getElementById(id);
        if(!el) return;
        el.addEventListener('click', function(ev){
          try{
            var hasSession = !!(localStorage.getItem(sessionKey) || sessionStorage.getItem(sessionKey));
            if(requireLoginNow && requireLoginNow() && !hasSession){
              ev.stopPropagation(); ev.preventDefault();
              try{
                if(id==='btnBookIn' || id==='btnBookOut' || id==='btnNew'){
                  toast && toast('Bitte anmelden, um zu buchen.');
                } else {
                  toast && toast('Bitte anmelden, um fortzufahren.');
                }
              }catch(_){}
              showLoginDialog(id);
              return;
            }
          }catch(_){}
        }, true); // capture, vor Original-Handlern
      }

      // Nur mutierende Aktionen sperren:
      gate('btnNew');      // Material anlegen
      gate('btnBookIn');   // Wareneingang buchen
      gate('btnBookOut');  // Warenausgang buchen
    })();
 try { init() } catch(e){ console.error(e) } });
    } else {
      try { init() } catch(e){ console.error(e) }
    }

  </script>

<script>
// v70 – UI-Status für Pending-Operationen und Outbox (nur Anzeige, keine Änderung an der Logik)
(function(){
  try{
    function getPendingCount(){
      try{
        // Immer über loadPending() gehen, damit die Aufräum-Logik greift
        var arr = loadPending();
        return Array.isArray(arr) ? arr.length : 0;
      }catch(_){ return 0; }
    }

    function getOutboxCount(){
      try{
        if(typeof loadOutbox === 'function'){
          var box = loadOutbox();
          return Array.isArray(box) ? box.length : 0;
        }
        var raw = localStorage.getItem('lagerverwaltung_outbox_v1');
        if(!raw) return 0;
        var arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr.length : 0;
      }catch(_){ return 0; }
    }

    function updateQueueStatus(){
      try{
        var pending = getPendingCount();
        var outbox  = getOutboxCount();
        var total   = pending + outbox;

        var banner      = document.getElementById('queueBanner');
        var bannerText  = document.getElementById('queueBannerText');
        var statusQueue = document.getElementById('statusQueue');
        var outboxInfo  = document.getElementById('outboxInfo');
        var btnRetry    = document.getElementById('btnRetryOutbox');

        var hasIssues = total > 0;

        if(statusQueue){
          if(hasIssues){
            statusQueue.style.display = '';
            var label = 'Sync ausstehend: ' + total;
            statusQueue.textContent = label;
            statusQueue.title = 'Davon ' + pending + ' lokal vorgemerkt, ' + outbox + ' in der Outbox.';
          }else{
            statusQueue.style.display = 'none';
            statusQueue.textContent = 'Sync ausstehend: 0';
            statusQueue.removeAttribute('title');
          }
        }

        if(banner){
          if(hasIssues){
            banner.style.display = 'flex';
            if(bannerText){
              var parts = [];
              if(pending>0) parts.push(pending + ' lokal vorgemerkt');
              if(outbox>0) parts.push(outbox + ' in Warteschlange');
              bannerText.textContent = parts.join(' · ') || 'Einträge warten auf Übertragung.';
            }
          }else{
            banner.style.display = 'none';
          }
        }

        if(outboxInfo){
          if(hasIssues){
            var msg = '';
            if(pending>0) msg += pending + ' Buchungen sind lokal vorgemerkt (noch nicht in die Outbox übertragen). ';
            if(outbox>0) msg += outbox + ' Vorgänge liegen in der Outbox und werden beim nächsten Senden übertragen.';
            outboxInfo.textContent = msg.trim();
          }else{
            outboxInfo.textContent = '';
          }
        }

        if(btnRetry){
          btnRetry.style.display = outbox>0 ? '' : 'none';
        }
      }catch(_){}
    }

    // Exponieren für spätere Erweiterungen/Debug
    window.lvQueueStatus = {
      update: updateQueueStatus,
      getPendingCount: getPendingCount,
      getOutboxCount: getOutboxCount
    };

    // Initial + periodisch aktualisieren, ohne andere Logik zu verändern
    document.addEventListener('DOMContentLoaded', function(){
      try{ updateQueueStatus(); }catch(_){}
      try{
        if(!window.__lvQueueStatusTimer){
          window.__lvQueueStatusTimer = setInterval(function(){
            try{ updateQueueStatus(); }catch(_){}
          }, 5000);
        }
      }catch(_){}
    });

  }catch(_){}
})();</script>


  <!-- [ADD] Category Support r1 -->
  <script>
  (function(){
    function $(sel){return document.querySelector(sel)}
    var CAT_ID = 'category';
    var CAT_OPTIONS = ['', 'Rauchmelder', 'Wärmezähler', 'Kaltwasserzähler', 'Warmwasserzähler', 'Heizkostenverteiler', 'Zusatzmaterial', 'Verbrauchsmaterial', 'Messtechnik Nord', 'Werkzeug'];
    function ensureCategoryField(){
      var notes = document.getElementById('notes');
      var form = document.getElementById('form');
      if(!form || !notes) return;
      if(document.getElementById(CAT_ID)) return;
      var grid = document.createElement('div');
      grid.className = 'grid';
      var html = '<label for="category">Kategorie (optional)</label>';
      html += '<select id="category" class="input">';
      html += '<option value="">— Keine Kategorie —</option>';
      for(var i=1;i<CAT_OPTIONS.length;i++) html += '<option>'+CAT_OPTIONS[i]+'</option>';
      html += '</select>';
      grid.innerHTML = html;
      var notesGrid = notes.closest('.grid') || notes.parentElement;
      try { form.insertBefore(grid, notesGrid); } catch(e) { form.appendChild(grid); }
    }
    function readItems(){ try{ return window.items ? JSON.parse(JSON.stringify(window.items)) : (window.loadJson? loadJson(window.storageKey, []): []) }catch(e){ return [] } }
    function writeItems(arr){ try{ if(window.saveJson && window.storageKey) saveJson(window.storageKey, arr); window.items = arr; }catch(e){} }
    function getSku(){ var el=document.getElementById('sku'); return el?String(el.value).trim():''; }
    function updateCategoryOnSave(){
      try{
        var catEl = document.getElementById(CAT_ID); if(!catEl) return;
        var arr = readItems();
        var idx = -1;
        var id = (typeof editId!=='undefined' && editId!=null) ? String(editId) : null;
        if(id){ idx = arr.findIndex(function(x){ return String(x.id||'')===id }) }
        if(idx<0){ var sku = getSku(); if(sku) idx = arr.findIndex(function(x){ return String(x.sku||'')===sku }) }
        if(idx>=0){
                    var _prevCat = (arr[idx].category||'');
          var _nextCat = (catEl.value||'');
          if(_prevCat !== _nextCat){
            try{ addLog(arr[idx], { ts: Date.now(), type: 'edit', delta: 0, reason: 'Kategorie: '+(_prevCat||'—')+' → '+(_nextCat||'—'), user: currentUserEmail }); }catch(e){}
          }
          arr[idx].category = catEl.value || '';
          arr[idx].updatedAt = Date.now();
          writeItems(arr);
          if(window.render) try{ window.render() }catch(_){}
        }
      }catch(e){ console.error('Kategorie-Speicherfehler', e) }
    }
    function applyCategoryOnOpen(){
      try{
        var catEl = document.getElementById(CAT_ID); if(!catEl) return;
        var arr = readItems();
        var it = null;
        var id = (typeof editId!=='undefined' && editId!=null) ? String(editId) : null;
        if(id){ it = arr.find(function(x){ return String(x.id||'')===id }) }
        if(!it){ var sku = getSku(); if(sku) it = arr.find(function(x){ return String(x.sku||'')===sku }) }
        catEl.value = (it && it.category) ? it.category : '';
      }catch(e){}
    }
    document.addEventListener('DOMContentLoaded', function(){
      ensureCategoryField();
      var btnSave = document.getElementById('btnSave');
      if(btnSave) btnSave.addEventListener('click', function(){ setTimeout(updateCategoryOnSave, 30) });
      var dlg = document.getElementById('modal');
      if(dlg) new MutationObserver(function(muts){
        muts.forEach(function(m){
          if(m.attributeName==='open' && dlg.open){
            ensureCategoryField();
            setTimeout(applyCategoryOnOpen, 30);
          }
        });
      }).observe(dlg,{attributes:true});
      var ovCat = document.getElementById('overviewCat');
      if(ovCat) ovCat.addEventListener('change', function(){
        if(window.renderOverview) window.renderOverview(document.getElementById('overviewSearch')?.value||'');
      });
      // Override renderOverview to show category + filter
      var esc = window.escapeHtml || function(s){ return String(s).replace(/[&<>"']/g, function(c){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c] }) };
      window.renderOverview = function(filter){
        var q=(filter||'').trim().toLowerCase();
        var wrap=document.querySelector('#overviewTable tbody'); if(!wrap) return; wrap.innerHTML='';
        var arr = readItems();
        var view = arr.slice();
        if(q) view=view.filter(function(x){ return String(x.name||'').toLowerCase().includes(q) || String(x.sku||'').toLowerCase().includes(q) || String(x.category||'').toLowerCase().includes(q) });
        var catSel = document.getElementById('overviewCat');
        if(catSel && catSel.value && catSel.value!=='__ALL__'){
          var want=catSel.value;
          view = view.filter(function(x){ var c=x.category||''; return want==='__NONE__' ? !c : c===want; });
        }
        view.sort(function(a,b){ var n=String(a.name||'').localeCompare(String(b.name||'')); if(n) return n; return String(a.sku||'').localeCompare(String(b.sku||'')) });
        view.forEach(function(it){
          var tr=document.createElement('tr');
          tr.innerHTML = '<td>'+esc(it.name||'')+'</td>'
                        + '<td>'+esc(it.sku||'')+'</td>'
                        + '<td>'+esc(it.category||'')+'</td>'
                        + '<td style="text-align:right">'+(Number(it.qty)||0)+'</td>';
          tr.tabIndex=0;
          tr.addEventListener('click', function(){ if(window.openEdit) try{ openEdit(it.id) }catch(_){}});
          tr.addEventListener('keydown', function(e){ if((e.key==='Enter'||e.key===' ') && window.openEdit){ e.preventDefault(); try{ openEdit(it.id) }catch(_ ){} } });
          wrap.appendChild(tr);
        });
        var c=document.getElementById('overviewCount'); if(c) c.textContent = view.length+' Einträge';
      };
    });
  })();</script>

<script>
// v06: Stabilisierung (additive Wrapper) – KEINE bestehenden Blöcke ersetzt
(function(){
  try{
    // --- Login: Wrapper, der den Benutzernamen verwendet ---
    if (typeof window.tryLogin === 'function' && !window.tryLoginLegacy){
      window.tryLoginLegacy = window.tryLogin;
    }
    window.tryLogin = function(loginId, password){
      var loginStr = String(loginId||'').trim().toLowerCase();
      // Members lesen; Legacy-Funktion nutzt dieselben globalen Quellen
      var m = (Array.isArray(window.members) ? window.members : []).find(function(x){
        return (String(x.username||'').toLowerCase()) === loginStr;
      });
      if(!m){ throw new Error('Unbekannter Benutzer'); }
      if(!(m.pw_salt && m.pw_hash)){ throw new Error('Kein Passwort gesetzt. Admin muss es setzen.'); }
      // PBKDF2 wie gehabt (200k)
      return window.pbkdf2Hash(String(password||''), m.pw_salt, 200000).then(function(hash){
        if(hash !== m.pw_hash){ throw new Error('Passwort falsch'); }
        if (typeof window.setSession === 'function'){
          window.setSession(m.username);
        }
        if (typeof window.toast === 'function'){
          window.toast('Angemeldet: ' + (m.username || '—'));
        }
        return true;
      });
    };

function rowToMember(r){
  return {
    username: (r.username||'').trim(),
    group_id: r.group_id || r.groupId || '',
    perm: safeJson(r.perms, {}),
    pw_salt: r.pw_salt || null,
    pw_hash: r.pw_hash || null
  };
}

    // --- Kategorien: Additiv, kein Ersetzen vorhandener Funktionen/DOM-Elemente ---
    const CAT_OPTIONS = ["Neuware", "Zusatzmaterial", "Verbrauchsmaterial", "Messtechnik Nord", "Werkzeug", "Wärmezähler", "Kaltwasserzähler", "Warmwasserzähler", "Heizkostenverteiler", "Rauchmelder"];
const CAT_SYNONYMS = {"neuware": "Neuware", "neu ware": "Neuware", "zusatzmaterial": "Zusatzmaterial", "zusatz-material": "Zusatzmaterial", "verbrauchsmaterial": "Verbrauchsmaterial", "verbrauchs-material": "Verbrauchsmaterial", "messtechnik nord": "Messtechnik Nord", "messtechnik-nord": "Messtechnik Nord", "werkzeug": "Werkzeug", "wmz": "Wärmezähler", "wärmezähler": "Wärmezähler", "waermezaehler": "Wärmezähler", "wärmemengenzähler": "Wärmezähler", "waermemengenzaehler": "Wärmezähler", "kwz": "Kaltwasserzähler", "kaltwasserzähler": "Kaltwasserzähler", "kaltwasserzaehler": "Kaltwasserzähler", "wwz": "Warmwasserzähler", "warmwasserzähler": "Warmwasserzähler", "warmwasserzaehler": "Warmwasserzähler", "hkv": "Heizkostenverteiler", "heizkostenverteiler": "Heizkostenverteiler", "rwm": "Rauchmelder", "rauchwarnmelder": "Rauchmelder", "rauchmelder": "Rauchmelder"};
function normalizeCategoryV06(cat){
  const raw = String(cat ?? '').trim();
  if(!raw) return '';
  const key = raw.toLowerCase();
  if (CAT_SYNONYMS[key]) return CAT_SYNONYMS[key];
  // exact match (case-insensitive) in UI options
  for (var i=0; i<CAT_OPTIONS.length; i++){ if (CAT_OPTIONS[i].toLowerCase() === key) return CAT_OPTIONS[i]; }
  // If unknown, keep original (do not null it)
  return raw;
}

    // Original bewahren, aber globalen Entry-Point sanft überschreiben
    if (typeof window.normalizeCategory === 'function' && !window.normalizeCategoryLegacy){
      window.normalizeCategoryLegacy = window.normalizeCategory;
    }
    window.normalizeCategory = function(cat){
      try { return normalizeCategoryV06(cat); }
      catch(e){ try{ return window.normalizeCategoryLegacy ? window.normalizeCategoryLegacy(cat) : String(cat||'').trim(); } catch(_) { return String(cat||'').trim(); } }
    };

    // Filter-Select nur ergänzen – Element selbst nicht ersetzen (Listener bleiben!)
    function ensureCategoryFilterOptions(){
      var el = document.getElementById('overviewCat');
      if(!el) return;
      var existing = new Set(Array.prototype.map.call(el.options, function(o){ return o.value; }));
      // "Alle" sicherstellen
      var hasAll = false;
      for (var i=0;i<el.options.length;i++){ if (el.options[i].value === '') { hasAll=true; break; } }
      if(!hasAll){
        var optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = 'Alle';
        el.insertBefore(optAll, el.firstChild);
      }
      // Kanonische Optionen ergänzen
      CAT_OPTIONS.forEach(function(c){
        if(!existing.has(c)){
          var opt = document.createElement('option');
          opt.value = c; opt.textContent = c;
          el.appendChild(opt);
        }
      });
      // Bestehende Auswahl respektieren (nichts umstellen)
    }

    function run(){ try{ ensureCategoryFilterOptions(); }catch(e){} }
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(run, 0); });
    } else {
      setTimeout(run, 0);
    }
  }catch(e){
    console.error('v06 additive wrapper failed:', e);
  }
})();</script>

<script>/* Guard-Module: Export/Import – konsolidiert bis v19 (nur Doku; keine Verhaltensänderung) */

// v07: Export/Import Guards (Teil 1) – History-Export robust & Excel-CSV-sicher
(function(){
  'use strict';
  try{
    function toUTF16LEWithBOM(str){
      // Prepend BOM for Excel; then encode UTF-16LE
      var buf = new Uint8Array(2 + str.length * 2);
      // BOM 0xFFFE (little endian FF FE in LE stream)
      buf[0] = 0xFF; buf[1] = 0xFE;
      for (var i=0; i<str.length; i++){
        var code = str.charCodeAt(i);
        buf[2 + i*2] = code & 0xFF;
        buf[2 + i*2 + 1] = (code >> 8) & 0xFF;
      }
      return buf;
    }
    function csvEscape(x){ return '"' + String(x).replace(/"/g,'""') + '"' }

    function exportHistoryCSV(){
try{ if(!(typeof hasRight==='function' ? hasRight('export_history') : (window.currentPerms && currentPerms.export_history))){ if(typeof toast==='function') toast('Keine Berechtigung'); else alert('Keine Berechtigung'); return; } }catch(_){} try{
    var rows = [];
    try { rows = (typeof aggregateHistory==='function') ? aggregateHistory() : []; } catch(_){}
    var header = ['Zeitpunkt','Benutzer','Aktion','Artikel','Delta','Info'];
    var body = rows.map(function(r){
      var delta = Number(r && r.delta); if(!isFinite(delta)) delta = 0;
      var action;
      if (r && r.type === 'qty') {
        action = (delta > 0 ? 'Zugang' : (delta < 0 ? 'Entnahme' : 'Mengenänderung'));
      } else if (r && r.type === 'in') {
        action = 'Eingang';
      } else if (r && r.type === 'out') {
        action = 'Ausgang';
      } else {
        action = String(r && r.type || '');
      }
      var deltaStr = (delta > 0 ? ('+'+delta) : (delta < 0 ? String(delta) : '0'));
      var itemName = (r && r.itemName) ? r.itemName : '';
      var sku = (r && r.sku) ? r.sku : '';
      var info = (r && r.reason) ? r.reason : '';
      return [
        (r && r.ts ? new Date(r.ts).toLocaleString('de-DE') : ''),
        (r && r.user) || '',
        action,
        (itemName + (sku ? ' · ' + sku : '')),
        deltaStr,
        info
      ];
    });
    if (!(window.lvUtil && typeof lvUtil.downloadCsv === 'function')){
      try{ (typeof toast==='function') && toast('Export nicht verfügbar (lvUtil.downloadCsv fehlt)'); }catch(_){}
      return;
    }
    lvUtil.downloadCsv('lager-historie.csv', header, body);
    (typeof toast==='function') && toast('Historie exportiert');
  }catch(e){
    console.error('exportHistoryCSV failed', e);
    (typeof toast==='function') && toast('Export fehlgeschlagen');
  }
}

    // Install a capturing listener to replace fragile default export with robust one
    function installHistoryExportGuard(){
      var btn = document.getElementById('btnHistoryExport');
      if(!btn) return;
      // Rechte: Nur Gruppen mit export_history sehen den CSV-Export-Button
      try{
        if (typeof has === 'function' && !has('export_history')){
          btn.style.display = 'none';
          return;
        }
      }catch(_){ /* im Zweifel sichtbar lassen */ }
      // Avoid multiple installs
      if(btn.__v07_guard_installed) return;
      btn.__v07_guard_installed = true;
      btn.addEventListener('click', function(ev){
        try{
          // Prevent original fragile handler to avoid double download
          if(ev && ev.stopImmediatePropagation) ev.stopImmediatePropagation();
          if(ev && ev.preventDefault) ev.preventDefault();
        }catch(_){}
        try{
          exportHistoryCSV();
          (typeof toast==='function') && toast('Historie exportiert');
        }catch(e){
          console.error('History export failed', e);
          (typeof toast==='function') && toast('Export fehlgeschlagen');
        }
      }, true); // capture to run before any bubble handlers
    }

    function run(){
      try{ installHistoryExportGuard(); }catch(_){}
    }
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(run, 0); });
    } else { setTimeout(run, 0); }

  }catch(e){
    console.error('v07 guards failed:', e);
  }
})();</script>

<script>
// v08: Import/Inventar-Export Guards (deaktiviert in Supabase-Version)
// Excel-Import/-Export über XLSX ist vorübergehend abgeschaltet.
</script>

<script>
/**
 * v09 Documentation Stub (no runtime effects)
 * - Provides a small metadata object for debugging/version display.
 * - Does NOT register listeners, does NOT override any function.
 */
(function(){
  try{
    window.lvMeta = window.lvMeta || {};
    window.lvMeta.version = 'v09';
    window.lvMeta.notes = [
      'Codehygiene: Kommentare & LF-Zeilenenden vereinheitlicht',
      'Keine Funktionsänderung, keine Ersetzungen'
    ];
    // Intentionally no further code.
  }catch(e){ /* no-op */ }
})();</script>

<script>
/**
 * v10 – Mini-Härtung & Inline-Dokumentation
 * Hinweis: Diese Datei ändert keine Logik. Sie dokumentiert nur die additiven Wrapper
 * (v06 Login, v05 Kategorien, v07/v08 Guards) und legt ein schlankes Meta-Objekt an.
 */

/**
 * @typedef {Object} LvMeta
 * @property {string} version  - Build/Versions-Tag (z. B. 'v10')
 * @property {Object} modules  - Erkennungsstatus vorhandener Wrapper/Guards
 * @property {boolean} modules.loginWrapper
 * @property {boolean} modules.categoryWrapper
 * @property {boolean} modules.historyExportGuard
 * @property {boolean} modules.overviewExportGuard
 * @property {boolean} modules.importGuards
 */

(function(){
  try{
    // Kein Logging; rein passiv.
    var has = function(x){ return typeof x !== 'undefined'; };
    var mods = {
      loginWrapper:        (typeof window.tryLoginLegacy === 'function' && typeof window.tryLogin === 'function'),
      categoryWrapper:     (typeof window.normalizeCategory === 'function'), // V06 überschreibt behutsam
      historyExportGuard:  !!document.getElementById('btnHistoryExport'),
      overviewExportGuard: (!!document.getElementById('btnOverviewExport') || !!document.getElementById('btnDataExport')),
      importGuards:        (!!document.getElementById('excelImportFile') || !!document.getElementById('dataImportFile'))
    };

    window.lvMeta = window.lvMeta || {};
    window.lvMeta.version = 'v10';
    window.lvMeta.modules = mods;

    // Mini-Härtung (ohne Verhaltensänderung):
    // - Freeze nur die Meta-Struktur, nicht App-APIs.
    if (typeof Object.freeze === 'function'){
      try { Object.freeze(window.lvMeta.modules); } catch(_){}
    }
  }catch(e){ /* bewusst still */ }
})();</script>

<script>
/**
 * v11 – Utils-Bundle (NO behavior change)
 * Bundles shared helpers under window.lvUtil to avoid duplication.
 * Does NOT override existing app functions or event listeners.
 */
(function(){
  try{
    var U = (window.lvUtil = window.lvUtil || {});
    // --- CSV/BOM helpers ---
    if (!U.toUTF16LEWithBOM){
      U.toUTF16LEWithBOM = function(str){
        var s = String(str==null?'':str);
        var buf = new Uint8Array(2 + s.length * 2);
        buf[0] = 0xFF; buf[1] = 0xFE;
        for (var i=0; i<s.length; i++){
          var code = s.charCodeAt(i);
          buf[2 + i*2] = code & 0xFF;
          buf[2 + i*2 + 1] = (code >> 8) & 0xFF;
        }
        return buf;
      };
    }
    if (!U.csvQuote){
      U.csvQuote = function(x){ return '"' + String(x==null?'':x).replace(/"/g,'""') + '"' };
    }
    if (!U.downloadCsv){
      U.downloadCsv = function(filename, header, rows){
        try{
          var head = Array.isArray(header) ? header : [];
          var body = Array.isArray(rows) ? rows : [];
          var csv = 'sep=;\\n' + head.join(';') + '\\n' + body.map(function(r){
            return (Array.isArray(r)?r:[]).map(U.csvQuote).join(';');
          }).join('\\n');
          var u16 = U.toUTF16LEWithBOM(csv);
          var blob = new Blob([u16], {type:'text/csv;charset=UTF-16LE;'});
          var a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = String(filename||'export.csv');
          a.click();
          setTimeout(function(){ try{ URL.revokeObjectURL(a.href) }catch(_){ } }, 1500);
        }catch(e){ /* no-op: util only */ }
      };
    }

    // --- Categories canonical options & synonyms (no overrides) ---
    if (!U.CAT_OPTIONS){
      U.CAT_OPTIONS = ["Neuware","Zusatzmaterial","Verbrauchsmaterial","Messtechnik Nord","Werkzeug","WMZ","KWZ","WWZ","HKV","RWM"];
    }
    if (!U.CAT_SYNONYMS){
      U.CAT_SYNONYMS = {
        "neuware":"Neuware","neu ware":"Neuware",
        "zusatzmaterial":"Zusatzmaterial","zusatz-material":"Zusatzmaterial",
        "verbrauchsmaterial":"Verbrauchsmaterial","verbrauchs-material":"Verbrauchsmaterial",
        "messtechnik nord":"Messtechnik Nord","messtechnik-nord":"Messtechnik Nord",
        "werkzeug":"Werkzeug",
        "wmz":"WMZ","wärmemengenzähler":"WMZ","waermemengenzaehler":"WMZ",
        "kwz":"KWZ","kaltwasserzähler":"KWZ","kaltwasserzaehler":"KWZ",
        "wwz":"WWZ","warmwasserzähler":"WWZ","warmwasserzaehler":"WWZ",
        "hkv":"HKV","heizkostenverteiler":"HKV",
        "rwm":"RWM","rauchwarnmelder":"RWM"
      };
    }
    if (!U.normalizeCategory){
      U.normalizeCategory = function(cat){
        var raw = String(cat ?? '').trim();
        if(!raw) return '';
        var key = raw.toLowerCase();
        if (U.CAT_SYNONYMS[key]) return U.CAT_SYNONYMS[key];
        for (var i=0;i<U.CAT_OPTIONS.length;i++){
          if (U.CAT_OPTIONS[i].toLowerCase() === key) return U.CAT_OPTIONS[i];
        }
        return raw;
      };
    }

    // Note: We deliberately do NOT set window.normalizeCategory here to avoid ANY behavior change in v11.
  }catch(e){ /* deliberately silent */ }
})();</script>
<script>
// v11 meta bump (non-functional)
(function(){
  try{
    window.lvMeta = window.lvMeta || {};
    window.lvMeta.version = 'v11';
    window.lvMeta.modules = window.lvMeta.modules || {};
    window.lvMeta.modules.utils = true;
  }catch(e){}
})();</script>

<script>(function(){ try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v12'; }catch(e){} })();</script>
<script>(function(){ try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v13'; }catch(e){} })();</script><script>(function(){ try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v14'; }catch(e){} })();</script><script>(function(){ try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v15'; }catch(e){} })();</script>
<script>
/**
 * v16 – lvUtil Singleton & SelfTest
 * - Keine Verhaltensänderung. Schützt lvUtil gegen versehentliche Redefinition.
 * - Stellt einen sehr kleinen Self-Test bereit (ohne UI/Netz/Downloads).
 */
(function(){
  try{
    // --- Singleton-Garde ---
    if (window.lvUtil && !Object.prototype.hasOwnProperty.call(window.lvUtil, '__id')) {
      try{
        Object.defineProperty(window.lvUtil, '__id', {
          value: 'lvUtil@singleton',
          enumerable: false,
          writable: false,
          configurable: false
        });
      }catch(_){}
    }
    // Versuch: Sealen ohne harte Fehler (kein Freeze, um Erweiterungen der Methoden zu vermeiden)
    if (window.lvUtil && typeof Object.seal === 'function') {
      try{ Object.seal(window.lvUtil); }catch(_){}
    }

    // --- Lightweight Self-Test (liefert nur Statusobjekt) ---
    window.lvMeta = window.lvMeta || {};
    window.lvMeta.selfTest = function(){
      try{
        return {
          version: String(window.lvMeta && window.lvMeta.version || ''),
          hasUtil: !!window.lvUtil,
          isSealed: !!(window.lvUtil && Object.isSealed && Object.isSealed(window.lvUtil)),
          hasDownloadCsv: !!(window.lvUtil && typeof window.lvUtil.downloadCsv === 'function')
        };
      }catch(e){
        return { error: true };
      }
    };

    // Version fortschreiben
    try{ window.lvMeta.version = 'v16'; }catch(_){}
  }catch(e){ /* bewusst still */ }
})();</script>
<script>(function(){ try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v17'; }catch(e){} })();</script>
<script>
/**
 * v18 – Doku (Button-IDs), keine Logikänderung
 * Erfasst zur Diagnose die Präsenz wichtiger Export/Import-Buttons im DOM.
 * Schreibt die Information nach window.lvMeta.docs.buttonIds (ohne UI).
 */
(function(){
  try{
    var ids = ['btnExcel','btnExcelImport','btnDataExport','btnOverviewExport','btnHistoryExport','excelImportFile','dataImportFile'];
    var map = {};
    ids.forEach(function(id){ map[id] = !!document.getElementById(id); });
    window.lvMeta = window.lvMeta || {};
    window.lvMeta.docs = window.lvMeta.docs || {};
    window.lvMeta.docs.xlsxPresent = (typeof XLSX !== 'undefined');
    // Version anheben
    window.lvMeta.version = 'v18';
  }catch(e){ /* silent */ }
})();</script>
<script>(function(){ try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v19'; }catch(e){} })();</script>
<style id="lv-badge-style">
.lv-badge{display:inline-flex;align-items:center;gap:.35rem;font-size:.78rem;line-height:1;border-radius:999px;padding:.2rem .5rem;font-weight:600;vertical-align:middle}
.lv-badge--ok{background:#e6f7ee;color:#0d6b3a;border:1px solid #9adbb6}
.lv-badge--warn{background:#fff4e6;color:#8a4b00;border:1px solid #f3c795}
.lv-badge__dot{width:.5rem;height:.5rem;border-radius:50%;display:inline-block}
.lv-dot--ok{background:#27ae60}
.lv-dot--warn{background:#f39c12}
</style>
<script>
// v20 – XLSX-Status-Badge (UI-only)
(function(){
  try{
    if (window.__lvBadgeInstalled) return; // guard against duplicates
    window.__lvBadgeInstalled = true;

    function makeBadge(){
      var hasXlsx = (typeof XLSX !== 'undefined');
      var span = document.createElement('span');
      span.className = 'lv-badge ' + (hasXlsx ? 'lv-badge--ok' : 'lv-badge--warn');
      span.setAttribute('data-lv-badge','xlsx');
      span.title = hasXlsx ? 'Excel-Bibliothek erkannt' : 'Excel-Bibliothek fehlt – CSV-Fallback';
      var dot = document.createElement('i');
      dot.className = 'lv-badge__dot ' + (hasXlsx ? 'lv-dot--ok' : 'lv-dot--warn');
      var text = document.createElement('span');
      text.textContent = hasXlsx ? 'XLSX geladen' : 'CSV‑Fallback aktiv';
      span.appendChild(dot);
      span.appendChild(text);
      return span;
    }

    function placeNearHeader(){
      var badge = makeBadge();
      // 1) Bevorzugt: Summary/Überschrift mit Text "Druck & Excel"
      var candidates = Array.from(document.querySelectorAll('summary, h1, h2, h3, h4, button, .section-title'));
      var header = candidates.find(function(el){
        var t = (el.textContent||'').toLowerCase();
        return t.includes('druck') && t.includes('excel');
      });
      if (header){
        // nicht doppelt
        if(!header.querySelector('[data-lv-badge="xlsx"]')){
          header.appendChild(document.createTextNode(' '));
          header.appendChild(badge);
        }
        return true;
      }
      return false;
    }

    function placeNearExcelButton(){
      var badge = makeBadge();
      // typische IDs/Buttons
      var btn = document.getElementById('btnExcel') ||
                Array.from(document.querySelectorAll('button,a,input[type=button]')).find(function(b){
                  var t = (b.textContent||b.value||'').toLowerCase();
                  return t.includes('excel') && (t.includes('xlsx') || t.includes('herunterladen') || t.includes('download'));
                });
      if (btn){
        if(!btn.parentElement.querySelector('[data-lv-badge="xlsx"]')){
          var wrap = btn.parentElement || btn;
          wrap.appendChild(document.createTextNode(' '));
          wrap.appendChild(badge);
        }
        return true;
      }
      return false;
    }

    function install(){
      if (!placeNearHeader()){
        placeNearExcelButton();
      }
      // Doku aktualisieren (sichtlos)
      try{
        window.lvMeta = window.lvMeta || {};
        window.lvMeta.docs = window.lvMeta.docs || {};
        window.lvMeta.docs.xlsxPresent = (typeof XLSX !== 'undefined');
        window.lvMeta.version = 'v20';
      }catch(_){}
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(install, 0); });
    } else {
      setTimeout(install, 0);
    }
  }catch(e){ /* UI-only; silent */ }
})();</script>

<script>
// v21 – Live-Update für XLSX-Badge (UI-only)
(function(){
  try{
    if (window.__lvBadgeLiveInstalled) return;
    window.__lvBadgeLiveInstalled = true;

    function applyBadgeState(hasXlsx){
      var badge = document.querySelector('[data-lv-badge="xlsx"]');
      if(!badge){
        // Falls noch nicht vorhanden (z. B. Race), neu erzeugen wie v20
        var span = document.createElement('span');
        span.className = 'lv-badge';
        span.setAttribute('data-lv-badge','xlsx');
        var dot = document.createElement('i'); dot.className = 'lv-badge__dot';
        var text = document.createElement('span'); text.textContent = '';
        span.appendChild(dot); span.appendChild(text);
        // Versuche, in die Nähe eines Excel-Buttons zu hängen:
        var btn = document.getElementById('btnExcel') || document.querySelector('summary, h2, h3, h4, button');
        (btn && btn.parentElement ? btn.parentElement : document.body).appendChild(span);
        badge = span;
      }
      var dot = badge.querySelector('.lv-badge__dot');
      var text = badge.querySelector('span:last-child');
      // Reset Klassen
      badge.classList.remove('lv-badge--ok','lv-badge--warn');
      dot && dot.classList.remove('lv-dot--ok','lv-dot--warn');

      if(hasXlsx){
        badge.classList.add('lv-badge--ok');
        dot && dot.classList.add('lv-dot--ok');
        badge.title = 'Excel-Bibliothek erkannt';
        if(text) text.textContent = 'XLSX geladen';
      }else{
        badge.classList.add('lv-badge--warn');
        dot && dot.classList.add('lv-dot--warn');
        badge.title = 'Excel-Bibliothek fehlt – CSV-Fallback';
        if(text) text.textContent = 'CSV‑Fallback aktiv';
      }

      // Doku/Meta aktualisieren
      try{
        window.lvMeta = window.lvMeta || {};
        window.lvMeta.docs = window.lvMeta.docs || {};
        window.lvMeta.docs.xlsxPresent = !!hasXlsx;
        window.lvMeta.version = 'v21';
      }catch(_){}
    }

    function startWatcher(){
      var last = (typeof XLSX !== 'undefined');
      applyBadgeState(last);
      // Poll leichtgewichtig (1s), endet automatisch sobald XLSX einmal vorhanden ist
      window.__lvBadgeTimer = setInterval(function(){
        var cur = (typeof XLSX !== 'undefined');
        if(cur !== last){
          last = cur;
          applyBadgeState(cur);
        }
        if(cur && window.__lvBadgeTimer){
          clearInterval(window.__lvBadgeTimer);
          window.__lvBadgeTimer = null;
        }
      }, 1000);
      // Sicherheitsstop nach 2 Minuten
      setTimeout(function(){
        if(window.__lvBadgeTimer){ clearInterval(window.__lvBadgeTimer); window.__lvBadgeTimer = null; }
      }, 120000);
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(startWatcher, 0); });
    } else {
      setTimeout(startWatcher, 0);
    }
  }catch(e){ /* silent */ }
})();</script>

<script>
// v22 – Sanfte Vereinheitlichung der Kategorie-Optionen (additiv)
(function(){
  try{
    if (window.__v22CatsInstalled) return;
    window.__v22CatsInstalled = true;

    function getCatOptions(){
      // Bevorzugt zentrale Quelle
      if (window.lvUtil && Array.isArray(lvUtil.CAT_OPTIONS)) return lvUtil.CAT_OPTIONS.slice();
      // Fallback – identisch zu lvUtil
      return ["Neuware","Zusatzmaterial","Verbrauchsmaterial","Messtechnik Nord","Werkzeug","WMZ","KWZ","WWZ","HKV","RWM"];
    }

    function ensureOptions(selectEl, isFilter){
      // v13: lokaler Dedupe-Key-Helper (wirkt nur für isFilter && Unified-Flag)
      function lvV13_key(s){
        var base = String(s||'').toLowerCase().trim();
        if (isFilter && window.lvV11 && window.lvV11.status && window.lvV11.status().unifiedOn){
          try{ base = String(window.lvV11.normalize(s, 'v26') || s).toLowerCase().trim(); }catch(_){}
        }
        return base;
      }
    
      if(!selectEl || selectEl.__v22_done) return;
      var keepValue = selectEl.value;
      var existing = new Set(Array.prototype.map.call(selectEl.options||[], function(o){
        return lvV13_key((o.value || o.text || ''));
      }));
      // Für Filter: "Alle" an den Anfang stellen, wenn nicht vorhanden
      if (isFilter){
        var hasAll = false;
        for (var i=0;i<selectEl.options.length;i++){
          if (String(selectEl.options[i].value) === '') { hasAll = true; break; }
        }
        if(!hasAll){
          var optAll = document.createElement('option');
          optAll.value = '';
          optAll.textContent = 'Alle';
          selectEl.insertBefore(optAll, selectEl.firstChild);
        }
      }
      // Kanonische Optionen nur ERGÄNZEN, nichts entfernen/ersetzen
      var cats = getCatOptions();
      cats.forEach(function(c){
        var key = String(c).toLowerCase();
        if(!existing.has(key)){
          var opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          selectEl.appendChild(opt);
        }
      });
      // Auswahl unverändert lassen
      try{
        if (keepValue != null && keepValue !== '') {
          selectEl.value = keepValue;
        } else if (isFilter && (selectEl.selectedIndex < 0)) {
          selectEl.selectedIndex = 0; // "Alle"
        }
      }catch(_){}
      selectEl.__v22_done = true;
    }

    function runOnce(){
      // Übersicht-Filter
      var of = document.getElementById('overviewCat');
      if (of) ensureOptions(of, true);
      // Editor-Kategorie (ID 'category' laut Vorlage)
      var ec = document.getElementById('category');
      if (ec) ensureOptions(ec, false);
      // Doku
      try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v22'; }catch(_){}
    }

    // Editor kann später in den DOM kommen → MutationObserver
    var mo;
    function startObserver(){
      try{
        if (window.MutationObserver){
          mo = new MutationObserver(function(muts){
            muts.forEach(function(m){
              if (!m.addedNodes || !m.addedNodes.length) return;
              for (var i=0;i<m.addedNodes.length;i++){
                var n = m.addedNodes[i];
                if (!n.querySelector) continue;
                var cat = n.querySelector('#category');
                if (cat) ensureOptions(cat, false);
                var of = n.querySelector('#overviewCat');
                if (of) ensureOptions(of, true);
              }
            });
          });
          mo.observe(document.documentElement || document.body, {childList:true, subtree:true});
          // Sicherheitsstop nach 2 Minuten
          setTimeout(function(){ try{ mo.disconnect(); }catch(_){ } }, 120000);
        }
      }catch(_){}
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(function(){ runOnce(); startObserver(); }, 0); });
    } else {
      setTimeout(function(){ runOnce(); startObserver(); }, 0);
    }
  }catch(e){ /* silent */ }
})();</script>

<script>
// v23 – Kategorie-UI korrigiert (Abkürzungen aus Auswahl entfernt; nur echte Kategorien anzeigen)
(function(){
  try{
    if (window.__v23CatsInstalled) return;
    window.__v23CatsInstalled = true;

    var UI_CATS = ["Neuware","Zusatzmaterial","Verbrauchsmaterial","Messtechnik Nord","Werkzeug"];
    var SHORTS  = ["WMZ","KWZ","WWZ","HKV","RWM"];

    function ciSetFromOptions(selectEl){
      return new Set(Array.prototype.map.call(selectEl.options||[], function(o){
        return String(o.value||o.text||'').toLowerCase().trim();
      }));
    }

    function addMissing(selectEl, list){
      var existing = ciSetFromOptions(selectEl);
      list.forEach(function(v){
        if(!existing.has(String(v).toLowerCase())){
          var opt = document.createElement('option');
          opt.value = v; opt.textContent = v;
          selectEl.appendChild(opt);
        }
      });
    }

    function removeShorts(selectEl){
      var current = String(selectEl.value||'');
      var currentUp = current.toUpperCase();
      var keepEphemeral = SHORTS.indexOf(currentUp) >= 0;
      // Remove all shorts
      var opts = Array.from(selectEl.options||[]);
      opts.forEach(function(o){
        if (SHORTS.indexOf(String(o.value||o.text||'').toUpperCase()) >= 0){
          if (keepEphemeral && String(o.value||'').toUpperCase() === currentUp){
            // Keep one hidden placeholder if currently selected
            o.hidden = true;
            o.setAttribute('data-v23-ephemeral','1');
          } else {
            o.remove();
          }
        }
      });
    }

    function unifyAllOption(selectEl){
      // Nur für Filter (#overviewCat): Alle-Optionen mit value=='' vereinheitlichen
      var allOpts = [];
      for (var i=0;i<selectEl.options.length;i++){
        var o = selectEl.options[i];
        if (String(o.value) === '') allOpts.push(o);
      }
      if(allOpts.length){
        // Behalte die erste, beschrifte konsistent
        allOpts[0].textContent = 'Alle Kategorien';
        for (var k=1;k<allOpts.length;k++){
          allOpts[k].remove();
        }
      }
    }

    function sanitizeSelect(selectEl, isFilter){
      if(!selectEl) return;
      var prev = selectEl.value;

      // 1) Entferne Abkürzungen aus der Liste (evtl. mit hidden Platzhalter für aktuelle Auswahl)
      removeShorts(selectEl);

      // 2) Fehlende echte Kategorien nur ergänzen
      addMissing(selectEl, UI_CATS);

      // 3) Filter: „Alle Kategorien“ konsistent halten
      if(isFilter) unifyAllOption(selectEl);

      // 4) Auswahl zurücksetzen
      try{
        // Falls current ein versteckter Platzhalter ist, bleibt er gewählt; sonst vorherigen Wert herstellen
        if (prev != null && prev !== '') selectEl.value = prev;
        if (isFilter && (selectEl.value == null || selectEl.value === '')) {
          // Für Filter ggf. erste Option als "Alle Kategorien"
          if (selectEl.selectedIndex < 0) selectEl.selectedIndex = 0;
        }
      }catch(_){}
    }

    function run(){
      sanitizeSelect(document.getElementById('overviewCat'), true);
      sanitizeSelect(document.getElementById('category'), false);
      // Meta
      try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v23'; }catch(_){}
    }

    // Auch für später hinzugefügte Dialoge
    function observe(){
      if (!window.MutationObserver) return;
      var mo = new MutationObserver(function(muts){
        muts.forEach(function(m){
          for (var i=0;i<(m.addedNodes?m.addedNodes.length:0); i++){
            var n = m.addedNodes[i];
            if (!n.querySelector) continue;
            var c1 = n.querySelector('#overviewCat'); if (c1) sanitizeSelect(c1, true);
            var c2 = n.querySelector('#category');    if (c2) sanitizeSelect(c2, false);
          }
        });
      });
      mo.observe(document.documentElement || document.body, {childList:true, subtree:true});
      // Sicherheitsstop nach 2 Minuten
      setTimeout(function(){ try{ mo.disconnect(); }catch(_){ } }, 120000);
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(function(){ run(); observe(); }, 0); });
    } else {
      setTimeout(function(){ run(); observe(); }, 0);
    }
  }catch(e){ /* silent */ }
})();</script>

<script>
// v24 – Kategorien ohne "Neuware" (Editor & Übersicht identisch)
(function(){
  try{
    if (window.__v24CatsInstalled) return;
    window.__v24CatsInstalled = true;

    // Einheitliche Kategorienliste (ohne "Neuware")
    var UI_CATS = ["Zusatzmaterial","Verbrauchsmaterial","Messtechnik Nord","Werkzeug"];
    var SHORTS  = ["WMZ","KWZ","WWZ","HKV","RWM"];
    var EXCLUDE = ["Neuware"].concat(SHORTS);

    function ciValue(x){ return String(x||'').toLowerCase().trim(); }

    function ciSetFromOptions(selectEl){
      return new Set(Array.prototype.map.call(selectEl.options||[], function(o){
        return ciValue(o.value||o.text||'');
      }));
    }

    function addMissing(selectEl, list){
      var existing = ciSetFromOptions(selectEl);
      list.forEach(function(v){
        if(!existing.has(ciValue(v))){
          var opt = document.createElement('option');
          opt.value = v; opt.textContent = v;
          selectEl.appendChild(opt);
        }
      });
    }

    function removeExcluded(selectEl, excludeList){
      var current = String(selectEl.value||'');
      var currentKey = current.toUpperCase();
      var keepEphemeral = excludeList.map(function(s){return String(s).toUpperCase();}).indexOf(currentKey) >= 0;
      var opts = Array.from(selectEl.options||[]);
      opts.forEach(function(o){
        var val = String(o.value||o.text||'').toUpperCase();
        if (excludeList.map(function(s){return String(s).toUpperCase();}).indexOf(val) >= 0){
          if (keepEphemeral && val === currentKey){
            o.hidden = true;
            o.setAttribute('data-v24-ephemeral','1');
          } else {
            o.remove();
          }
        }
      });
    }

    function unifyAllOption(selectEl){
      var allOpts = [];
      for (var i=0;i<selectEl.options.length;i++){
        var o = selectEl.options[i];
        if (String(o.value) === '') allOpts.push(o);
      }
      if(allOpts.length){
        allOpts[0].textContent = 'Alle Kategorien';
        for (var k=1;k<allOpts.length;k++){
          allOpts[k].remove();
        }
      }
    }

    function sanitizeSelect(selectEl, isFilter){
      if(!selectEl) return;
      var prev = selectEl.value;

      // 1) Entferne "Neuware" & Kurzformen aus Liste (evtl. hidden Platzhalter, falls aktuell gewählt)
      removeExcluded(selectEl, EXCLUDE);

      // 2) Fehlende echten Kategorien (ohne "Neuware") nur ergänzen
      addMissing(selectEl, UI_CATS);

      // 3) Filter: Alle-Option konsistent
      if(isFilter) unifyAllOption(selectEl);

      // 4) Auswahl zurücksetzen
      try{
        if (prev != null && prev !== '') selectEl.value = prev;
        if (isFilter && (selectEl.value == null || selectEl.value === '')) {
          if (selectEl.selectedIndex < 0) selectEl.selectedIndex = 0;
        }
      }catch(_){}
    }

    function run(){
      sanitizeSelect(document.getElementById('overviewCat'), true);
      sanitizeSelect(document.getElementById('category'), false);
      try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v24'; }catch(_){}
    }

    function observe(){
      if (!window.MutationObserver) return;
      var mo = new MutationObserver(function(muts){
        muts.forEach(function(m){
          for (var i=0;i<(m.addedNodes?m.addedNodes.length:0); i++){
            var n = m.addedNodes[i];
            if (!n.querySelector) continue;
            var c1 = n.querySelector('#overviewCat'); if (c1) sanitizeSelect(c1, true);
            var c2 = n.querySelector('#category');    if (c2) sanitizeSelect(c2, false);
          }
        });
      });
      mo.observe(document.documentElement || document.body, {childList:true, subtree:true});
      setTimeout(function(){ try{ mo.disconnect(); }catch(_){ } }, 120000);
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(function(){ run(); observe(); }, 0); });
    } else {
      setTimeout(function(){ run(); observe(); }, 0);
    }
  }catch(e){ /* silent */ }
})();</script>

<script>
// v25 – Übersichtsliste exakt an Editor angleichen (additiv, keine Datenänderung)
(function(){
  try{
    if (window.__v25SyncInstalled) return;
    window.__v25SyncInstalled = true;

    function norm(txt){ return String(txt||'').trim(); }
    function key(txt){ return norm(txt).toLowerCase(); }

    function readEditorCats(){
      var sel = document.getElementById('category');
      if(!sel || !sel.options) return [];
      var out = [];
      for (var i=0;i<sel.options.length;i++){
        var o = sel.options[i];
        var v = String(o.value||'');
        var t = norm(o.textContent||o.label||'');
        // Editor-Platzhalter (keine Kategorie) überspringen
        if (v === '') continue;
        // Duplikate per Label unterdrücken
        var tKey = t;
        try{
          if (window.lvV11 && window.lvV11.status && window.lvV11.status().unifiedOn){
            tKey = String(window.lvV11.normalize(t, 'v26')||t);
          }
        }catch(_){}
        var k = key(tKey);
        if (!out.some(function(x){ return x.k === k; })){
          out.push({v:v, t:t, k:k});
        }
      }
      return out;
    }

    function ensureSingleAllOption(ov){
      // Alle Optionen mit value=='' zusammenführen
      var empties = [];
      for (var i=0;i<ov.options.length;i++){
        if (String(ov.options[i].value) === '') empties.push(ov.options[i]);
      }
      if (empties.length){
        empties[0].textContent = 'Alle Kategorien';
        for (var j=1;j<empties.length;j++) empties[j].remove();
      } else {
        var optAll = document.createElement('option');
        optAll.value = '';
        optAll.textContent = 'Alle Kategorien';
        ov.insertBefore(optAll, ov.firstChild);
      }
    }

    function ensureCatless(ov){
      // Bewahre vorhandenen Wert, ansonsten lege „Kategorielos“ mit stabiler value an
      var catless = Array.prototype.find.call(ov.options, function(o){
        return /kategorielos|keine\s*kategorie/i.test(o.textContent||'');
      });
      if (!catless){
        var o2 = document.createElement('option');
        o2.value = '__none__';
        o2.textContent = 'Kategorielos';
        // Nach „Alle Kategorien“ einfügen
        ov.insertBefore(o2, ov.options[1] || null);
        return o2.value;
      }
      return catless.value;
    }

    function syncOverview(){
      var ov = document.getElementById('overviewCat');
      if(!ov) return;

      var keep = ov.value; // aktuelle Filterwahl merken

      ensureSingleAllOption(ov);
      var catlessVal = ensureCatless(ov);

      var editor = readEditorCats();
      if(!editor.length) return; // Editor noch nicht im DOM, später erneut

      // Entferne Fremd-Optionen (außer '' und Kategorielos)
      var allowed = new Set(editor.map(function(e){ return e.k; }));
      for (var i=ov.options.length-1; i>=0; i--){
        var o = ov.options[i];
        var v = String(o.value);
        var t = norm(o.textContent||'');
        var k = key(t);
        if (v === '' || /kategorielos|keine\s*kategorie/i.test(t)) continue;
        if (!allowed.has(k)){
          o.remove();
        }
      }

      // Füge fehlende hinzu und ordne wie im Editor – nach „Alle“ und „Kategorielos“
      var baseIndex = 2; // 0: Alle, 1: Kategorielos
      editor.forEach(function(e, idx){
        var wantIndex = baseIndex + idx;
        // existiert?
        var found = Array.prototype.find.call(ov.options, function(o){
          return key(o.textContent||'') === e.k;
        });
        if (!found){
          var opt = document.createElement('option');
          opt.value = e.v; opt.textContent = e.t;
          if (ov.options.length > wantIndex){
            ov.insertBefore(opt, ov.options[wantIndex]);
          } else {
            ov.appendChild(opt);
          }
        } else {
          // Position korrigieren (nur wenn nötig)
          var curIndex = Array.prototype.indexOf.call(ov.options, found);
          if (curIndex > wantIndex){
            ov.insertBefore(found, ov.options[wantIndex]);
          }
        }
      });

      // Auswahl wiederherstellen (falls möglich)
      try{
        if (typeof keep === 'string') ov.value = keep;
      }catch(_){}
    }

    function run(){ try{ syncOverview(); }catch(_){ } }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(run, 0); });
    } else {
      setTimeout(run, 0);
    }

    // Wenn der Editor später geladen/aktualisiert wird → erneut spiegeln
    if (window.MutationObserver){
      var mo = new MutationObserver(function(muts){
        var hasCategoryChange = muts.some(function(m){
          return Array.prototype.some.call(m.addedNodes||[], function(n){
            return n.querySelector && n.querySelector('#category');
          });
        });
        if (hasCategoryChange) setTimeout(run, 0);
      });
      try{
        mo.observe(document.documentElement||document.body, {childList:true, subtree:true});
        setTimeout(function(){ try{ mo.disconnect(); }catch(_){ } }, 120000);
      }catch(_){}
    }
  }catch(e){ /* silent */ }
})();</script>
<script>(function(){ try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v26'; }catch(e){} })();</script>
<script>
// v27 – Import: Kategorie unverändert übernehmen (verlustfrei)
(function(){
  try{
    if (window.keepCategory) return;
    window.keepCategory = function(cat){
      try{
        var s = String(cat==null ? '' : cat).trim();
        return s;
      }catch(_){
        return '';
      }
    };
    try{ window.lvMeta = window.lvMeta || {}; window.lvMeta.version = 'v27'; }catch(_){}
  }catch(e){}
})();</script>

<script>
/*! v29/v30 – Mehrfachsuche + Präfixe (Materialübersicht)
   - Komma-getrennt (ODER)
   - Präfixe: sku:, name:, cat:, loc:, note:
   - Robust via MutationObserver, Filter per hidden-Attribut
*/
(function(){
  try{
    if (!window.__lvMultiSearchV29){
      window.__lvMultiSearchV29 = true;
      function $(sel){ return document.querySelector(sel) }
      function $all(sel, root){ return Array.prototype.slice.call((root||document).querySelectorAll(sel)); }
      function parseTerms(s){ return String(s||'').split(',').map(function(x){return x.trim();}).filter(Boolean).slice(0,50); }
      function anyTermMatch(txt, terms){
        var hay = String(txt||'').toLowerCase();
        for (var i=0;i<terms.length;i++){ if (hay.indexOf(terms[i].toLowerCase())!==-1) return true; }
        return false;
      }
      function applyFilter(rows, terms){
        rows.forEach(function(el){
          var text=(el.textContent||'').trim();
          if (!text){ el.hidden=false; return; }
          el.hidden = !anyTermMatch(text, terms);
        });
      }
      function rowsOverview(){
        var tb=document.querySelector('#overviewTable tbody');
        if (tb) return $all('tr', tb);
        var grid=document.getElementById('overview')||document.body;
        return $all('tr,.card,.ov-card,li,article,.row', grid);
      }
      (function(){
        var fld = $('#overviewSearch'); if (!fld) return;
        var observer=null;
        function startObs(terms){
          if (observer) try{observer.disconnect();}catch(_){}
          if (!window.MutationObserver) return;
          var root=document.querySelector('#overviewTable tbody')||document.getElementById('overview')||document.body;
          observer = new MutationObserver(function(){ applyFilter(rowsOverview(), terms); });
          observer.observe(root, {childList:true, subtree:true});
          setTimeout(function(){ try{observer.disconnect();}catch(_){ } }, 90000);
        }
        fld.addEventListener('input', function(){
          var terms=parseTerms(fld.value);
          if (terms.length<=1){ if(observer) try{observer.disconnect();}catch(_){ } rowsOverview().forEach(function(el){ el.hidden=false; }); return; }
          applyFilter(rowsOverview(), terms); startObs(terms);
        });
      })();
    }
    if (!window.__lvPrefixedSearchV30){
      window.__lvPrefixedSearchV30 = true;
      function $(sel){ return document.querySelector(sel); }
      function $all(sel, root){ return Array.prototype.slice.call((root||document).querySelectorAll(sel)); }
      var FIELD_ALIAS = {'sku':'sku','artikelnummer':'sku','artnr':'sku','name':'name','bezeichnung':'name','titel':'name','title':'name','cat':'cat','kategorie':'cat','category':'cat','loc':'loc','lagerort':'loc','ort':'loc','location':'loc','note':'note','notiz':'note','hinweis':'note','remarks':'note'};
      function splitTokens(s){
      s = String(s || '');
      var out = [], cur = '', q = null;
      for (var i = 0; i < s.length; i++){
        var ch = s[i];
        if (q){
          cur += ch;
          if (ch === q){
            q = null;
          }
        }else{
          if (ch === '"' || ch === "'"){
            q = ch;
            cur += ch;
          }else if (ch === ','){
            if (cur.trim().length){ out.push(cur.trim()); }
            cur = '';
          }else{
            cur += ch;
          }
        }
      }
      if (cur.trim().length){ out.push(cur.trim()); }
      return out.filter(Boolean).slice(0,50);
    }

    function unquote(s){
      s = String(s || '').trim();
      if (
        (s.startsWith('"') && s.endsWith('"')) ||
        (s.startsWith("'") && s.endsWith("'"))
      ){
        return s.slice(1, -1);
      }
      return s;
    }

    function parseTokens(input){
        var parts = splitTokens(String(input||'')); 
        return parts.map(function(p){
          var m = p.match(/^([^:]+):\s*(.+)$/);
          if (m){ var f=(FIELD_ALIAS[String(m[1]||'').toLowerCase().trim()]||'').trim(); var val=unquote(m[2]); if(f&&val) return {field:f,value:val}; }
          return {value:p};
        });
      }
      function buildHeaderMap(){
        var thead=document.querySelector('#overviewTable thead'); var map={}; if(!thead) return map;
        var ths=$all('th', thead);
        for(var i=0;i<ths.length;i++){ var t=String((ths[i].textContent||'').trim()).toLowerCase();
          if(t.includes('sku')||t.includes('artikel')) map.sku=i;
          else if(t.includes('name')||t.includes('bezeichnung')) map.name = map.name ?? i;
          else if(t.includes('kategorie')||t.includes('category')) map.cat=i;
          else if(t.includes('ort')||t.includes('lager')) map.loc=i;
          else if(t.includes('notiz')||t.includes('hinweis')) map.note=i;
        }
        return map;
      }
      function rowFields(row, map){
        var tds = Array.prototype.slice.call(row.querySelectorAll('td,th'));
        function cell(i){ return (i!=null && tds[i]) ? (tds[i].textContent||'') : ''; }
        var f={ sku:cell(map.sku), name:cell(map.name), cat:cell(map.cat), loc:cell(map.loc), note:cell(map.note), full:(row.textContent||'') };
        f.sku  = f.sku  || row.getAttribute('data-sku')  || '';
        f.name = f.name || row.getAttribute('data-name') || '';
        f.cat  = f.cat  || row.getAttribute('data-cat')  || row.getAttribute('data-category') || '';
        f.loc  = f.loc  || row.getAttribute('data-loc')  || row.getAttribute('data-location') || row.getAttribute('data-ort') || '';
        f.note = f.note || row.getAttribute('data-note') || row.getAttribute('data-notiz') || '';
        return f;
      }
      function anyMatchToken(fields, tok){
        var needle = String(tok.value||'').toLowerCase();
        if (!needle) return false;
        if (tok.field){ return String(fields[tok.field]||'').toLowerCase().indexOf(needle)!==-1; }
        return String(fields.full||'').toLowerCase().indexOf(needle)!==-1;
      }
      function hasAnyFieldToken(tokens){ return tokens.some(function(t){ return !!t.field; }); }
      function applyPrefixed(tokens){
        var tb=document.querySelector('#overviewTable tbody'); 
        var rows = tb ? $all('tr', tb) : $all('tr', document.getElementById('overview')||document.body);
        var map = buildHeaderMap();
        rows.forEach(function(r){
          var f=rowFields(r, map); var show=false;
          for(var i=0;i<tokens.length;i++){ if(anyMatchToken(f,tokens[i])){ show=true; break; } }
          r.hidden = !show;
        });
      }
      (function(){
        var fld = $('#overviewSearch'); if(!fld) return;
        var obs=null;
        function startObs(tokens){
          if (obs) try{obs.disconnect();}catch(_){}
          if (!window.MutationObserver) return;
          var root=document.querySelector('#overviewTable tbody')||document.getElementById('overview')||document.body;
          obs = new MutationObserver(function(){ applyPrefixed(tokens); });
          obs.observe(root,{childList:true,subtree:true});
          setTimeout(function(){ try{obs.disconnect();}catch(_){ } }, 90000);
        }
        fld.addEventListener('input', function(){
          var toks=parseTokens(fld.value);
          if (toks.length<=1 || !hasAnyFieldToken(toks)){ return; } // Volltext bleibt v29
          applyPrefixed(toks); startObs(toks);
        });
      })();
    }
  }catch(e){ console.error(e); }
})();</script>

<script>
// v38 – Übersicht-Export (sichtbare Treffer) stabil
(function(){
  try{
    var btn = document.getElementById('btnOverviewExport');
    if (!btn) return;
    var clone = btn.cloneNode(true); clone.id = btn.id; btn.parentNode.replaceChild(clone, btn);
    function $all(sel, root){ return Array.prototype.slice.call((root||document).querySelectorAll(sel)); }
    function vis(el){ if(!el||el.hidden) return false; var cs=getComputedStyle(el); if(cs.display==='none'||cs.visibility==='hidden') return false; return (el.offsetHeight>0||el.offsetWidth>0); }
    function ensureXlsxLoaded(){
      return new Promise(function(resolve){
        try{ if (typeof XLSX!=='undefined' && XLSX && XLSX.utils && XLSX.writeFile){ resolve(true); return; } }catch(_){}
        var tag=document.getElementById('xlsx-auto-loader');
        if (tag){
          var tries=0;(function wait(){ tries++; if (typeof XLSX!=='undefined' && XLSX && XLSX.utils && XLSX.writeFile){ resolve(true); return; } if (tries>120){ resolve(false); return; } setTimeout(wait,50); })();
          return;
        }
        var s=document.createElement('script'); s.id='xlsx-auto-loader'; s.src='https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js'; s.async=true;
        s.onload=function(){ resolve(true); }; s.onerror=function(){ resolve(false); }; document.head.appendChild(s);
      });
    }
    function collect(){
      var tb=document.querySelector('#overviewTable tbody');
      if (tb){
        var head=document.querySelector('#overviewTable thead');
        var headers=[]; if (head){ $all('th', head).forEach(function(th){ headers.push((th.textContent||'').trim()); }); }
        else { headers=['Name','SKU','Kategorie','Bestand','Ort','Notiz']; }
        var rows=$all('tr', tb).filter(vis).map(function(tr){
          var tds=$all('td,th', tr), arr=[]; for(var i=0;i<tds.length;i++){ arr.push((tds[i].textContent||'').trim()); } return arr;
        });
        return {headers:headers, rows:rows};
      }
      var cont=document.getElementById('overview')||document.body;
      var cards=$all('.ov-card,.card,li,article,.row', cont).filter(vis);
      if (!cards.length) return null;
      function attr(el,k){ return el.getAttribute(k)||''; }
      var rows = cards.map(function(el){ return [(attr(el,'data-name')||''),(attr(el,'data-sku')||''),(attr(el,'data-cat')||''),(attr(el,'data-qty')||''),(attr(el,'data-loc')||attr(el,'data-location')||attr(el,'data-ort')||''),(attr(el,'data-note')||'')]; });
      return {headers:['Name','SKU','Kategorie','Bestand','Ort','Notiz'], rows:rows};
    }
    clone.addEventListener('click', function(ev){
      try{
        ev.preventDefault(); ev.stopPropagation();
        setTimeout(function(){
          try{
            var t=collect();
            if(!t||!t.rows||!t.rows.length){ try{ toast && toast('Keine sichtbaren Zeilen'); }catch(_){ } return; }
            function doXlsx(){
              var wb = XLSX.utils.book_new();
              var data=[t.headers].concat(t.rows);
              var ws=XLSX.utils.aoa_to_sheet(data);
              XLSX.utils.book_append_sheet(wb, ws, 'Übersicht');
              XLSX.writeFile(wb, 'material-uebersicht.xlsx');
              try{ toast && toast('Excel exportiert'); }catch(_){}
            }
            if (typeof XLSX!=='undefined' && XLSX && XLSX.utils && XLSX.writeFile){ doXlsx(); return; }
            ensureXlsxLoaded().then(function(ok){
              try{
                if (ok && typeof XLSX!=='undefined' && XLSX && XLSX.utils && XLSX.writeFile){ doXlsx(); return; }
              }catch(_){}
              // CSV Fallback (Excel-kompatibel)
              var header=t.headers, rows=t.rows;
              function q(s){ s=String(s||''); return '"' + s.replace(/"/g,'""') + '"'; }
              var lines=['sep=;', header.map(q).join(';')];
              for (var i=0;i<rows.length;i++){ lines.push(rows[i].map(q).join(';')); }
              var csv=lines.join('\r\n');
              var blob=new Blob(['\ufeff'+csv], {type:'text/csv;charset=utf-8'});
              var a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='material-uebersicht.csv'; a.click();
              setTimeout(function(){ URL.revokeObjectURL(a.href) }, 1500);
            });
          }catch(e){ console.error(e); }
        },0);
      }catch(_){}
    });
  }catch(e){ console.error(e); }
})();</script>

<script>
(function(){
  'use strict';
  var ALERTS_KEY = 'lv_alerts_v1';
  function readAlerts(){ try{ return JSON.parse(localStorage.getItem(ALERTS_KEY)||'{}') }catch(_){ return {} } }
  function writeAlerts(obj){ localStorage.setItem(ALERTS_KEY, JSON.stringify(obj||{})); }
  function byIdMap(){ var s=readAlerts(); if(!s||typeof s!=='object') s={}; if(!s.byId||typeof s.byId!=='object') s.byId={}; return s; }
  function getConf(id){ var s=byIdMap(); var c=s.byId[id]||{active:false,threshold:0,ordered:false}; return {s:s,c:c}; }
  function putConf(id, conf){ var s=byIdMap(); s.byId[id]={active:!!conf.active,threshold:Math.max(0,Math.floor(Number(conf.threshold||0))),ordered:!!conf.ordered}; writeAlerts(s); }
  function resetIfRecovered(it){ var g=getConf(it.id).c; var qty=Number(it.qty)||0, th=Number(g.threshold)||0; if(qty>=th && g.ordered){ g.ordered=false; putConf(it.id,g); } }
  function isTriggered(it,c){ var qty=Number(it.qty)||0, th=Number(c.threshold)||0; return !!c.active && th>0 && qty<th && !c.ordered; }

  function renderAlerts(filter){
    
    var __canEditAlerts = false;
    try{
      if (typeof hasRight==='function') __canEditAlerts = !!hasRight('edit_alerts');
      else if (typeof has==='function') __canEditAlerts = !!has('edit_alerts');
      else if (window.currentPerms) __canEditAlerts = !!window.currentPerms.edit_alerts;
    }catch(_){}
var tbody=document.querySelector('#alertsTable tbody'); if(!tbody) return; tbody.innerHTML='';
    var list=Array.isArray(window.items)?window.items.slice():[];
    var mode=(filter||(localStorage.getItem('lv_alerts_filter')||'ALL')); localStorage.setItem('lv_alerts_filter',mode);
    list.forEach(function(it){ resetIfRecovered(it) });
    if(mode==='ACTIVE'){ list=list.filter(function(it){ return !!getConf(it.id).c.active }); }
    else if(mode==='TRIGGERED'){ list=list.filter(function(it){ var gc=getConf(it.id).c; return isTriggered(it,gc) }); }
    list.sort(function(a,b){ return String(a.name||'').localeCompare(String(b.name||'')) });
    list.forEach(function(it){
      var gc=getConf(it.id).c;
      var tr=document.createElement('tr'); tr.dataset.id=it.id;
      var td1=document.createElement('td'); td1.style.textAlign='left'; td1.innerHTML='<div><strong>'+ (it.name||'—') +'</strong></div><div class="muted" style="opacity:.8">'+ (it.sku||'') +'</div>';
      var td2=document.createElement('td'); td2.style.textAlign='right'; td2.textContent=String(Number(it.qty)||0);
      var td3=document.createElement('td'); td3.style.textAlign='center'; var chk=document.createElement('input'); chk.type='checkbox'; chk.className='alert-active'; chk.checked=!!gc.active;
      if(!__canEditAlerts){ try{chk.disabled=true; chk.title='Nur mit Recht „Warnungen bearbeiten“';}catch(_){}} 
      chk.addEventListener('change', function(){
        try{ if(!__canEditAlerts){ if(typeof toast==='function') toast('Keine Berechtigung'); this.checked=!this.checked; return; } }catch(_){ return; } var c=getConf(it.id).c; c.active=!!this.checked; putConf(it.id,c); renderAlerts(mode); });
      td3.appendChild(chk);
      var td4=document.createElement('td'); td4.style.textAlign='right'; var inp=document.createElement('input'); inp.type='number'; inp.min='0'; inp.step='1'; inp.className='input alert-threshold'; inp.style.maxWidth='120px'; inp.value=String(Number(gc.threshold)||0);
      if(!__canEditAlerts){ try{inp.disabled=true; inp.title='Nur mit Recht „Warnungen bearbeiten“';}catch(_){}} 
      inp.addEventListener('change', function(){
        try{ if(!__canEditAlerts){ if(typeof toast==='function') toast('Keine Berechtigung'); return; } }catch(_){ return; } var v=Math.max(0,Math.floor(Number(this.value||0))); var c=getConf(it.id).c; c.threshold=v; if((Number(it.qty)||0)>=v && c.ordered) c.ordered=false; putConf(it.id,c); renderAlerts(mode); });
      td4.appendChild(inp);
      var td5=document.createElement('td'); var badge=document.createElement('span'); var trig=isTriggered(it,gc); badge.className='badge '+(trig?'danger':'ok'); badge.className = trig ? 'lv-badge lv-badge--danger' : 'lv-badge lv-badge--ok';
            if(trig){ try{ badge.style.backgroundColor='#E53935'; badge.style.color='#FFFFFF'; badge.style.borderColor='#E53935'; }catch(e){} }
      badge.textContent = trig ? 'ausgelöst' : 'ok';
      td5.appendChild(badge);
      tr.append(td1,td2,td3,td4,td5); tbody.appendChild(tr);
    });
    var countEl=document.getElementById('alertsCount'); if(countEl){ countEl.textContent=(list.length||0)+' Einträge'; }
  }
  function openAlertsDialog(){
    try{ if(!(typeof hasRight==='function' ? hasRight('view_alerts') : (window.currentPerms && currentPerms.view_alerts))){ if(typeof toast==='function') toast('Keine Berechtigung'); else alert('Keine Berechtigung'); return; } }catch(_){ /* fallback: no-op */ }
 var dlg=document.getElementById('alertsDlg'); if(!dlg) return; var mode=localStorage.getItem('lv_alerts_filter')||'ALL'; var sel=document.getElementById('alertsFilter'); if(sel){ sel.value=mode } renderAlerts(mode); dlg.showModal(); }

  function showWarnPopup(triggered){
    if(!triggered||!triggered.length) return;
    var dlg=document.getElementById('stockWarnPopup'); var list=document.getElementById('warnList'); if(!dlg||!list) return;
    list.innerHTML='';
    triggered.forEach(function(t){ var row=document.createElement('div'); row.className='card'; row.style.padding='8px 10px'; var name=(t.item.name||'—')+' ('+(t.item.sku||'')+')'; var qty=Number(t.item.qty)||0; var th=Number(t.conf.threshold)||0; row.innerHTML='<div><strong>'+name+'</strong></div><div class="muted" style="opacity:.85">Bestand: '+qty+' • Schwellwert: '+th+'</div>'; list.appendChild(row); });
    function closeIt(){ try{ dlg.close() }catch(_){ } }
    var btnClose=document.getElementById('btnWarnPopupClose'); var btnOk=document.getElementById('btnWarnPopupOk'); var btnOrder=document.getElementById('btnWarnPopupOrder');
    // Button nur anzeigen, wenn Warnungen bearbeitet werden dürfen
    var canEditAlertsUI = false;
    try{
      if (typeof hasRight==='function') canEditAlertsUI = !!hasRight('edit_alerts');
      else if (typeof has==='function') canEditAlertsUI = !!has('edit_alerts');
      else if (window.currentPerms) canEditAlertsUI = !!window.currentPerms.edit_alerts;
    }catch(_){}
    if(btnOrder){
      btnOrder.style.display = canEditAlertsUI ? '' : 'none';
    }
    if(btnClose){ btnClose.onclick=closeIt } if(btnOk){ btnOk.onclick=closeIt }
    if(btnOrder){ btnOrder.onclick=function(){ try{ 
      var __canEditAlerts = false;
      try{
        if (typeof hasRight==='function') __canEditAlerts = !!hasRight('edit_alerts');
        else if (typeof has==='function') __canEditAlerts = !!has('edit_alerts');
        else if (window.currentPerms) __canEditAlerts = !!window.currentPerms.edit_alerts;
      }catch(_){}
      if(!__canEditAlerts){ if(typeof toast==='function') toast('Keine Berechtigung'); return; }
      triggered.forEach(function(t){ var c=getConf(t.item.id).c; c.ordered=true; putConf(t.item.id,c); }); }catch(_){ } closeIt(); }; }
    dlg.showModal();
  }
  function collectTriggered(){ var arr=Array.isArray(window.items)?window.items.slice():[]; var L=[]; arr.forEach(function(it){ var gc=getConf(it.id).c; if(isTriggered(it,gc)) L.push({item:it, conf:gc}); }); return L; }
  function startupCheck(){ var t=collectTriggered(); if(t.length) showWarnPopup(t); }

  (function(){ // Wrap saveJson
    try{
      var originalSave=window.saveJson; if(typeof originalSave!=='function') return;
      var storageKey=(typeof window.storageKey!=='undefined')?window.storageKey:(window.storageKey||'lagerverwaltung_items_v12');
      window.saveJson=function(key,val){
        try{
          if(key===storageKey){
            var before=Array.isArray(window.items)?window.items.slice():[];
            originalSave(key,val);
            try{ if(Array.isArray(val)) window.items=val }catch(_){}
            var after=Array.isArray(window.items)?window.items.slice():[];
            after.forEach(function(it){ resetIfRecovered(it) });
            var trig=[];
            after.forEach(function(it){
              var c=getConf(it.id).c; var th=Number(c.threshold||0);
              if(!!c.active && th>0 && !c.ordered){
                var prev=before.find(function(x){ return x.id===it.id })||{};
                var qb=Number(prev.qty)||0, qa=Number(it.qty)||0;
                if(qb>=th && qa<th){ trig.push({item:it, conf:c}); }
              }
            });
            if(trig.length){ setTimeout(function(){ showWarnPopup(trig) }, 0) }
            return;
          }
        }catch(_){}
        return originalSave(key,val);
      };
    }catch(_){}
  })();

  function onReady(){
    var h=document.getElementById('openAlerts'); if(h){ h.addEventListener('click', function(){ if(!has('view_alerts')){ toast('Keine Berechtigung'); return } openAlertsDialog(); }) }
    var c=document.getElementById('btnAlertsClose'); if(c){ c.addEventListener('click', function(){ var d=document.getElementById('alertsDlg'); if(d) d.close(); }) }
    var sel=document.getElementById('alertsFilter'); if(sel){ sel.addEventListener('change', function(){ renderAlerts(this.value) }) }
    startupCheck();
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', onReady); } else { onReady(); }
})();</script>



<script>
// v03 – Kategorien stabilisieren (nicht-destruktiv, keine Änderungen an bestehenden Kategorien)
(function(){
  'use strict';
  try{
    if (window.__lvCatsV03) return;
    window.__lvCatsV03 = true;

    function $id(id){ return document.getElementById(id); }
    function readItemsSafe(){
      try { return (window.readItems ? window.readItems() : []) || []; } catch(_) { return []; }
    }
    function catListFromItems(){
      var seen = new Set(); var out = [];
      var arr = readItemsSafe();
      for (var i=0;i<arr.length;i++){
        var it = arr[i];
        var c = (it && Object.prototype.hasOwnProperty.call(it,'category')) ? String(it.category||'') : '';
        if (!c) continue; // kein Kategorielos
        if (!seen.has(c)){ seen.add(c); out.push(c); }
      }
      return out;
    }
    function snapshotOptions(selectEl){
      var arr = [];
      if (!selectEl) return arr;
      for (var i=0;i<selectEl.options.length;i++){
        var o = selectEl.options[i];
        var v = String(o.value);
        var t = o.textContent == null ? '' : String(o.textContent);
        // Nur echte Kategorien, keine Spezial-Optionen
        if (v !== '' && !/kategorielos/i.test(t)){
          arr.push(v);
        }
      }
      return arr;
    }
    function ensureOptions(selectEl, optionsOrder){
      if (!selectEl) return;
      var keepValue = selectEl.value;
      var present = new Set();
      for (var i=0;i<selectEl.options.length;i++){ present.add(String(selectEl.options[i].value)); }

      // Fehlende Kategorien anhängen (keine Umbenennung/Sortierung/Löschung)
      for (var j=0;j<optionsOrder.length;j++){
        var cat = String(optionsOrder[j]);
        if (cat === '') continue;
        if (!present.has(cat)){
          var o = document.createElement('option');
          o.value = cat;
          o.textContent = cat;
          selectEl.appendChild(o);
        }
      }

      // Für den Übersichts-Filter sicherstellen, dass es genau eine leere "Alle Kategorien"-Option gibt
      if (selectEl.id === 'overviewCat'){
        var hasEmpty = false;
        for (var k=0;k<selectEl.options.length;k++){
          if (String(selectEl.options[k].value) === '') { hasEmpty = true; break; }
        }
        if (!hasEmpty){
          var all = document.createElement('option');
          all.value = '';
          all.textContent = 'Alle Kategorien';
          // Vorsichtig am Anfang einfügen; Kategorien selbst bleiben unverschoben
          selectEl.insertBefore(all, selectEl.firstChild);
        }
      }

      // Auswahl wiederherstellen (falls vorhanden)
      try { if (keepValue != null) selectEl.value = keepValue; } catch(_){}
    }

    function runOnce(id){
      var el = $id(id);
      if (!el) return;
      var initial = snapshotOptions(el);
      var merged = initial.slice(0);
      var fromData = catListFromItems();
      for (var i=0;i<fromData.length;i++){
        if (merged.indexOf(fromData[i]) === -1) merged.push(fromData[i]);
      }
      ensureOptions(el, merged);
    }

    function run(){
      runOnce('category');
      runOnce('overviewCat');
    }

    // Beobachter: bei DOM-Änderungen (Editor/Filter erscheinen, Import, etc.) erneut anwenden
    var mo;
    function startObserver(){
      if (!window.MutationObserver) return;
      mo = new MutationObserver(function(muts){
        var touched = false;
        for (var i=0;i<muts.length;i++){
          var m = muts[i];
          if (m.addedNodes && m.addedNodes.length) touched = true;
          if (m.type === 'childList' || m.type === 'attributes') touched = true;
        }
        if (touched) { try { run(); } catch(_){ } }
      });
      mo.observe(document.documentElement || document.body, { childList:true, subtree:true, attributes:true });
      // Sicherheits-Timeout nach 2 Minuten
      setTimeout(function(){ try{ mo.disconnect(); }catch(_){} }, 120000);
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(function(){ run(); startObserver(); }, 0); });
    } else {
      setTimeout(function(){ run(); startObserver(); }, 0);
    }
  }catch(e){ /* silent */ }
})();</script>


<script>
// v04 – Kategorien Diagnose (read-only, keine Änderungen)
(function(){
  'use strict';
  try{
    if (window.__lvDiagV04) return;
    window.__lvDiagV04 = true;

    function $id(id){ return document.getElementById(id); }
    function readItemsSafe(){
      try { return (window.readItems ? window.readItems() : []) || []; } catch(_) { return []; }
    }
    function uniquePreserve(arr){
      var s = new Set(); var out = [];
      for (var i=0;i<arr.length;i++){
        var v = arr[i];
        if (!s.has(v)){ s.add(v); out.push(v); }
      }
      return out;
    }
    function categoriesFromItems(){
      var items = readItemsSafe();
      var cats = [];
      for (var i=0;i<items.length;i++){
        var it = items[i];
        if (!it) continue;
        var c = (Object.prototype.hasOwnProperty.call(it,'category')) ? String(it.category||'') : '';
        if (c) cats.push(c);
      }
      return uniquePreserve(cats);
    }
    function snapshotSelect(el){
      var out = [];
      if (!el || !el.options) return out;
      for (var i=0;i<el.options.length;i++){
        var o = el.options[i];
        out.push({ value: String(o.value), text: (o.textContent==null?'':String(o.textContent)) });
      }
      return out;
    }
    function diff(baseArr, compareSet){
      var out = [];
      for (var i=0;i<baseArr.length;i++){
        var v = baseArr[i];
        if (!compareSet.has(v)) out.push(v);
      }
      return out;
    }
    function logDiag(){
      var ts = new Date().toISOString();
      var items = readItemsSafe();
      var itemCats = categoriesFromItems();

      var selCat = $id('category');
      var selOverview = $id('overviewCat');

      var snapCat = snapshotSelect(selCat);
      var snapOverview = snapshotSelect(selOverview);

      var catValues = []; // nur echte Kategorie-Werte aus Editor-Select (ohne leere)
      for (var i=0;i<snapCat.length;i++){ if (snapCat[i].value !== '') catValues.push(snapCat[i].value); }

      var setItem = new Set(itemCats);
      var setSel = new Set(catValues);

      var itemsNotInSelect = diff(itemCats, setSel);
      var selectNotInItems = diff(catValues, setItem);

      // Kompakte, aber strukturierte Ausgabe
      

    }

    function run(){ try{ logDiag(); }catch(_){ } }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){
        setTimeout(run, 0);
        setTimeout(run, 2000); // lazy UI erfassen
      });
    } else {
      setTimeout(run, 0);
      setTimeout(run, 2000);
    }
  }catch(e){ /* silent */ }
})();</script>


<style id="lv-v05-warn-style">
/* v05 – nur Anzeigeanpassung: 'Ausgelöst' rot markieren */
.lv-warn-status--ausgeloest { color: #D32F2F !important; font-weight: 600; }
/* falls als Chip/Badge dargestellt */
.lv-warn-chip.lv-warn-status--ausgeloest {
  border-color: #D32F2F !important;
  background: rgba(211, 47, 47, 0.08) !important;
}
</style>
<script>
// v05 – Warnungen: 'Ausgelöst' rot markieren (nicht-invasiv)
(function(){
  'use strict';
  try{
    if (window.__lvWarnV05) return;
    window.__lvWarnV05 = true;

    function norm(s){
      if (s == null) return '';
      s = String(s).trim();
      // deutsche Umlaute als Fallback behandeln
      return s.toLowerCase()
              .replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue')
              .replace(/ß/g,'ss');
    }
    function isTriggered(text){
      var t = norm(text);
      return t.includes('ausgeloest'); // deckt sowohl 'ausgelöst' als auch 'ausgeloest' ab
    }
    function markInContainer(root){
      if (!root) return;
      // Kandidaten: explizite Status-Elemente zuerst
      var nodes = root.querySelectorAll('[data-status], [data-state], .status, .state, .chip, .badge, td, span, div');
      for (var i=0;i<nodes.length;i++){
        var el = nodes[i];
        // nicht auf Input/Select/Button anwenden
        var tag = el.tagName;
        if (tag === 'INPUT' || tag === 'SELECT' || tag === 'BUTTON' || tag === 'TEXTAREA') continue;
        var txt = el.textContent;
        if (isTriggered(txt)){
          // nur hinzufügen, nichts entfernen/umschreiben
          el.classList.add('lv-warn-status--ausgeloest');
          // falls Chips verwendet werden, ergänzen ohne bestehende Klassen zu stören
          if (/chip|badge/i.test(el.className)) el.classList.add('lv-warn-chip');
          // leichte A11y-Hilfe (additiv)
          if (!el.getAttribute('aria-label')){
            el.setAttribute('aria-label','Warnung: Ausgelöst');
          }
        }
      }
    }
    function scan(){
      // scope: Bereiche, die offensichtlich Warnungen enthalten
      var scopes = [];
      // bevorzugt IDs/Klassen mit 'warn' oder 'alert'
      var sel = '[id*="warn" i], [class*="warn" i], [id*="alert" i], [class*="alert" i]';
      var found = document.querySelectorAll(sel);
      for (var i=0;i<found.length;i++) scopes.push(found[i]);
      // Fallback: gesamtes Dokument, aber nur wenn keine Scopes gefunden wurden
      if (scopes.length === 0) scopes = [document.body || document.documentElement];
      for (var j=0;j<scopes.length;j++) markInContainer(scopes[j]);
    }

    function start(){
      try { scan(); } catch(_) {}
      // Mutations beobachten, um dynamische Aktualisierungen zu erfassen
      if (window.MutationObserver){
        var mo = new MutationObserver(function(muts){
          var touch = false;
          for (var i=0;i<muts.length;i++){
            if (muts[i].addedNodes && muts[i].addedNodes.length){ touch = true; break; }
            if (muts[i].type === 'characterData'){ touch = true; break; }
          }
          if (touch){ try { scan(); } catch(_) {} }
        });
        mo.observe(document.documentElement, {subtree:true, childList:true, characterData:true});
        // nach 2 Minuten automatisch beenden (Ressourcen-schonend)
        setTimeout(function(){ try{ mo.disconnect(); }catch(e){} }, 120000);
      }
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(start, 0); });
    } else {
      setTimeout(start, 0);
    }
  }catch(e){ /* silent */ }
})();</script>


<style id="lv-v06-warn-badge">
/* v06 – Neutralisiere frühere v05-Färbung auf Container-Ebene */
.lv-warn-status--ausgeloest { color: inherit !important; font-weight: inherit !important; }
/* Badge-Styles (ähnlich 'ok', aber rot) */
.lv-badge { display:inline-flex; align-items:center; padding: 2px 10px; border-radius: 9999px; font-weight: 600; font-size: 0.85rem; line-height: 1.4; border: 1px solid transparent; }
.lv-badge--danger { background: #E53935; color: #FFFFFF; border-color: #E53935; }
/* Falls bestehende Chips/Badges vorhanden sind, nur Farbe überschreiben */
.badge.lv-badge--danger, .chip.lv-badge--danger { background: #E53935 !important; color: #FFFFFF !important; border-color: #E53935 !important; }
</style>
<script>
// v06 – 'Ausgelöst' als rote Badge, ohne restlichen Text zu beeinflussen
(function(){
  'use strict';
  try{
    if (window.__lvWarnV06) return;
    window.__lvWarnV06 = true;

    function norm(s){
      if (s == null) return '';
      s = String(s).trim();
      return s.toLowerCase()
              .replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue')
              .replace(/ß/g,'ss');
    }
    function isAusgeloestText(s){
      var t = norm(s);
      return t === 'ausgeloest' || t === 'ausgeloest.' || t === 'ausgeloest!' || t === 'ausgeloest?' || t === 'ausgeloest,' || t === 'ausgeloest;';
    }
    function findLeafTargets(root){
      var out = [];
      var nodes = root.querySelectorAll('span, b, strong, small, i, em, td, div');
      for (var i=0;i<nodes.length;i++){
        var el = nodes[i];
        // überspringe großflächige Container
        var tag = el.tagName;
        if (tag === 'DIV' || tag === 'TD'){
          // nur wenn es ein "Leaf" ist (keine Element-Kinder) und nur aus dem Wort besteht
          if (el.children.length === 0 && isAusgeloestText(el.textContent)) out.push(el);
          continue;
        }
        // kleine Inline-Elemente erlauben
        if (el.children.length === 0 && isAusgeloestText(el.textContent)) out.push(el);
        else {
          // versuche direkten Kind-Textknoten mit exakt dem Wort zu finden
          for (var j=0;j<el.childNodes.length;j++){
            var n = el.childNodes[j];
            if (n.nodeType === Node.TEXT_NODE && isAusgeloestText(n.textContent)){
              out.push(el);
              break;
            }
          }
        }
      }
      return out;
    }
    function ensureBadge(el){
      if (!el) return;
      if (el.dataset && el.dataset.lvBadge === 'danger') return;
      var txt = (el.textContent||'').trim();
      // Wenn Element schon eine Badge/Chip darstellt, nur Klassen ergänzen
      if (/badge|chip|pill/i.test(el.className) && el.children.length === 0){
        el.classList.add('lv-badge','lv-badge--danger');
        el.dataset.lvBadge = 'danger';
        return;
      }
      // Wenn das Element selbst nur das Wort enthält und keine Kinder hat, klassifizieren
      if (el.children.length === 0 && isAusgeloestText(el.textContent)){
        el.classList.add('lv-badge','lv-badge--danger');
        el.textContent = 'ausgelöst';
        el.dataset.lvBadge = 'danger';
        return;
      }
      // Andernfalls: kleinstmögliche Umhüllung hinzufügen (ohne Originaltext zu verändern)
      // Suche erste reine Textnode mit dem Wort und ersetze sie durch span
      for (var i=0;i<el.childNodes.length;i++){
        var n = el.childNodes[i];
        if (n.nodeType === Node.TEXT_NODE && isAusgeloestText(n.textContent)){
          var span = document.createElement('span');
          span.className = 'lv-badge lv-badge--danger';
          span.textContent = 'ausgelöst';
          span.setAttribute('data-lv-badge','danger');
          el.replaceChild(span, n);
          return;
        }
      }
    }
    function scan(){
      // Begrenze Suche auf Warnungsbereiche; Fallback body
      var scopes = [];
      var sel = '[id*="warn" i], [class*="warn" i], [id*="alert" i], [class*="alert" i]';
      var found = document.querySelectorAll(sel);
      for (var i=0;i<found.length;i++) scopes.push(found[i]);
      if (scopes.length === 0) scopes = [document.body || document.documentElement];

      for (var k=0;k<scopes.length;k++){
        var targets = findLeafTargets(scopes[k]);
        for (var t=0;t<targets.length;t++) ensureBadge(targets[t]);
      }
    }
    function start(){
      // Einmal initial
      scan();
      // Auch bei dynamischen Änderungen erneut
      if (window.MutationObserver){
        var mo = new MutationObserver(function(muts){
          var touch=false;
          for (var i=0;i<muts.length;i++){
            if (muts[i].addedNodes && muts[i].addedNodes.length){ touch=true; break; }
            if (muts[i].type === 'characterData'){ touch=true; break; }
          }
          if (touch) scan();
        });
        mo.observe(document.documentElement, {subtree:true, childList:true, characterData:true});
        setTimeout(function(){ try{ mo.disconnect(); }catch(e){} }, 120000);
      }
    }
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ setTimeout(start,0); });
    } else {
      setTimeout(start,0);
    }
  }catch(e){ /* silent */ }
})();</script>



<style id="lv-v07-badges">
/* v07 – Einheitliche Badge-Metriken */
:root{
  --lv-badge-pad-y: 2px;
  --lv-badge-pad-x: 10px;
  --lv-badge-radius: 9999px;
  --lv-badge-font-size: 0.85rem;
  --lv-badge-font-weight: 600;
}
.lv-badge{
  display:inline-flex; align-items:center; vertical-align:middle;
  padding: var(--lv-badge-pad-y) var(--lv-badge-pad-x);
  border-radius: var(--lv-badge-radius);
  font-size: var(--lv-badge-font-size);
  font-weight: var(--lv-badge-font-weight);
  line-height: 1.4;
  border: 1px solid transparent;
  white-space: nowrap;
}
.lv-badge--danger{ background:#E53935; color:#FFFFFF; border-color:#E53935; }
.lv-badge--success{ background:#2E7D32; color:#FFFFFF; border-color:#2E7D32; }
.lv-warn-chip.lv-warn-status--ausgeloest{ background:#E53935 !important; color:#FFFFFF !important; border-color:#E53935 !important; }
/* Falls bestehende Framework-Badges vorhanden sind, nur Farben vereinheitlichen */
.badge.lv-badge--danger, .chip.lv-badge--danger { background:#E53935 !important; color:#FFFFFF !important; border-color:#E53935 !important; }
.badge.lv-badge--success, .chip.lv-badge--success { background:#2E7D32 !important; color:#FFFFFF !important; border-color:#2E7D32 !important; }
</style>
<script>
// v07 – Symmetrische Badges für 'ok' & 'ausgelöst' in Warnungsbereichen
(function(){
  'use strict';
  try{
    if (window.__lvWarnV07) return;
    window.__lvWarnV07 = true;

    function norm(s){
      if (s == null) return '';
      s = String(s).trim();
      return s.toLowerCase()
              .replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue')
              .replace(/ß/g,'ss');
    }
    function cleanToken(s){
      var t = norm(s);
      // entferne häufige Satzzeichen-Endungen
      t = t.replace(/[\.,;!?:]+$/, '');
      return t;
    }
    function isAusgeloestText(s){ return cleanToken(s) === 'ausgeloest'; }
    function isOkText(s){ return cleanToken(s) === 'ok'; }

    function leafCandidates(scope){
      // Inline-/kleine Elemente priorisieren; Tabellenspitzen nur wenn Leaf
      return scope.querySelectorAll('span, b, strong, small, i, em, td, div');
    }

    function ensureBadge(el, variant){
      if (!el) return;
      // schon badge? nur Klassen ergänzen
      if (/\blv-badge\b/.test(el.className)){
        if (variant === 'danger') el.classList.add('lv-badge--danger');
        if (variant === 'success') el.classList.add('lv-badge--success');
        return;
      }
      // wenn bestehende chip/badge, ergänzen
      if (/\bbadge\b|\bchip\b|\bpill\b/i.test(el.className) && el.children.length === 0){
        el.classList.add('lv-badge', variant==='danger' ? 'lv-badge--danger' : 'lv-badge--success');
        return;
      }
      // nur wenn Leaf-Text exakt das Wort ist
      if (el.children.length === 0){
        var raw = (el.textContent||'').trim();
        var token = cleanToken(raw);
        if ((variant==='danger' && token==='ausgeloest') || (variant==='success' && token==='ok')){
          el.classList.add('lv-badge', variant==='danger' ? 'lv-badge--danger' : 'lv-badge--success');
          // Normalisiere Anzeige-Text minimal (Kleinschreibung wie im Screenshot)
          el.textContent = (variant==='danger' ? 'ausgelöst' : 'ok');
          return;
        }
      }
      // Ansonsten: den passenden Textknoten durch eine Badge-Spanne ersetzen
      for (var i=0;i<el.childNodes.length;i++){
        var n = el.childNodes[i];
        if (n.nodeType === Node.TEXT_NODE){
          var token = cleanToken(n.textContent||'');
          if ((variant==='danger' && token==='ausgeloest') || (variant==='success' && token==='ok')){
            var span = document.createElement('span');
            span.className = 'lv-badge ' + (variant==='danger' ? 'lv-badge--danger' : 'lv-badge--success');
            span.textContent = (variant==='danger' ? 'ausgelöst' : 'ok');
            el.replaceChild(span, n);
            return;
          }
        }
      }
    }

    function scan(){
      var scopes = [];
      var sel = '[id*="warn" i], [class*="warn" i], [id*="alert" i], [class*="alert" i]';
      var found = document.querySelectorAll(sel);
      for (var i=0;i<found.length;i++) scopes.push(found[i]);
      if (scopes.length === 0) scopes = [document.body || document.documentElement];

      for (var s=0;s<scopes.length;s++){
        var nodes = leafCandidates(scopes[s]);
        for (var j=0;j<nodes.length;j++){
          var el = nodes[j];
          if (el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'BUTTON' || el.tagName === 'TEXTAREA') continue;
          var text = (el.textContent||'').trim();
          if (isAusgeloestText(text)) ensureBadge(el, 'danger');
          else if (isOkText(text)) ensureBadge(el, 'success');
          else {
            // check child text nodes
            for (var k=0;k<el.childNodes.length;k++){
              var n = el.childNodes[k];
              if (n.nodeType === Node.TEXT_NODE){
                var token = cleanToken(n.textContent||'');
                if (token==='ausgeloest'){ ensureBadge(el,'danger'); break; }
                if (token==='ok'){ ensureBadge(el,'success'); break; }
              }
            }
          }
        }
      }
    }

    function start(){
      scan();
      if (window.MutationObserver){
        var mo = new MutationObserver(function(muts){
          var touch=false;
          for (var i=0;i<muts.length;i++){
            if (muts[i].addedNodes && muts[i].addedNodes.length){ touch=true; break; }
            if (muts[i].type === 'characterData'){ touch=true; break; }
          }
          if (touch) scan();
        });
        mo.observe(document.documentElement, {subtree:true, childList:true, characterData:true});
        setTimeout(function(){ try{ mo.disconnect(); }catch(e){} }, 120000);
      }
    }

    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', function(){ setTimeout(start,0); });
    else setTimeout(start,0);
  }catch(e){ /* silent */ }
})();</script>

<script>
(function(){
  function ts(d){ var t=Date.parse(d); return isNaN(t)?null:t; }
  function computeBadge(it){
    var lastIn=null, lastOut=null, lastQty=null;
    try{
      var lg = Array.isArray(it.log) ? it.log : [];
      for (var i=0;i<lg.length;i++){
        var e=lg[i]; if(!e) continue;
        if (e.ts==null) continue;
        var ty=(e.type||'').toString().toLowerCase();
        if (ty==='in')  lastIn  = Math.max(lastIn===null?-1:lastIn, Number(e.ts));
        else if (ty==='out') lastOut = Math.max(lastOut===null?-1:lastOut, Number(e.ts));
        else if (ty==='qty') lastQty = e; // keep whole entry (ts, delta)
      }
    }catch(_){}
    if (lastIn!=null || lastOut!=null){
      if (lastOut!=null && (lastIn==null || lastOut>lastIn)) return {cls:'out', txt:'Ausgang gebucht'};
      return {cls:'ok', txt:'Eingang gebucht'};
    }
    if (lastQty && typeof lastQty.delta==='number'){
      if (lastQty.delta>0) return {cls:'ok', txt:'Eingang gebucht'};
      if (lastQty.delta<0) return {cls:'out', txt:'Ausgang gebucht'};
    }
    var ti=ts(it.inDate), to=ts(it.outDate);
    if (to!=null || ti!=null){
      if (to!=null && (ti==null || to>ti)) return {cls:'out', txt:'Ausgang gebucht'};
      return {cls:'ok', txt:'Eingang gebucht'};
    }
    return {cls:'warn', txt:'Ohne Datum'};
  }
  function finalize(){
    try{
      var cards=document.querySelectorAll('#cards .card');
      for (var i=0;i<cards.length;i++){
        var card=cards[i]; var id=card.getAttribute('data-id')||'';
        var it=(window.items||[]).find(function(x){ return String(x.id||'')===id; });
        if(!it) continue;
        var b=card.querySelector('.badge'); if(!b) continue;
        var r=computeBadge(it); b.className='badge '+r.cls; b.textContent=r.txt;
      }
    }catch(_){}
  }
  // Hook render and run once
  if (typeof window.render==='function' && !window.render.__v19){
    var _r=window.render; window.render=function(){ var rv=_r.apply(this,arguments); try{finalize();}catch(_){} return rv; };
    
  }
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', function(){ setTimeout(finalize,0); });
  else setTimeout(finalize,0);
})();</script>


<script>
(function(){
  function ts(d){ var t=Date.parse(d); return isNaN(t)?null:t; }
  function computeBadge(it){
    var lastIn=null, lastOut=null, lastQty=null;
    try{
      var lg = Array.isArray(it.log) ? it.log : [];
      for (var i=0;i<lg.length;i++){
        var e=lg[i]; if(!e) continue;
        if (e.ts==null) continue;
        var ty=(e.type||'').toString().toLowerCase();
        if (ty==='in')  lastIn  = Math.max(lastIn===null?-1:lastIn, Number(e.ts));
        else if (ty==='out') lastOut = Math.max(lastOut===null?-1:lastOut, Number(e.ts));
        else if (ty==='qty') lastQty = e;
      }
    }catch(_){}
    if (lastIn!=null || lastOut!=null){
      if (lastOut!=null && (lastIn==null || lastOut>lastIn)) return {cls:'out', txt:'Ausgang gebucht'};
      return {cls:'ok', txt:'Eingang gebucht'};
    }
    if (lastQty && typeof lastQty.delta==='number'){
      if (lastQty.delta>0) return {cls:'ok', txt:'Eingang gebucht'};
      if (lastQty.delta<0) return {cls:'out', txt:'Ausgang gebucht'};
    }
    var ti=ts(it.inDate), to=ts(it.outDate);
    if (to!=null || ti!=null){
      if (to!=null && (ti==null || to>ti)) return {cls:'out', txt:'Ausgang gebucht'};
      return {cls:'ok', txt:'Eingang gebucht'};
    }
    return {cls:'warn', txt:'Ohne Datum'};
  }

  function findStatusBadge(card){
    // 1) Preferred: explicitly marked
    var b = card.querySelector('.badge[data-role="status"], .status-badge');
    if (b) return b;
    // 2) Structural heuristic: our status badge is the first child, followed by <h3> and .meta
    var c0 = card.firstElementChild, c1 = c0 && c0.nextElementSibling, c2 = c1 && c1.nextElementSibling;
    if (c0 && c0.classList && c0.classList.contains('badge') && c1 && c1.tagName==='H3' && c2 && c2.classList && c2.classList.contains('meta')) {
      return c0;
    }
    // 3) Heuristic by text (only touch if it already reads like a status)
    var candidates = card.querySelectorAll('.badge');
    for (var i=0;i<candidates.length;i++){
      var t = (candidates[i].textContent||'').trim().toLowerCase();
      if (t==='eingang gebucht' || t==='ausgang gebucht' || t==='ohne datum') return candidates[i];
    }
    return null;
  }

  function finalize(){
    try{
      var cards=document.querySelectorAll('#cards .card');
      for (var i=0;i<cards.length;i++){
        var card=cards[i];
        var id=card.getAttribute('data-id')||'';
        var it=(window.items||[]).find(function(x){ return String(x.id||'')===id; });
        if(!it) continue;
        var b=findStatusBadge(card);
        if(!b) continue;
        var r=computeBadge(it);
        b.className='badge '+r.cls;
        b.setAttribute('data-role','status');
        b.textContent=r.txt;
      }
    }catch(_){}
  }

  // Hook render and run once
  if (typeof window.render==='function' && !window.render.__v20){
    var _r=window.render; window.render=function(){ var rv=_r.apply(this,arguments); try{finalize();}catch(_){} return rv; };
    window.render.__v20=true;
  }
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', function(){ setTimeout(finalize,0); });
  else setTimeout(finalize,0);
})();</script>





<script id="lv37-cat-dom">
(function(){
  'use strict';
  var DEVSET = {WMZ:1, KWZ:1, WWZ:1, HKV:1, RWM:1};
  var UISHORT = { ZM:'ZM', VBR:'VBR', ME:'ME', WG:'WG' };

  function nrm(s){ return String(s||'').toLowerCase().trim()
    .replace(/[äÄ]/g,'ae').replace(/[öÖ]/g,'oe').replace(/[üÜ]/g,'ue'); }

  function sanitizeLabel(badge){
    var label = badge.querySelector('[data-role=\"status-label\"]');
    var cur;
    if (!label){
      cur = (badge.textContent||'').trim();
      label = document.createElement('span');
      label.setAttribute('data-role','status-label');
      while (badge.firstChild) badge.removeChild(badge.firstChild);
      badge.appendChild(label);
    } else {
      cur = (label.textContent||'').trim();
    }
    var m = String(cur).match(/^(Eingang gebucht|Ausgang gebucht|Ohne Datum)/i);
    label.textContent = m ? m[1] : cur;
    return label;
  }

  function abbrFromCategory(cat){
    if (!cat) return '';
    var raw = String(cat).trim();
    var upper = raw.toUpperCase();
    var lower = nrm(raw);
    if (DEVSET[upper]) return upper;
    if (UISHORT[upper]) return upper;
    if (upper === 'VB') return 'VBR';
    try{
      if (window.CAT_SHORT && typeof CAT_SHORT==='object'){
        var s = CAT_SHORT[raw] || CAT_SHORT[upper] || CAT_SHORT[lower];
        if (s) return (String(s).toUpperCase()==='VB'?'VBR':String(s).toUpperCase());
      }
    }catch(_){}
    var DEV_LONG = {
      'heizkostenverteiler':'HKV',
      'rauchwarnmelder':'RWM','rauchmelder':'RWM',
      'waermemengenzaehler':'WMZ','waermemengenzahler':'WMZ','waermenzaehler':'WMZ','waermezaehler':'WMZ','waermezahler':'WMZ',
      'kaltwasser':'KWZ','kaltwasserzaehler':'KWZ','kaltwasserzähler':'KWZ',
      'warmwasser':'WWZ','warmwasserzaehler':'WWZ','warmwasserzähler':'WWZ',
      'warmwasserzähler':'WWZ','kaltwasserzähler':'KWZ','wärmemengenzähler':'WMZ','wärmezähler':'WMZ'
    };
    if (DEV_LONG[lower]) return DEV_LONG[lower];
    var UI2SHORT = { 'zusatzmaterial':'ZM', 'verbrauchsmaterial':'VBR', 'messtechnik nord':'ME', 'werkzeug':'WG' };
    if (UI2SHORT[lower]) return UI2SHORT[lower];
    if (/^[A-Z]{2,4}$/.test(upper)) return upper;
    return '';
  }

  function devFromTitle(title){
    var U = String(title||'').toUpperCase().replace(/\s+/g,'');
    var t = nrm(title);
    if (U.indexOf('WMZ')>=0) return 'WMZ';
    if (U.indexOf('KWZ')>=0) return 'KWZ';
    if (U.indexOf('WWZ')>=0) return 'WWZ';
    if (U.indexOf('HKV')>=0) return 'HKV';
    if (U.indexOf('RWM')>=0) return 'RWM';
    if (t.indexOf('kaltwasser')>=0) return 'KWZ';
    if (t.indexOf('warmwasser')>=0) return 'WWZ';
    if (t.indexOf('heizkostenverteiler')>=0) return 'HKV';
    if (t.indexOf('rauchwarnmelder')>=0 || t.indexOf('rauchmelder')>=0) return 'RWM';
    if (t.indexOf('waermemengenzaehler')>=0 || t.indexOf('waermezaehler')>=0 || t.indexOf('waermenzaehler')>=0 || t.indexOf('waermemengenzahler')>=0 || t.indexOf('waermezahler')>=0) return 'WMZ';
    return '';
  }

  function getCategoryFromDOM(card){
    // data attributes first
    var attr = card.getAttribute('data-cat') || card.getAttribute('data-category') || card.getAttribute('data-kategorie');
    if (attr) return attr;
    // common selectors
    var sel = card.querySelector('[data-cat],[data-category],[data-kategorie], .category, .kategorie, [data-field=\"category\"], [data-field=\"kategorie\"], [data-key=\"category\"], [data-key=\"kategorie\"]');
    if (sel && sel.textContent) return sel.textContent.trim();
    // label-based scan: look for "Kategorie:" and read trailing text
    var text = card.textContent || '';
    if (text){
      var m = text.match(/Kategorie\s*:?\s*([A-Za-zÄÖÜäöüß\s\-]+)\b/);
      if (m && m[1]) return m[1].trim();
    }
    return '';
  }

  function ensureChip(badge){
    var chip = badge.querySelector('.chip.cat') || badge.querySelector('[data-role=\"cat-abbr\"]');
    var dups = badge.querySelectorAll('.chip.cat');
    for (var i=1;i<dups.length;i++) dups[i].remove();
    if (!chip){
      chip = document.createElement('span');
      chip.className = 'chip cat';
      chip.setAttribute('data-role','cat-abbr');
      badge.appendChild(chip);
    }
    return chip;
  }

  function getItemForCard(card, title){
    var id = card.getAttribute('data-id')||'';
    var it = null;
    try{
      if (Array.isArray(window.items)){
        it = (id ? window.items.find(function(x){ return String(x.id||'')===String(id); }) : null) ||
             window.items.find(function(x){ return nrm(x.name||x.title||x.bezeichnung||'') === nrm(title); });
      }
    }catch(_){}
    return it;
  }

  function updateCard(card){
    try{
      var badge = card.querySelector('.badge'); if (!badge) return;
      sanitizeLabel(badge);
      var titleEl = card.querySelector('h3'); var title = titleEl && titleEl.textContent || '';

      // 1) Try category from DOM (works on cold boot even ohne items)
      var catDom = getCategoryFromDOM(card);
      // 2) Try from items model (after it loads)
      var it = getItemForCard(card, title);
      var catName = catDom || (it && (it.category||it.kategorie||it.cat)) || '';

      var ab = abbrFromCategory(catName);
      if (!ab){ ab = devFromTitle(title); }

      var chip = ensureChip(badge);
      var next = ab ? (ab==='VB'?'VBR':ab) : '';
      if ((chip.textContent||'') !== next){
        chip.textContent = next;
        if (catName) chip.title = 'Kategorie: ' + catName; else chip.removeAttribute('title');
      }
    }catch(_){}
  }

  function updateAll(){
    if (updateAll.__running) return;
    updateAll.__running = true;
    try{
      var cards = document.querySelectorAll('#cards .card');
      for (var i=0;i<cards.length;i++) updateCard(cards[i]);
    }finally{
      updateAll.__running = false;
    }
  }

  // Throttled scheduler
  var pending = false;
  function schedule(){ if (pending) return; pending = true;
    (window.requestAnimationFrame || function(fn){ return setTimeout(fn,16); })(function(){ pending=false; updateAll(); });
  }

  // Boot: retry kurzzeitig, bis Karten DOM steht
  (function boot(){
    var tries=0, max=80;
    function tick(){
      tries++;
      var haveCards = document.querySelectorAll('#cards .card').length>0;
      if (haveCards){ schedule(); }
      if (haveCards || tries>=max){ return; }
      setTimeout(tick, 100);
    }
    window.addEventListener('pageshow', schedule);
    window.addEventListener('load', schedule);
    setTimeout(tick, 80);
  })();

  // Kategorie-Select-Änderungen
  document.addEventListener('change', function(e){
    var t=e.target; var id=(t.id||'').toLowerCase(), nm=(t.name||'').toLowerCase();
    if (t.tagName==='SELECT' && (id.includes('category')||id.includes('kategorie')||nm.includes('category')||nm.includes('kategorie'))){
      schedule();
    }
    if (t.tagName==='INPUT' && t.type==='file'){ schedule(); }
  }, true);

  // Nach render()
  if (typeof window.render==='function' && !window.render.__lv37){
    var _r = window.render;
    window.render = function(){ var rv=_r.apply(this, arguments); schedule(); return rv; };
    window.render.__lv37 = true;
  }

  // Minimaler CSS-Rahmen für Chip
  if (!document.getElementById('lv37-chipcss')){
    var s=document.createElement('style'); s.id='lv37-chipcss';
    s.textContent = ".card>.badge{position:relative;padding-right:40px}.card>.badge .chip.cat{position:absolute;top:50%;right:10px;transform:translateY(-50%);padding:2px 8px;border-radius:999px;border:1px solid currentColor;background:transparent;font-size:11.5px;line-height:1;font-weight:600;opacity:.95;pointer-events:none}";
    (document.head||document.documentElement).appendChild(s);
  }
})();</script>


<script id="lv39-cat-dataset">
(function(){
  'use strict';
  function nrm(s){ return String(s||'').toLowerCase().trim()
    .replace(/[äÄ]/g,'ae').replace(/[öÖ]/g,'oe').replace(/[üÜ]/g,'ue'); }

  function getCategoryFromDOM(card){
    var attr = card.getAttribute('data-cat') || card.getAttribute('data-category') || card.getAttribute('data-kategorie');
    if (attr) return attr;
    var el = card.querySelector('[data-cat],[data-category],[data-kategorie], .category, .kategorie, [data-field="category"], [data-field="kategorie"], [data-key="category"], [data-key="kategorie"]');
    if (el && el.textContent) return el.textContent.trim();
    var text = card.textContent || '';
    if (text){
      var m = text.match(/Kategorie\s*:?\s*([A-Za-zÄÖÜäöüß\s\-]+)\b/);
      if (m && m[1]) return m[1].trim();
    }
    return '';
  }

  function getItemForCard(card){
    var title = (card.querySelector('h3')||{}).textContent || '';
    var id = card.getAttribute('data-id')||'';
    try{
      if (Array.isArray(window.items)){
        var it = (id ? window.items.find(function(x){ return String(x.id||'')===String(id); }) : null);
        if (!it){
          it = window.items.find(function(x){
            return nrm(x.name||x.title||x.bezeichnung||'') === nrm(title);
          });
        }
        return it || null;
      }
    }catch(_){}
    return null;
  }

  function assignDataCat(card){
    try{
      var cat = '';
      var it = getItemForCard(card);
      if (it) cat = it.category || it.kategorie || it.cat || '';
      if (!cat) cat = getCategoryFromDOM(card);
      if (cat){
        var cur = card.getAttribute('data-cat') || '';
        if (cur !== String(cat)){
          card.setAttribute('data-cat', String(cat));
        }
      }
    }catch(_){}
  }

  function run(){
    var cards = document.querySelectorAll('#cards .card');
    for (var i=0;i<cards.length;i++) assignDataCat(cards[i]);
  }

  var pending = false;
  function schedule(){ if (pending) return; pending = true;
    (window.requestAnimationFrame || function(fn){ return setTimeout(fn,16); })(function(){ pending=false; run(); });
  }

  // Hook in render()
  if (typeof window.render==='function' && !window.render.__lv39){
    var _r = window.render;
    window.render = function(){ var rv=_r.apply(this, arguments); schedule(); return rv; };
    window.render.__lv39 = true;
  }

  // Kategorie-Selects triggern Update
  document.addEventListener('change', function(e){
    var t=e.target; var id=(t.id||'').toLowerCase(), nm=(t.name||'').toLowerCase();
    if (t.tagName==='SELECT' && (id.includes('category')||id.includes('kategorie')||nm.includes('category')||nm.includes('kategorie'))){
      schedule();
    }
  }, true);

  // Initial kick
  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', schedule); }
  else { schedule(); }
})();</script>


<script id="lv40-selfcheck">
(function(){
  'use strict';
  var DEVSET = {WMZ:1, KWZ:1, WWZ:1, HKV:1, RWM:1};
  var UISHORT = { ZM:'ZM', VBR:'VBR', ME:'ME', WG:'WG' };

  function nrm(s){ return String(s||'').toLowerCase().trim()
    .replace(/[äÄ]/g,'ae').replace(/[öÖ]/g,'oe').replace(/[üÜ]/g,'ue'); }

  function abbrFromCategory(cat){
    if (!cat) return '';
    var raw = String(cat).trim();
    var upper = raw.toUpperCase();
    var lower = nrm(raw);
    if (DEVSET[upper]) return upper;
    if (UISHORT[upper]) return upper;
    if (upper === 'VB') return 'VBR';
    try{
      if (window.CAT_SHORT && typeof CAT_SHORT==='object'){
        var s = CAT_SHORT[raw] || CAT_SHORT[upper] || CAT_SHORT[lower];
        if (s) return (String(s).toUpperCase()==='VB'?'VBR':String(s).toUpperCase());
      }
    }catch(_){}
    var DEV_LONG = {
      'heizkostenverteiler':'HKV',
      'rauchwarnmelder':'RWM','rauchmelder':'RWM',
      'waermemengenzaehler':'WMZ','waermemengenzahler':'WMZ','waermenzaehler':'WMZ','waermezaehler':'WMZ','waermezahler':'WMZ',
      'kaltwasser':'KWZ','kaltwasserzaehler':'KWZ','kaltwasserzähler':'KWZ',
      'warmwasser':'WWZ','warmwasserzaehler':'WWZ','warmwasserzähler':'WWZ',
      'warmwasserzähler':'WWZ','kaltwasserzähler':'KWZ','wärmemengenzähler':'WMZ','wärmezähler':'WMZ'
    };
    if (DEV_LONG[lower]) return DEV_LONG[lower];
    var UI2SHORT = { 'zusatzmaterial':'ZM', 'verbrauchsmaterial':'VBR', 'messtechnik nord':'ME', 'werkzeug':'WG' };
    if (UI2SHORT[lower]) return UI2SHORT[lower];
    if (/^[A-Z]{2,4}$/.test(upper)) return upper;
    return '';
  }

  function devFromTitle(title){
    var U = String(title||'').toUpperCase().replace(/\s+/g,'');
    var t = nrm(title);
    if (U.indexOf('WMZ')>=0) return 'WMZ';
    if (U.indexOf('KWZ')>=0) return 'KWZ';
    if (U.indexOf('WWZ')>=0) return 'WWZ';
    if (U.indexOf('HKV')>=0) return 'HKV';
    if (U.indexOf('RWM')>=0) return 'RWM';
    if (t.indexOf('kaltwasser')>=0) return 'KWZ';
    if (t.indexOf('warmwasser')>=0) return 'WWZ';
    if (t.indexOf('heizkostenverteiler')>=0) return 'HKV';
    if (t.indexOf('rauchwarnmelder')>=0 || t.indexOf('rauchmelder')>=0) return 'RWM';
    if (t.indexOf('waermemengenzaehler')>=0 || t.indexOf('waermezaehler')>=0 || t.indexOf('waermenzaehler')>=0 || t.indexOf('waermemengenzahler')>=0 || t.indexOf('waermezahler')>=0) return 'WMZ';
    return '';
  }

  function sanitizeLabel(badge){
    var label = badge.querySelector('[data-role=\"status-label\"]');
    var cur;
    if (!label){
      cur = (badge.textContent||'').trim();
      label = document.createElement('span');
      label.setAttribute('data-role','status-label');
      while (badge.firstChild) badge.removeChild(badge.firstChild);
      badge.appendChild(label);
    } else {
      cur = (label.textContent||'').trim();
    }
    var m = String(cur).match(/^(Eingang gebucht|Ausgang gebucht|Ohne Datum)/i);
    label.textContent = m ? m[1] : cur;
    return label;
  }

  function ensureChip(badge){
    var chip = badge.querySelector('.chip.cat') || badge.querySelector('[data-role=\"cat-abbr\"]');
    var dups = badge.querySelectorAll('.chip.cat');
    for (var i=1;i<dups.length;i++) dups[i].remove();
    if (!chip){
      chip = document.createElement('span');
      chip.className = 'chip cat';
      chip.setAttribute('data-role','cat-abbr');
      badge.appendChild(chip);
    }
    return chip;
  }

  function expectedAbbr(card){
    var cat = card.getAttribute('data-cat') || card.getAttribute('data-category') || card.getAttribute('data-kategorie') || '';
    var ab = abbrFromCategory(cat);
    if (!ab){
      var title = (card.querySelector('h3')||{}).textContent || '';
      ab = devFromTitle(title);
    }
    return ab ? (ab==='VB'?'VBR':ab) : '';
  }

  function checkAndFixOnce(){
    var changed = false;
    var cards = document.querySelectorAll('#cards .card');
    for (var i=0;i<cards.length;i++){
      var card = cards[i];
      var badge = card.querySelector('.badge'); if (!badge) continue;
      var exp = expectedAbbr(card);
      var chip = badge.querySelector('.chip.cat') || badge.querySelector('[data-role=\"cat-abbr\"]');
      var cur = chip && (chip.textContent||'').trim() || '';
      if (cur !== exp){
        sanitizeLabel(badge);
        if (!chip){ chip = document.createElement('span'); chip.className='chip cat'; chip.setAttribute('data-role','cat-abbr'); badge.appendChild(chip); }
        chip.textContent = exp;
        if (exp){
          var cat = card.getAttribute('data-cat') || '';
          if (cat) chip.title = 'Kategorie: ' + cat; else chip.removeAttribute('title');
        } else {
          chip.removeAttribute('title');
        }
        changed = true;
      }
    }
    return changed;
  }

  var ran = false;
  function boot(){
    if (ran) return; ran = true;
    var tries = 0, max = 60;
    (function tick(){
      tries++;
      var haveCards = document.querySelectorAll('#cards .card').length > 0;
      if (haveCards){
        checkAndFixOnce();
        return;
      }
      if (tries < max) setTimeout(tick, 100);
    })();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot);
  } else { boot(); }
  window.addEventListener('pageshow', boot);
})();</script>



<script id="lv42-chip-clean">
(function(){
  'use strict';

  function isStatusChip(el){
    if (!el || !el.classList) return false;
    var cls = el.classList;
    // common status markers
    return cls.contains('ok') || cls.contains('alert') || cls.contains('status') || cls.contains('warn');
  }

  function isCategoryChip(el){
    if (!el) return false;
    if (el.getAttribute && el.getAttribute('data-role') === 'cat-abbr') return true;
    if (el.classList && el.classList.contains('cat')){
      // treat as category chip only if it's not an explicit status chip
      return !isStatusChip(el);
    }
    return false;
  }

  function cleanupBadge(badge){
    try{
      // Collect *category* chips only
      var all = badge.querySelectorAll('.chip, [data-role="cat-abbr"]');
      var catChips = [];
      for (var i=0;i<all.length;i++){
        if (isCategoryChip(all[i])) catChips.push(all[i]);
      }
      if (catChips.length === 0) return; // nothing to clean for category chips

      // Keep the first category chip as primary; remove other category duplicates
      var primary = catChips[0];
      // Ensure correct markers on primary (do not overwrite status classes)
      if (primary.classList){
        if (!primary.classList.contains('chip')) primary.classList.add('chip');
        if (!primary.classList.contains('cat')) primary.classList.add('cat');
      }
      if (primary.getAttribute) primary.setAttribute('data-role','cat-abbr');

      for (var j=1;j<catChips.length;j++){
        catChips[j].remove();
      }

      // Hide only the *category* chip if it is empty; never touch status chips
      var txt = (primary.textContent||'').trim();
      if (!txt){
        primary.style.display = 'none';
        primary.removeAttribute('title');
      } else {
        primary.style.display = '';
      }
    }catch(_){}
  }

  function run(){
    try{
      var badges = document.querySelectorAll('#cards .card .badge');
      for (var i=0;i<badges.length;i++) cleanupBadge(badges[i]);
    }catch(_){}
  }

  var pending = false;
  function schedule(){
    if (pending) return; pending = true;
    (window.requestAnimationFrame || function(fn){ return setTimeout(fn, 16); })(function(){ pending=false; run(); });
  }

  // Hook into render() once
  if (typeof window.render==='function' && !window.render.__lv42clean){
    var _r = window.render;
    window.render = function(){ var rv=_r.apply(this, arguments); schedule(); return rv; };
    window.render.__lv42clean = true;
  }

  // Kategorie-Selects trigger cleanup (nur Kategorie-Chips)
  document.addEventListener('change', function(e){
    var t=e.target; var id=(t.id||'').toLowerCase(), nm=(t.name||'').toLowerCase();
    if (t.tagName==='SELECT' && (id.includes('category')||id.includes('kategorie')||nm.includes('category')||nm.includes('kategorie'))) schedule();
  }, true);

  // Boot events
  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', schedule); } else { schedule(); }
  window.addEventListener('pageshow', schedule);
  window.addEventListener('load', schedule);
})();</script>


<script id="lv43-chip-guard">
(function(){
  'use strict';
  if (window.__lvChipGuard) return;
  window.__lvChipGuard = {
    isStatus: function(el){
      if (!el || !el.classList) return false;
      var c = el.classList;
      if (c.contains('ok')||c.contains('alert')||c.contains('status')||c.contains('warn')||c.contains('warning')||c.contains('danger')||c.contains('error')||c.contains('success')||c.contains('badge-status')) return true;
      var role = el.getAttribute && el.getAttribute('data-role');
      return role==='status' || role==='status-label';
    },
    isCat: function(el){
      if (!el) return false;
      if (el.getAttribute && el.getAttribute('data-role')==='cat-abbr') return true;
      return el.classList && el.classList.contains('cat') && !this.isStatus(el);
    },
    sanitizeBadge: function(badge){
      if (!badge) return;
      var chips = badge.querySelectorAll('.chip,[data-role]');
      for (var i=0;i<chips.length;i++){
        var el = chips[i];
        if (this.isStatus(el)){
          if (el.classList) el.classList.remove('cat');
          if (el.getAttribute && el.getAttribute('data-role')==='cat-abbr') el.removeAttribute('data-role');
        }
      }
    },
    run: function(){
      var badges = document.querySelectorAll('#cards .card .badge');
      for (var i=0;i<badges.length;i++) this.sanitizeBadge(badges[i]);
    }
  };
  function schedule(){ (window.requestAnimationFrame||function(f){return setTimeout(f,16)})(window.__lvChipGuard.run.bind(window.__lvChipGuard)); }
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', schedule); else schedule();
  window.addEventListener('pageshow', schedule);
  if (typeof window.render==='function' && !window.render.__lv43guard){
    var _r=window.render; window.render=function(){ var rv=_r.apply(this, arguments); schedule(); return rv; }; window.render.__lv43guard=true;
  }
})();</script>





<script id="lv48-history-final">
(function(){
  'use strict';
  function nrm(s){ return String(s||'').trim().toLowerCase()
    .replace(/[äÄ]/g,'ae').replace(/[öÖ]/g,'oe').replace(/[üÜ]/g,'ue'); }

  function findHistoryTables(){
    var t = Array.prototype.slice.call(document.querySelectorAll('table'));
    return t.filter(function(tb){
      var hs = Array.prototype.map.call(tb.querySelectorAll('thead th, tr th'), function(th){ return (th.textContent||'').trim().toLowerCase(); });
      if (!hs.length) return false;
      return hs.includes('aktion') && hs.includes('info');
    });
  }
  function headerIdx(tb){
    var idx={aktion:-1,artikel:-1,info:-1};
    if (!tb) return idx;
    var ths = tb.querySelectorAll('thead th, tr th');
    for (var i=0;i<ths.length;i++){
      var t = (ths[i].textContent||'').trim().toLowerCase();
      if (t==='aktion') idx.aktion=i;
      else if (t==='artikel') idx.artikel=i;
      else if (t==='info') idx.info=i;
    }
    return idx;
  }

  function replaceExactTextIn(el){
    if (!el) return;
    var walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);
    var nodes=[], n;
    while(n=walker.nextNode()) nodes.push(n);
    for (var i=0;i<nodes.length;i++){
      var txt = nodes[i].nodeValue;
      var trimmed = txt.trim();
      if (trimmed==='Zugang') nodes[i].nodeValue = txt.replace('Zugang','Eingang');
      else if (trimmed==='Entnahme') nodes[i].nodeValue = txt.replace('Entnahme','Ausgang');
      else if (/^Typ:\s*Zugang$/i.test(trimmed)) nodes[i].nodeValue = txt.replace(/Zugang$/,'Eingang');
      else if (/^Typ:\s*Entnahme$/i.test(trimmed)) nodes[i].nodeValue = txt.replace(/Entnahme$/,'Ausgang');
    }
  }

  function parseCat(text){
    var m = text.match(/kategorie\s*:?\s*(.*?)\s*(?:→|->)\s*(.*?)\s*$/i);
    if (!m) return null;
    var left  = (m[1]||'').replace(/^[–—-]+$/,'').trim();
    var right = (m[2]||'').trim();
    return {from:left,to:right};
  }

  function shouldHideRowByInfo(infoCell, aktionCell){
    var t = (infoCell.textContent||'').trim();
    // 1) reine Kategorie-Noise?
    if (/kategorie/i.test(t)){
      var ch = parseCat(t); if (!ch) return false;
      var from=nrm(ch.from), to=nrm(ch.to);
      var isDash = !from || from==='-' || from==='–' || from==='—';
      if (from===to || isDash) return true;
      // zusätzlich: wenn Aktion eine Mengenänderung ist, blende "Kategorie:" generell aus
      var a = (aktionCell && (aktionCell.textContent||'').trim().toLowerCase()) || '';
      if (a==='edit' || a==='qty' || a==='mengenänderung') return true;
    }
    return false;
  }

  function patchTable(tb){
    var idx = headerIdx(tb);
    var rows = tb.querySelectorAll('tbody tr');
    for (var r=0;r<rows.length;r++){
      var cells = rows[r].children;
      var cAk = idx.aktion>=0 ? cells[idx.aktion] : null;
      var cIn = idx.info>=0   ? cells[idx.info]   : null;
      if (cAk) replaceExactTextIn(cAk);
      if (cIn) replaceExactTextIn(cIn);
      if (cIn && shouldHideRowByInfo(cIn, cAk)){
        rows[r].style.display = 'none';
      }
    }
  }

  function applyOnce(){
    var tbs = findHistoryTables();
    for (var i=0;i<tbs.length;i++){
      (function(tb){
        if (!tb) return;
        patchTable(tb);
        if (!tb.__lv48Obs){
          var pending=false;
          var obs = new MutationObserver(function(){
            if (pending) return; 
            pending=true;
            (window.requestAnimationFrame||function(f){return setTimeout(f,16)})(function(){
              pending=false;
              try{ patchTable(tb); }catch(_){}
            });
          });
          var target = (tb.tBodies && tb.tBodies.length ? tb.tBodies[0] : tb);
          obs.observe(target, {childList:true, subtree:true, characterData:true});
          tb.__lv48Obs = obs;
        }
      })(tbs[i]);
    }
    injectAdminClear();
  }

  // ---- Admin: Historie löschen (nur wenn lv_admin==='1' oder window.isAdmin===true) ----
  function isAdmin(){
    try{
      if (typeof window.has === 'function'){
        try{
          if (window.has('manage_settings') || window.has('manage_users') || window.has('backup')) return true;
        }catch(_){}
      }
      if (localStorage.getItem('lv_admin')==='1') return true;
      if (window.isAdmin===true) return true;
      if (window.user && (window.user.role==='admin' || window.user.isAdmin)) return true;
    }catch(e){}
    return false;
  }
  function clearHistory(){
    try{
      var allowed = false;
      if (typeof hasRight==='function'){ allowed = !!hasRight('clear_history'); }
      else if (typeof has==='function'){ allowed = !!has('clear_history'); }
      else if (window.currentPerms){ allowed = !!window.currentPerms.clear_history; }
      if (!allowed && (typeof isAdmin==='function' && isAdmin())) allowed = true;
      if (!allowed){ if(typeof toast==='function') toast('Keine Berechtigung'); else alert('Keine Berechtigung'); return; }
    }catch(_){ }if (!isAdmin()) return;
    if (!confirm('Historie wirklich löschen?')) return;
    try{ if (Array.isArray(window.historyEntries)) window.historyEntries.length = 0; }catch(_){}
    try{ if (typeof window.renderHistory==='function') window.renderHistory([]); }catch(_){}
    try{
      ['history','verlauf','historyEntries','history_entries','log'].forEach(function(k){
        try{ localStorage.removeItem(k) }catch(_){}
      });
    }catch(_){}
    try{
      if (Array.isArray(window.items) && typeof window.saveJson==='function' && window.storageKey){
        window.items.forEach(function(it){
          if (!it) return;
          if (Array.isArray(it.log)) it.log.length = 0;
          else if (it.log) it.log = [];
        });
        try{ window.saveJson(window.storageKey, window.items); }catch(_){}
        if (typeof window.render==='function') window.render();
      }
      var hc = document.getElementById('histCount');
      if (hc) hc.textContent = '0 Einträge';
    }catch(_){}
    var tbs = findHistoryTables();
    tbs.forEach(function(tb){ var b = tb.tBodies && tb.tBodies[0]; if (b) b.innerHTML=''; });
    alert('Historie gelöscht.');
  }
  function injectAdminClear(){
    var dlg = document.getElementById('historyDlg');
    if (!dlg) return;
    var clearBtn = dlg.querySelector('#btnHistoryClear');
    if (clearBtn){
      try{
        var allowed = false;
        if (typeof hasRight==='function'){ allowed = !!hasRight('clear_history'); }
        else if (typeof has==='function'){ allowed = !!has('clear_history'); }
        else if (window.currentPerms){ allowed = !!window.currentPerms.clear_history; }
        if (!allowed && (typeof isAdmin==='function' && isAdmin())) allowed = true;
        if (!allowed){ clearBtn.style.display = 'none'; return; }
      }catch(_){ clearBtn.style.display='none'; return; }
      if (!clearBtn.__lv48wired){
        clearBtn.addEventListener('click', clearHistory);
        clearBtn.__lv48wired = true;
      }
      clearBtn.style.display = '';
      return;
    }
    // Fallback für alte Layouts ohne festen Button: Header-Button nur für Admins injizieren
    if (!isAdmin()) return;
    var header = dlg.querySelector('header');
    if (!header || header.__lv48btn) return;
    var btn = document.createElement('button');
    btn.className = 'btn';
    btn.style.cssText = 'padding:6px 10px;margin-left:8px';
    btn.type='button';
    btn.textContent = 'Historie löschen';
    btn.addEventListener('click', clearHistory);
    header.insertBefore(btn, header.querySelector('button.btn.primary, #btnHistoryOk, #btnHistoryClose') || header.lastChild);
    header.__lv48btn = btn;
  }

  function schedule(){ (window.requestAnimationFrame||function(f){return setTimeout(f,16)})(applyOnce); }

  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', schedule); } else { schedule(); }
  window.addEventListener('pageshow', schedule);
  window.addEventListener('load', schedule);
  if (typeof window.render==='function' && !window.render.__lv48hist){
    var _r = window.render; window.render=function(){ var rv=_r.apply(this, arguments); schedule(); return rv; }; window.render.__lv48hist=true;
  }
  document.addEventListener('click', function(e){
    var t=e.target && e.target.closest && e.target.closest('button,a,[role=\"button\"],.link');
    if (!t) return;
    var tx = (t.textContent||'').toLowerCase();
    if (tx.includes('historie')||tx.includes('verlauf')||t.id==='openHistory') schedule();
  }, true);
  document.addEventListener('change', function(e){
    var t=e.target;
    if (t && (t.tagName==='SELECT' || (t.tagName==='INPUT' && (t.type==='search'||t.type==='text'||t.type==='date')))) schedule();
  }, true);
})();</script>


<!-- v26: independent selftest script -->
<script>
(function(){
  window.cloudSelftest = async function(){
    try{
      var out = document.getElementById('cloudSelftestResult');
      if(!out){
        var btn = document.getElementById('btnCloudSelftest');
        out = document.createElement('div'); out.id='cloudSelftestResult'; out.className='hint'; out.style.marginTop='8px';
        if(btn && btn.parentElement){ btn.parentElement.appendChild(out); }
      }
      if(out) out.textContent = 'Prüfe Verbindung...';
      function line(kind, label, msg){
        var dot = '<span class="lv-dot lv-dot-'+kind+'"></span>';
        return '<div>'+dot+'<strong>'+label+':</strong> '+msg+'</div>';
      }
      var html = [];
      var __cfg = (typeof readBrConfig==='function') ? readBrConfig() : null;
var url = (__cfg && __cfg.url ? String(__cfg.url) : '').trim();
      var tok = (__cfg && __cfg.token ? String(__cfg.token) : '').trim();
      html.push(line(url? 'ok':'err', 'URL', url? 'gesetzt' : 'fehlt'));
      html.push(line(tok? 'ok':'err', 'Token', tok? 'gesetzt' : 'fehlt'));
      async function testTbl(id, label){
        if(!id){ html.push(line('warn', label, 'keine ID gesetzt')); return; }
        if(typeof brListAll !== 'function'){ html.push(line('warn', label, 'API-Wrapper nicht geladen')); return; }
        try{
          var rows = await brListAll(id, { size: 1 });
          var n = Array.isArray(rows)? rows.length : (rows && rows.results ? rows.results.length : 0);
          html.push(line('ok', label, 'lesbar ('+(n||0)+' Zeilen)'));
        }catch(e){
          html.push(line('err', label, 'Fehler: '+(e && e.message ? e.message : String(e))));
        }
      }
      var itemsId   = (__cfg && __cfg.tblItems ? String(__cfg.tblItems) : '').trim();
      var groupsId  = (__cfg && __cfg.tblGroups ? String(__cfg.tblGroups) : '').trim();
      var membersId = (__cfg && __cfg.tblMembers ? String(__cfg.tblMembers) : '').trim();
      var backupsId = (__cfg && __cfg.tblBackups ? String(__cfg.tblBackups) : '').trim();
      await testTbl(itemsId,   'Items');
      await testTbl(groupsId,  'Gruppen');
      await testTbl(membersId, 'Mitglieder');
      await testTbl(backupsId, 'Backups');
      html.push('<div style="margin-top:6px">'+(html.join('').includes('lv-dot-err')?'Gesamt: FEHLER':'Gesamt: OK')+'</div>'); var _summary = (html.join('').indexOf('Gesamt: ')>=0) ? '' : '<div style="margin-top:6px">'+(html.join('').includes('lv-dot-err')?'Gesamt: FEHLER':'Gesamt: OK')+'</div>'; if(_summary) html.push(_summary); if(out) out.innerHTML = html.join('');
    }catch(e){
      try{
        var out = document.getElementById('cloudSelftestResult');
        if(out) out.textContent = 'Selbsttest-Fehler: '+(e && e.message ? e.message : String(e));
      }catch(_){}
    }
  };
})();</script>


<!-- v28: startup login check (no overlay) -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  try {
// (legacy) requirePwKey 'lagerverwaltung_requirePw' replaced by 'lagerverwaltung_require_pw'
var sessionKey = 'lagerverwaltung_session_email'; // v26 uses _email; keep for compatibility
    // Passwort-Anmeldung immer erforderlich
    try { localStorage.setItem(requirePwKey, '1'); } catch(_){ }
    var requirePw = true;
    var storedEmail = (localStorage.getItem(sessionKey)||sessionStorage.getItem(sessionKey)||'').trim();
    var hasSession = !!storedEmail;
    // Auto-Login wiederherstellen, wenn "angemeldet bleiben" aktiv war
    if(hasSession){
      try {
        var remembered = !!localStorage.getItem(sessionKey);
        setSession(storedEmail, remembered);
      } catch(_){ /* falls setSession fehlschlägt, nicht blockieren */ }
    }
    if(requirePw && !hasSession){
      var dlg = document.getElementById('login');
      if(dlg){ try{ dlg.showModal(); }catch(_){ dlg.open=true; } }
    }
  } catch(e) { console && console.warn('startup login check failed', e); }
});</script>


<!-- v30: Passwort-Dialog -->
<dialog id="pwDlg" class="card" style="max-width:420px">
  <h3>Passwort setzen</h3>
  <div class="hint">Benutzer: <strong id="pwUserLabel"></strong></div>
  <div class="row">
    <label>Neues Passwort</label>
    <input id="pwNew" type="password" autocomplete="new-password" placeholder="Neues Passwort">
  </div>
  <div class="row">
    <label>Wiederholen</label>
    <input id="pwRepeat" type="password" autocomplete="new-password" placeholder="Passwort wiederholen">
  </div>
  <div class="row">
    <label><input type="checkbox" id="pwShow"> Anzeigen</label>
    <button class="btn" id="pwGen" type="button">Zufällig</button>
  </div>
  <div class="row right">
    <button class="btn" id="btnPwCancel" type="button">Abbrechen</button>
    <button class="btn ok" id="btnPwSave" type="button">Speichern</button>
  </div>
</dialog>


<!-- v30: Passwort-Dialog Logik -->
<script>
(function(){
  var currentPwUser = null;
  function randString(n){
    var chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789!@#$%';
    var out = ''; var a = new Uint8Array(n); crypto.getRandomValues(a);
    for(var i=0;i<n;i++){ out += chars[a[i] % chars.length]; }
    return out;
  }
  function showPwDlg(username){
    currentPwUser = (username||'').trim();
    document.getElementById('pwUserLabel').textContent = currentPwUser || '—';
    document.getElementById('pwNew').value = '';
    document.getElementById('pwRepeat').value = '';
    document.getElementById('pwShow').checked = false;
    try{ document.getElementById('pwDlg').showModal(); }catch(_){ document.getElementById('pwDlg').open = true; }
  }
  window.__openPwForUser = showPwDlg;

  function updatePwVisibility(){
    var t = document.getElementById('pwShow').checked ? 'text' : 'password';
    document.getElementById('pwNew').type = t;
    document.getElementById('pwRepeat').type = t;
  }
  document.addEventListener('DOMContentLoaded', function(){
    var sh = document.getElementById('pwShow'); if(sh) sh.addEventListener('change', updatePwVisibility);
    var gn = document.getElementById('pwGen'); if(gn) gn.addEventListener('click', function(){
      var s = randString(14);
      document.getElementById('pwNew').value = s;
      document.getElementById('pwRepeat').value = s;
      updatePwVisibility();
    });
    var cancel = document.getElementById('btnPwCancel'); if(cancel) cancel.addEventListener('click', function(){
      try{ document.getElementById('pwDlg').close(); }catch(_){ document.getElementById('pwDlg').open=false; }
    });
    var save = document.getElementById('btnPwSave'); if(save) save.addEventListener('click', async function(){
      var a = document.getElementById('pwNew').value||'';
      var b = document.getElementById('pwRepeat').value||'';
      if(a.length < 4){ alert('Bitte mindestens 4 Zeichen.'); return; }
      if(a !== b){ alert('Passwörter stimmen nicht überein.'); return; }
      if(!currentPwUser){ alert('Kein Benutzer gewählt.'); return; }
      var m = (members||[]).find(function(x){ return (x.username||'').toLowerCase()===currentPwUser.toLowerCase(); });
      if(!m){ alert('Benutzer nicht gefunden.'); return; }
      var saltBytes = new Uint8Array(16); crypto.getRandomValues(saltBytes);
      var salt = Array.from(saltBytes).map(function(b){ return b.toString(16).padStart(2,'0'); }).join('');
      try{
        var hash = await pbkdf2Hash(String(a), salt, 200000);
        m.pw_salt = salt; m.pw_hash = String(hash);
        saveJson(membersKey, members);
        if(typeof refreshMembersUI==='function') try{ refreshMembersUI(); }catch(_){}
        try{ document.getElementById('pwDlg').close(); }catch(_){ document.getElementById('pwDlg').open=false; }
        if(typeof pushMembersOnly==='function') try{ pushMembersOnly(); }catch(_){}
        if(typeof toast==='function') try{ toast('Passwort aktualisiert für '+currentPwUser); }catch(_){}
      }catch(e){
        console && console.error('Hash error', e);
        alert('Fehler beim Hashen des Passworts.');
      }
    });
  });

  // Hook: ersetze prompt durch Dialog-Button
  var _oldRefresh = window.refreshMembersUI;
  window.refreshMembersUI = function(){
    if(typeof _oldRefresh==='function') _oldRefresh();
    try{
      var tbl = document.getElementById('membersTable');
      if(!tbl) return;
      var rows = tbl.querySelectorAll('tbody tr');
      rows.forEach(function(tr){
        var cells = tr.querySelectorAll('td');
        if(cells.length>=5){
          var pwCell = cells[cells.length-2];
          var btn = pwCell.querySelector('button');
          var uname = (tr.getAttribute('data-username') || (cells[0] && cells[0].textContent) || '').trim();
          if(btn && !btn.__lv_pwdlg){
            btn.textContent = 'Setzen / Ändern';
            btn.onclick = function(){ __openPwForUser(uname); };
            btn.__lv_pwdlg = true;
          }
        }
      });
    }catch(_){}
  };
})();</script>


<!-- v31: Konto-Dialog -->



<!-- v32: Konto-Register & Sicherheit Logik -->
<script>
(function(){
  function can(key){
    try{
      var u = (window.currentUser && currentUser && currentUser()) || (localStorage.getItem('lagerverwaltung_session_email')||sessionStorage.getItem('lagerverwaltung_session_email')||'').trim();
      var pp = (window.computePermsFor && computePermsFor(u)) || {};
      var p = pp.perm || pp.perms || {};
      return !!p[key];
    }catch(_){ return false; }
  }
  function showHide(id, vis){ var el = document.getElementById(id); if(el) el.style.display = vis ? '' : 'none'; }
  function randString(n){
    var chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789!@#$%';
    var out = ''; var a = new Uint8Array(n); crypto.getRandomValues(a);
    for(var i=0;i<n;i++){ out += chars[a[i] % chars.length]; }
    return out;
  }

  document.addEventListener('DOMContentLoaded', function(){
    var allowSelf = can('account.password.set_self');
    showHide('secAccount', allowSelf);

    try{
      var sec = document.getElementById('secSecurity');
      if(sec){ sec.style.display = can('security.requirePw.manage') ? 'block' : 'none'; }
      var lo = document.getElementById('btnLogout');
      if(lo){ lo.style.display = can('session.logout') ? '' : 'none'; }
    }catch(_){}

    var pwNew   = document.getElementById('accPwNew');
    var pwRep   = document.getElementById('accPwRepeat');
    var pwShow  = document.getElementById('accPwShow');
    var pwGen   = document.getElementById('accPwGen');
    var pwSave  = document.getElementById('accPwSave');

    if(pwShow){
      pwShow.addEventListener('change', function(){
        var t = pwShow.checked ? 'text' : 'password';
        if(pwNew) pwNew.type = t;
        if(pwRep) pwRep.type = t;
      });
    }
    if(pwGen){
      pwGen.addEventListener('click', function(){
        var s = randString(14);
        if(pwNew) pwNew.value = s;
        if(pwRep) pwRep.value = s;
      });
    }
    if(pwSave){
      pwSave.addEventListener('click', async function(){
        if(!allowSelf){ alert('Keine Berechtigung.'); return; }
        var a = (pwNew && pwNew.value) || '';
        var b = (pwRep && pwRep.value) || '';
        if(a.length < 4){ alert('Bitte mindestens 4 Zeichen.'); return; }
        if(a !== b){ alert('Passwörter stimmen nicht überein.'); return; }
        var u = (window.currentUser && currentUser && currentUser()) || (localStorage.getItem('lagerverwaltung_session_email')||sessionStorage.getItem('lagerverwaltung_session_email')||'').trim();
        if(!u){ alert('Kein Benutzer angemeldet.'); return; }
        var m = (window.members||[]).find(function(x){ return (x.username||'').toLowerCase()===u.toLowerCase(); });
        if(!m){ alert('Benutzer nicht gefunden.'); return; }
        try{
          var saltBytes = new Uint8Array(16); crypto.getRandomValues(saltBytes);
          var salt = Array.from(saltBytes).map(function(b){ return b.toString(16).padStart(2,'0'); }).join('');
          var hash = await pbkdf2Hash(String(a), salt, 200000);
          m.pw_salt = salt; m.pw_hash = String(hash);
          if(typeof refreshMembersUI==='function') try{ refreshMembersUI(); }catch(_){}
          if(typeof pushMembersOnly==='function') try{ pushMembersOnly(); }catch(_){}
          if(typeof toast==='function') try{ toast('Passwort aktualisiert'); }catch(_){}
          if(pwNew) pwNew.value=''; if(pwRep) pwRep.value=''; if(pwShow) pwShow.checked=false;
        }catch(e){
          console && console.error('Hash error', e); alert('Fehler beim Hashen.');
        }
      });
    }
  });
})();</script>


<!-- v39: Move requirePw into 'Benutzergruppen & Rechte' -->
<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var box = document.getElementById('secGroupsPerms');
    var cont = document.getElementById('groupsPermsContainer');
    if(!box || !cont) return;

    var labels = Array.prototype.slice.call(document.querySelectorAll('label'));
    var targetRow = null;
    labels.forEach(function(l){
      var t = (l.textContent||'').replace(/\s+/g,' ').trim();
      if(/Passwort.*Anmeldung.*erforderlich/i.test(t)){
        var r = l.closest && l.closest('.row');
        if(r) targetRow = r;
      }
    });

    if(targetRow){
      var cb = targetRow.querySelector('input[type="checkbox"]');
      if(cb && !cb.id) cb.id = 'requirePwChk';

      var hint = targetRow.nextElementSibling;
      if(hint && hint.classList && hint.classList.contains('hint')){
        hint.innerHTML = (hint.innerHTML||'').replace(/\(E-?Mail\)/ig, '(Benutzername)');
      }

      cont.appendChild(targetRow);
      if(hint && hint.classList && hint.classList.contains('hint')) cont.appendChild(hint);

      if (typeof window.can === 'function'){
        box.style.display = can('security.requirePw.manage') ? 'block' : 'none';
      }
    }
  }catch(e){ /* silent */ }

  ['secSession','secAccount','secGroupsPerms','secSecurity'].forEach(function(id){
    var det = document.getElementById(id); if(det) det.open = false;
  });
});</script>

<!-- v40: PW-Dialog absolute Absicherung -->
<script>
(function(){
  if (window.__pwHardGuard_v40) return;
  window.__pwHardGuard_v40 = true;

  function has(el){ return !!document.getElementById(el); }
  function dlg(){ return document.getElementById('pwDlg'); }

  function hideDlg(){
    var d = dlg(); if(!d) return;
    try{ d.close(); }catch(_){ d.open = false; }
    d.classList.remove('lv-visible');
  }
  function showDlg(){
    var d = dlg(); if(!d) return;
    d.classList.add('lv-visible');
    try{ d.showModal(); }catch(_){ d.open = true; }
  }

  // Gate
  window.__pwGate2 = window.__pwGate2 || { allow:false, t:0 };
  function armGate(ms){
    window.__pwGate2.allow = true;
    window.__pwGate2.t = Date.now();
    setTimeout(function(){ window.__pwGate2.allow = false; }, ms || 1500);
  }

  // Wrap __openPwForUser
  var oldOpen = window.__openPwForUser;
  window.__openPwForUser = function(username){
    armGate(1500);
    if (typeof oldOpen === 'function') { return oldOpen(username); }
    if (typeof window.showPwDlg === 'function') return window.showPwDlg(username);
    showDlg();
  };

  // Wrap showPwDlg
  var origShow = window.showPwDlg;
  window.showPwDlg = function(username){
    if (window.__pwGate2 && window.__pwGate2.allow){
      if (typeof origShow === 'function') return origShow(username);
      return showDlg();
    }
    hideDlg();
  };

  // Harden the dialog's showModal directly
  document.addEventListener('DOMContentLoaded', function(){
    var d = dlg();
    if (!d) return;

    hideDlg(); // ensure hidden at start

    var orig = d.showModal;
    if (typeof orig === 'function'){
      d.showModal = function(){
        if (window.__pwGate2 && window.__pwGate2.allow){
          d.classList.add('lv-visible');
          return orig.call(d);
        } else {
          hideDlg();
        }
      };
    }

    // If someone toggles 'open' attribute directly, enforce guard
    try{
      var mo = new MutationObserver(function(){
        if (d.open && !(window.__pwGate2 && window.__pwGate2.allow && d.classList.contains('lv-visible'))){
          hideDlg();
        }
      });
      mo.observe(d, { attributes:true, attributeFilter:['open','class'] });
    }catch(_){}
    var settings = document.getElementById('settings');
    if (settings){
      settings.addEventListener('close', hideDlg);
    }
  });

  // Keep settings sections collapsed when opening settings
  document.addEventListener('DOMContentLoaded', function(){
    ['secSession','secAccount','secGroupsPerms','secSecurity'].forEach(function(id){
      var det = document.getElementById(id); if(det) det.open = false;
    });
  });
})();</script>






<script>
(function(){
  function byId(id){ return document.getElementById(id); }

  function showAdminPinInline(){
    return new Promise(function(resolve){
      var box = byId('adminPinInline');
      var input = byId('adminPinInput');
      var ok = byId('adminPinOk');
      var cancel = byId('adminPinCancel');

      if(!box || !input || !ok || !cancel){
        resolve(true);
        return;
      }

      function cleanup(result){
        ok.removeEventListener('click', onOk);
        cancel.removeEventListener('click', onCancel);
        input.removeEventListener('keydown', onKey);
        box.style.display = 'none';
        resolve(result);
      }

      function onOk(){
        var val = (input.value || '').trim();
        if(val === '8283'){
          cleanup(true);
        } else {
          input.classList.add('shake');
          setTimeout(function(){ input.classList.remove('shake'); }, 250);
          input.focus();
          if(input.select) input.select();
        }
      }

      function onCancel(){
        cleanup(false);
      }

      function onKey(ev){
        if(ev.key === 'Enter'){
          ev.preventDefault();
          onOk();
        } else if(ev.key === 'Escape'){
          ev.preventDefault();
          onCancel();
        }
      }

      ok.addEventListener('click', onOk);
      cancel.addEventListener('click', onCancel);
      input.addEventListener('keydown', onKey);

      box.style.display = 'block';
      input.value = "";
      setTimeout(function(){
        try { input.focus(); } catch(e){}
      }, 0);
    });
  }

  document.addEventListener('DOMContentLoaded', function(){
    var btn = byId('btnLoginAdminLocal');
    if(!btn) return;
    if(btn.__lv_pin_guard) return;
    btn.__lv_pin_guard = true;

    btn.addEventListener('click', function(ev){
      if(btn.__lv_pin_allow_once){
        btn.__lv_pin_allow_once = false;
        return;
      }
      ev.preventDefault();
      ev.stopImmediatePropagation();

      showAdminPinInline().then(function(ok){
        if(ok){
          btn.__lv_pin_allow_once = true;
          btn.click();
        }
      });
    }, true);
  });
})();</script>



  <script>
  // vLoginGuard: Login-Dialog darf bei aktivierter Passwortpflicht nicht einfach geschlossen werden
  (function(){
    function guardLoginDialog(){
      var dlg = document.getElementById('login');
      var btn = document.getElementById('btnLoginClose');
      if(!dlg){ return; }
      // Schließen-Button abfangen
      if(btn && !btn.__lv_guard){
        btn.__lv_guard = true;
        btn.addEventListener('click', function(ev){
          ev.preventDefault();
          ev.stopImmediatePropagation();
          try{
            if(typeof requireLoginNow === 'function' && requireLoginNow()){
              if(typeof toast === 'function'){
                toast('Bitte anmelden, um fortzufahren.');
              }
              // Dialog bleibt offen
              return;
            }
          }catch(_){}
          // Wenn keine Passwortpflicht aktiv ist, darf der Dialog geschlossen werden
          try{ dlg.close(); } catch(e){ dlg.open = false; }
        }, true);
      }
      // Escape / Klick auf Hintergrund: cancel-Event blocken, wenn Login Pflicht
      dlg.addEventListener('cancel', function(ev){
        try{
          if(typeof requireLoginNow === 'function' && requireLoginNow()){
            ev.preventDefault();
            if(typeof toast === 'function'){
              toast('Bitte anmelden, um fortzufahren.');
            }
          }
        }catch(_){}
      });
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', guardLoginDialog);
    }else{
      guardLoginDialog();
    }
  })();</script>

  <script>
  // vAddMemberFix: robustes Anlegen von Benutzern nur über Benutzernamen
  (function(){
    function bindAddMember(){
      var btn = document.getElementById('btnAddMember');
      if(!btn || btn.__lv_fix_add) return;
      btn.__lv_fix_add = true;
      btn.addEventListener('click', function(ev){
        try{
          if(typeof has === 'function' && !has('manage_users')){
            if(typeof toast === 'function') toast('Keine Berechtigung');
            return;
          }
          var unameInput = document.getElementById('memberUsername');
          var groupSel = document.getElementById('memberGroup');
          var uname = (unameInput && unameInput.value || '').trim();
          var gid = groupSel ? (groupSel.value || null) : null;
          if(!uname){
            if(typeof toast === 'function') toast('Benutzername eingeben');
            return;
          }
          if(!Array.isArray(window.members)) window.members = [];
          var exists = window.members.find(function(x){
            return String(x.username||'').toLowerCase() === uname.toLowerCase();
          });
          if(exists){
            if(typeof toast === 'function') toast('Benutzername existiert bereits');
            return;
          }
          var m = { username: uname, group_id: gid, perm:{}, pw_salt:null, pw_hash:null };
          window.members.push(m);
          try{
            if(typeof refreshMembersUI === 'function') refreshMembersUI();
          }catch(_){}
          try{
            if(typeof maybeCloudPushMembers === 'function') maybeCloudPushMembers();
          }catch(_){}
          if(typeof toast === 'function') toast('Benutzer erfasst');
        }catch(e){
          try{ console.error(e); }catch(_){}
          if(typeof toast === 'function') toast('Fehler beim Anlegen des Benutzers');
        }
      });
    }
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', bindAddMember);
    }else{
      bindAddMember();
    }
  })();</script>

<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('sw.js').catch(function(err){
        console && console.warn && console.warn('SW registration failed', err);
      });
    });
  }
</script>

<script>
/* v51 – Remember-Login robust bei duplizierter #loginRemember */
(function(){
  try{
    function allRememberInputs(){
      try{ return Array.prototype.slice.call(document.querySelectorAll('#loginRemember')); }
      catch(e){ return []; }
    }
    function anyRememberChecked(){
      var boxes = allRememberInputs();
      for (var i=0;i<boxes.length;i++){ if (!!boxes[i].checked) return true; }
      return false;
    }
    function installSync(){
      var boxes = allRememberInputs();
      if (boxes.length > 1){
        boxes.forEach(function(box){
          if (box.__lv51_sync) return;
          box.__lv51_sync = true;
          box.addEventListener('change', function(){
            var v = !!this.checked;
            allRememberInputs().forEach(function(b){ if (b !== box) b.checked = v; });
          }, {passive:true});
        });
      }
    }
    document.addEventListener('DOMContentLoaded', installSync);
    var mo = new MutationObserver(installSync);
    mo.observe(document.documentElement || document.body, {subtree:true, childList:true});

    if (typeof window.tryLogin === 'function' && !window.tryLogin__v51){
      var _orig = window.tryLogin;
      window.tryLogin__v51 = true;
      window.tryLogin = function(loginId, password){
        var remember = anyRememberChecked();
        var p;
        try { p = _orig(loginId, password); } catch(e){ throw e; }
        if (!p || typeof p.then !== 'function'){ p = Promise.resolve(p); }
        return p.then(function(res){
          try{
            if (typeof window.setSession === 'function'){
              var userId = (typeof window.currentUserEmail === 'string' && window.currentUserEmail) ? window.currentUserEmail : loginId;
              window.setSession(userId, remember);
            }
          }catch(_){}
          return res;
        });
      };
    }
  }catch(e){}
})();</script>


<script>
/* v52 – Sitzung-Label + Status-Refresh (nicht-invasiv) */
(function(){
  try{
    var SESSION_KEY_KNOWN = 'lagerverwaltung_session_email';
    function detectSessionKey(){
      try {
        if (localStorage.getItem(SESSION_KEY_KNOWN) !== null || sessionStorage.getItem(SESSION_KEY_KNOWN) !== null){
          return SESSION_KEY_KNOWN;
        }
        for (var i=0;i<localStorage.length;i++){
          var k = localStorage.key(i)||'';
          if (/lagerverwaltung.*session.*email/i.test(k)) return k;
        }
        for (var j=0;j<sessionStorage.length;j++){
          var k2 = sessionStorage.key(j)||'';
          if (/lagerverwaltung.*session.*email/i.test(k2)) return k2;
        }
      } catch(e){}
      return SESSION_KEY_KNOWN;
    }
    var SESSION_KEY = detectSessionKey();

    function readSession(){
      var user = null, persistent = false;
      try {
        var l = localStorage.getItem(SESSION_KEY);
        var s = sessionStorage.getItem(SESSION_KEY);
        if (l != null){ user = l; persistent = true; }
        else if (s != null){ user = s; persistent = false; }
      } catch(e){}
      return { user: user, persistent: persistent };
    }

    function ensureSessionUI(){
      var parent = document.getElementById('sessionPersist');
      if (!parent){ parent = document.querySelector('#settings, #einstellungen, body'); }
      else { parent = parent.parentNode || parent; }
      if (!document.getElementById('sessionLabel')){
        var span = document.createElement('span');
        span.id = 'sessionLabel';
        span.className = 'chip';
        span.textContent = 'Angemeldet: —';
        if (parent && parent.insertBefore){
          parent.insertBefore(span, parent.firstChild ? parent.firstChild.nextSibling : null);
        } else {
          (document.body||document.documentElement).appendChild(span);
        }
      }
      if (!document.getElementById('sessionStatusRefresh')){
        var btn = document.createElement('button');
        btn.id = 'sessionStatusRefresh';
        btn.type = 'button';
        btn.textContent = 'Status aktualisieren';
        btn.style.marginLeft = '0.5rem';
        btn.className = 'btn';
        btn.addEventListener('click', function(){ updateSessionLabel(); });
        if (parent && parent.appendChild) parent.appendChild(btn);
        else (document.body||document.documentElement).appendChild(btn);
      }
    }

    function updateSessionLabel(){
      try{
        var label = document.getElementById('sessionLabel');
        if (!label) return;
        var s = readSession();
        if (!s.user){ label.textContent = 'Angemeldet: —'; return; }
        label.textContent = 'Angemeldet als ' + s.user + (s.persistent ? ' (dauerhaft)' : ' (Sitzung)');
      }catch(e){}
    }

    document.addEventListener('DOMContentLoaded', function(){
      ensureSessionUI();
      updateSessionLabel();
    });

    if (typeof window.setSession === 'function' && !window.setSession__v52){
      var _origSet = window.setSession;
      window.setSession__v52 = true;
      window.setSession = function(userId, remember){
        var r = _origSet.apply(this, arguments);
        try{ updateSessionLabel(); }catch(_){}
        return r;
      };
    }

    window.addEventListener('storage', function(ev){
      if (!ev) return;
      if (!ev.key || /session/i.test(ev.key)) { updateSessionLabel(); }
    });
  }catch(e){}
})();</script>


<script>
/* v53 – Entflechtung duplizierter IDs der Remember-Checkbox (minimal-invasiv) */
(function(){
  try{
    function qsa(sel, root){ return Array.prototype.slice.call((root||document).querySelectorAll(sel)); }
    function closestDialog(el){
      var n = el;
      while (n){
        if (n.tagName && n.tagName.toLowerCase() === 'dialog') return n;
        n = n.parentNode;
      }
      return null;
    }
    function normalizeRememberIds(){
      var boxes = qsa('#loginRemember'); // alle mit exakt dieser ID
      if (boxes.length <= 1) return {canonical: boxes[0] || null, all: boxes};
      var canonical = boxes[0];
      var all = [canonical];
      for (var i=1;i<boxes.length;i++){
        var b = boxes[i];
        var newId = 'loginRemember_' + (i+1);
        var scope = closestDialog(b) || b.parentNode || document;
        qsa('label[for=\"loginRemember\"]', scope).forEach(function(lbl){
          if (!lbl.__v53_updated){
            lbl.setAttribute('for', newId);
            lbl.__v53_updated = true;
          }
        });
        b.id = newId;
        all.push(b);
      }
      return {canonical: canonical, all: all};
    }

    function installSyncSelector(){
      function allBoxes(){ return qsa('[id^=\"loginRemember\"]'); }
      function syncFrom(src){
        var val = !!src.checked;
        allBoxes().forEach(function(b){ if (b !== src) b.checked = val; });
      }
      function attach(el){
        if (el.__v53_sync) return;
        el.__v53_sync = true;
        el.addEventListener('change', function(){ syncFrom(el); }, {passive:true});
      }
      function setupAll(){ allBoxes().forEach(attach); }
      setupAll();
      var mo = new MutationObserver(setupAll);
      mo.observe(document.documentElement || document.body, {subtree:true, childList:true});
      var first = allBoxes()[0];
      if (first) syncFrom(first);
    }

    document.addEventListener('DOMContentLoaded', function(){
      normalizeRememberIds();
      installSyncSelector();
    });
  }catch(e){}
})();</script>


<script>
/* v55 – Diagnose: Persistenz testen (harmlos, ohne Session-Veränderung) */
(function(){
  try{
    function ensurePersistTestButton(){
      var parent = document.getElementById('sessionPersist');
      if (!parent){ parent = document.querySelector('#settings, #einstellungen, body'); }
      else { parent = parent.parentNode || parent; }
      if (!document.getElementById('btnPersistTest')){
        var btn = document.createElement('button');
        btn.id = 'btnPersistTest';
        btn.type = 'button';
        btn.textContent = 'Persistenz testen';
        btn.style.marginLeft = '0.5rem';
        btn.className = 'btn';
        btn.addEventListener('click', function(){ runPersistTest(); });
        if (parent && parent.appendChild) parent.appendChild(btn);
        else (document.body||document.documentElement).appendChild(btn);
      }
    }

    function canUseStorage(storage){
      try{
        var key = '__lv_persist_test__' + Math.random();
        storage.setItem(key, 'ok');
        var ok = storage.getItem(key) === 'ok';
        storage.removeItem(key);
        return !!ok;
      }catch(e){ return false; }
    }

    function runPersistTest(){
      var msgs = [];
      var localOk = canUseStorage(localStorage);
      var sessOk  = canUseStorage(sessionStorage);
      msgs.push('localStorage: ' + (localOk ? 'OK (schreib-/lesbar)' : 'NICHT nutzbar'));
      msgs.push('sessionStorage: ' + (sessOk ? 'OK (schreib-/lesbar)' : 'NICHT nutzbar'));
      if (!localOk){
        msgs.push('Hinweis: „Angemeldet bleiben“ benötigt localStorage. Gründe können sein: Privater Modus, strenge Browser-/Tracking-Schutz-Einstellungen, Drittanbieter-Kontext.');
      }
      alert(msgs.join('\\n'));
    }

    document.addEventListener('DOMContentLoaded', function(){
      ensurePersistTestButton();
    });
  }catch(e){}
})();</script>


<script>
/* v57 – Historie deduplizieren (Anzeige-Ebene, minimal-invasiv) */
(function(){
  try{
    function getHistoryTableBody(){
      var dlg = document.querySelector('#historyDlg, dialog#historyDlg');
      if (!dlg) return null;
      var tbody = dlg.querySelector('table tbody, .history-table tbody, #historyTable tbody');
      return tbody || null;
    }
    function parseDelta(txt){
      if (txt == null) return null;
      var m = (''+txt).match(/-?\d+/);
      return m ? parseInt(m[0], 10) : null;
    }
    function cellText(row, idx){
      var cell = row && row.cells ? row.cells[idx] : null;
      if (!cell) return '';
      return (cell.textContent || '').trim();
    }
    function dedupHistoryOnce(){
      var tbody = getHistoryTableBody();
      if (!tbody || tbody.__v57_done) return;
      var rows = Array.prototype.slice.call(tbody.querySelectorAll('tr'));
      if (rows.length === 0) return;
      var byKey = {};
      rows.forEach(function(tr){
        var ts = cellText(tr, 0);
        var user = cellText(tr, 1);
        var action = cellText(tr, 2);
        var article = cellText(tr, 3);
        var deltaTxt = cellText(tr, 4);
        var delta = parseDelta(deltaTxt);
        var key = [ts, user, action, article].join('|');
        if (!byKey[key]) byKey[key] = [];
        byKey[key].push({tr: tr, delta: delta, zero: delta === 0});
      });
      var removed = 0;
      Object.keys(byKey).forEach(function(k){
        var arr = byKey[k];
        if (arr.length < 2) return;
        var hasNonZero = arr.some(function(e){ return typeof e.delta === 'number' && e.delta !== 0; });
        if (hasNonZero){
          arr.forEach(function(e){
            if (e.zero && e.tr.parentNode){
              e.tr.parentNode.removeChild(e.tr);
              removed++;
            }
          });
        }
      });
      if (removed > 0) tbody.__v57_done = true;
    }

    function installObserver(){
      var dlg = document.querySelector('#historyDlg, dialog#historyDlg') || document;
      var root = dlg;
      var mo = new MutationObserver(function(muts){
        for (var i=0;i<muts.length;i++){
          var m = muts[i];
          if (m.type === 'childList'){
            if ((m.target && m.target.tagName && m.target.tagName.toLowerCase() === 'tbody') ||
                (m.addedNodes && m.addedNodes.length)){
              dedupHistoryOnce();
            }
          }
        }
      });
      mo.observe(root, {subtree:true, childList:true});
    }

    document.addEventListener('DOMContentLoaded', function(){
      installObserver();
      setTimeout(dedupHistoryOnce, 100);
    });
  }catch(e){}
})();</script>


<script>
/* v58 – Historie-Deduplizierung auf Datenebene beim Speichern (nur Items) */
(function(){
  try{
    function safeParseInt(n){
      if (n == null) return null;
      var m = (''+n).match(/-?\d+/);
      return m ? parseInt(m[0], 10) : null;
    }
    function normalizeTs(ts){
      // Wir kürzen auf Sekunde, damit identische Aktionen im selben Augenblick erfasst werden
      if (!ts) return '';
      var s = (''+ts).trim();
      // akzeptiere ISO oder bereits formatierte Strings
      // Heuristik: nur bis Sekunden abschneiden
      var m = s.match(/^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})/);
      if (m) return m[1];
      // oder DD.MM.YYYY, HH:MM:SS
      var m2 = s.match(/^(\d{2}\.\d{2}\.\d{4}, \d{2}:\d{2}:\d{2})/);
      if (m2) return m2[1];
      return s;
    }
    function consolidateItemLogs(it){
      try{
        if (!it || !Array.isArray(it.log) || it.log.length < 2) return;
        var groups = {};
        for (var i=0;i<it.log.length;i++){
          var e = it.log[i] || {};
          var ts = normalizeTs(e.ts || e.time || e.date || '');
          var user = (e.user || e.username || '').toString().trim();
          var action = (e.type || e.action || e.info || '').toString().trim(); // tolerant
          var delta = safeParseInt(e.delta);
          var key = [ts, user, action].join('|');
          if (!groups[key]) groups[key] = [];
          groups[key].push({idx:i, delta:delta});
        }
        var toRemove = [];
        Object.keys(groups).forEach(function(k){
          var arr = groups[k];
          if (arr.length < 2) return;
          var hasNonZero = arr.some(function(x){ return typeof x.delta === 'number' && x.delta !== 0; });
          if (!hasNonZero) return;
          arr.forEach(function(x){
            if (x.delta === 0) toRemove.push(x.idx);
          });
        });
        if (toRemove.length){
          // remove from highest index to lowest
          toRemove.sort(function(a,b){ return b - a; });
          for (var r=0;r<toRemove.length;r++){
            it.log.splice(toRemove[r], 1);
          }
        }
      }catch(_){}
    }

    if (typeof window.saveJson === 'function' && !window.saveJson__v58){
      var _origSave = window.saveJson;
      window.saveJson__v58 = true;
      window.saveJson = function(storageKey, data){
        try{
          var keyStr = (storageKey || '').toString();
          if (/lagerverwaltung.*items/i.test(keyStr)){
            if (Array.isArray(data)){
              for (var i=0;i<data.length;i++) consolidateItemLogs(data[i]);
            } else if (data && typeof data === 'object' && Array.isArray(data.items)){
              for (var j=0;j<data.items.length;j++) consolidateItemLogs(data.items[j]);
            }
          }
        }catch(_){}
        return _origSave.apply(this, arguments);
      };
    }
  }catch(e){ /* niemals blockieren */ }
})();</script>

</script>


<script>
/* v61 – Buchungs-Schreiber: nur ein Log pro Buchung (minimal-invasiv) */
(function(){
  try{
    function isZeroInOut(entry){
      if (!entry || typeof entry !== 'object') return false;
      var t = (entry.type||'').toString();
      var d = Number(entry.delta||0);
      return (t === 'in' || t === 'out') && d === 0;
    }
    function isQtyNonZero(entry){
      if (!entry || typeof entry !== 'object') return false;
      return (entry.type === 'qty') && (Number(entry.delta||0) !== 0);
    }
    function sameMoment(a,b){
      if (!a || !b) return false;
      var ta = Number(a.ts||a.time||0);
      var tb = Number(b.ts||b.time||0);
      return Math.floor(ta/1000) === Math.floor(tb/1000);
    }
    function stripPair(args){
      try{
        var list = Array.prototype.slice.call(args);
        if (list.length < 2) return list;
        for (var i=0;i<list.length;i++){
          for (var j=i+1;j<list.length;j++){
            var a = list[i], b = list[j];
            if (isQtyNonZero(a) && isZeroInOut(b) && sameMoment(a,b)){
              list.splice(j,1); j--;
            } else if (isQtyNonZero(b) && isZeroInOut(a) && sameMoment(a,b)){
              list.splice(i,1); i--; break;
            }
          }
        }
        return list;
      }catch(_){ return args; }
    }
    function wrapLogger(fnName){
      var f = window[fnName];
      if (typeof f !== 'function' || f.__v61_wrapped) return;
      var orig = f;
      window[fnName] = function(){
        var sanitized = stripPair(arguments);
        return orig.apply(this, sanitized);
      };
      window[fnName].__v61_wrapped = true;
    }
    ['addItemLog','logChange','logBooking','pushLog','appendLog','writeLog','addLog'].forEach(wrapLogger);
  }catch(e){}
})();</script>


<script>
/* v62 – Historie-Qualität (Anzeige & Daten – konservativ, idempotent) */
(function(){
  try{
    // 1. Helper: Sekundengenauigkeit
    function toSec(ts){ try{ return Math.floor(Number(ts)/1000); }catch(_){ return null; } }

    // 2. Logic: Logs bereinigen (0-in/out entfernen, wenn qty vorhanden)
    function consolidateLogsV62(log){
      if(!Array.isArray(log) || log.length < 2) return 0;
      var bySec = {};
      for (var i=0; i<log.length; i++){
        var e = log[i] || {};
        var sec = toSec(e.ts);
        if (sec == null) continue;
        if (!bySec[sec]) bySec[sec] = [];
        bySec[sec].push({idx:i, type:String(e.type||''), delta:Number(e.delta||0)});
      }
      var removeIdx = [];
      Object.keys(bySec).forEach(function(sec){
        var arr = bySec[sec];
        var qty = null;
        // Suche echte qty-Änderung in dieser Sekunde
        for(var k=0; k<arr.length; k++){
          if(arr[k].type === 'qty' && arr[k].delta !== 0){ qty = arr[k]; break; }
        }
        if (!qty) return;

        // Markiere überflüssige 0-Delta Einträge
        arr.forEach(function(x){
          if ((x.type === 'in' || x.type === 'out') && x.delta === 0){
            if ((qty.delta > 0 && x.type === 'in') || (qty.delta < 0 && x.type === 'out')){
              removeIdx.push(x.idx);
            }
          }
        });
      });
      // Entfernen (rückwärts)
      if (removeIdx.length){
        removeIdx.sort(function(a,b){ return b-a; });
        for (var r=0; r<removeIdx.length; r++){ log.splice(removeIdx[r], 1); }
      }
      return removeIdx.length;
    }

    // 3. Anzeige-Filter (für aggregateHistory)
    window.__lv62_histFilter = function(rows){
      try{
        if(!Array.isArray(rows) || rows.length < 2) return rows;
        var hasNZByKey = Object.create(null);
        var seenExact = Object.create(null);
        for (var i=0;i<rows.length;i++){
          var r = rows[i] || {};
          var s = toSec(r.ts);
          if (s != null){
            var key = s+'|'+(r.itemName||'')+'|'+(r.sku||'');
            if (Number(r.delta||0) !== 0) hasNZByKey[key] = true;
          }
        }
        var out = [];
        for (var j=0;j<rows.length;j++){
          var r2 = rows[j] || {};
          var s2 = toSec(r2.ts);
          var d2 = Number(r2.delta||0);
          if (s2 != null){
            var k2 = s2+'|'+(r2.itemName||'')+'|'+(r2.sku||'');
            if (hasNZByKey[k2] && d2 === 0) continue;
          }
          var kExact = [r2.ts, r2.user, r2.type, r2.itemName, r2.sku, r2.delta, r2.reason].join('|');
          if (seenExact[kExact]) continue;
          seenExact[kExact] = 1;
          out.push(r2);
        }
        return out;
      }catch(_){ return rows; }
    };

    // 4. Hooks installieren
    // Hook für Anzeige
    if (typeof window.aggregateHistory === 'function' && !window.aggregateHistory.__v62_wrapped){
      var __origAgg = window.aggregateHistory;
      window.aggregateHistory = function(){
        var r = __origAgg.apply(this, arguments);
        try{ if (window.__lv62_histFilter) r = window.__lv62_histFilter(r); }catch(_){}
        return r;
      };
      window.aggregateHistory.__v62_wrapped = true;
    }

    // Hook für Daten-Speicherung
    if (typeof window.saveJson === 'function' && !window.saveJson__v62){
      var _prev = window.saveJson;
      window.saveJson__v62 = true;
      window.saveJson = function(storageKey, data){
        try{
          if (/lagerverwaltung.*items/i.test(String(storageKey||''))){
            var list = Array.isArray(data) ? data : (data && data.items);
            if (Array.isArray(list)){
              for (var i=0; i<list.length; i++){
                if (list[i] && Array.isArray(list[i].log)) consolidateLogsV62(list[i].log);
              }
            }
          }
        }catch(_){}
        return _prev.apply(this, arguments);
      };
    }
  }catch(e){ /* silent */ }
})();
</script>
<script>
/* v63 – Mehrbenutzer-Grundgerüst (Pull-vor-Push, opId, Idempotenz – minimal-invasiv) */
(function(){
  try{
    function uuid(){
      try{
        if (crypto && crypto.randomUUID) return crypto.randomUUID();
      }catch(_){}
      // Fallback
      var d = Date.now();
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c){
        var r = (d + Math.random()*16)%16 | 0; d = Math.floor(d/16);
        return (c==='x' ? r : (r&0x3|0x8)).toString(16);
      });
    }

    // ---- v63.1: qty-Logs immer mit opId taggen (bei Erstellung) ----
    function tagOpId(entry){
      try{
        if (!entry || typeof entry !== 'object') return;
        if (entry.type === 'qty' && Number(entry.delta||0) !== 0){
          if (!entry.opId) entry.opId = uuid();
        }
      }catch(_){}
    }

    // Wrap der Log-Schreiber wie in v61, nur ergänzend: opId setzen
    ['addItemLog','logChange','logBooking','pushLog','appendLog','writeLog','addLog'].forEach(function(fn){
      var f = window[fn];
      if (typeof f === 'function' && !f.__v63_wrapped){
        var orig = f;
        window[fn] = function(){
          var args = Array.prototype.slice.call(arguments);
          for (var i=0;i<args.length;i++) tagOpId(args[i]);
          return orig.apply(this, args);
        };
        window[fn].__v63_wrapped = true;
      }
    });

    // ---- v63.2: Lokale Idempotenz: angewendete opIds per Item merken ----
    function ensureAppliedSetOnItem(it){
      if (!it) return;
      if (!Array.isArray(it.appliedOpIds)) it.appliedOpIds = [];
    }
    function markApplied(it, entry){
      try{
        if (!it || !entry || !entry.opId) return;
        ensureAppliedSetOnItem(it);
        if (it.appliedOpIds.indexOf(entry.opId) === -1) it.appliedOpIds.push(entry.opId);
      }catch(_){}
    }

    // Hook saveJson (Items): überspringe doppelte opIds, markiere neue als angewendet
    if (typeof window.saveJson === 'function' && !window.saveJson__v63_ops){
      var _savePrev = window.saveJson;
      window.saveJson__v63_ops = true;
      window.saveJson = function(storageKey, data){
        try{
          var keyStr = (storageKey||'')+'';
          if (/lagerverwaltung.*items/i.test(keyStr)){
            var items = null;
            if (Array.isArray(data)) items = data;
            else if (data && typeof data==='object' && Array.isArray(data.items)) items = data.items;
            if (items){
              for (var i=0;i<items.length;i++){
                var it = items[i];
                if (!it || !Array.isArray(it.log)) continue;
                ensureAppliedSetOnItem(it);
                // Filter doppelte opIds innerhalb desselben Speichervorgangs
                var seen = new Set(it.appliedOpIds);
                it.log = it.log.filter(function(e){
                  if (!e || !e.opId) return true;
                  if (seen.has(e.opId)) return false; // dupliziert
                  seen.add(e.opId);
                  return true;
                });
                // Neue als angewendet markieren
                it.log.forEach(function(e){ if (e && e.opId) markApplied(it, e); });
              }
            }
          }
        }catch(_){}
        return _savePrev.apply(this, arguments);
      };
    }

    // ---- v63.3: Outbox anreichern (opId + Kombinierung lokaler qty-Ops) ----
    function combineQtyOps(jobs){
      // Kombiniere mehrere qty-Änderungen auf dasselbe Item (nur qty-ops) zu einer Summe
      try{
        var byItem = {};
        var others = [];
        jobs.forEach(function(job){
          if (!job || job.type!=='qty' || !job.itemId) { others.push(job); return; }
          var k = String(job.itemId);
          if (!byItem[k]) byItem[k] = {base: null, sum:0, ops:[]};
          byItem[k].sum += Number(job.delta||0);
          byItem[k].ops.push(job);
        });
        var result = others.slice();
        Object.keys(byItem).forEach(function(k){
          var b = byItem[k];
          if (b.ops.length){
            var merged = Object.assign({}, b.ops[0]);
            merged.delta = b.sum;
            if (!merged.opId) merged.opId = uuid();
            result.push(merged);
          }
        });
        return result;
      }catch(_){ return jobs; }
    }

    function patchOutboxSender(fnName){
      var f = window[fnName];
      if (typeof f !== 'function' || f.__v63_outbox) return;
      var orig = f;
      window[fnName] = async function(){
        // Kein implizites Pull-vor-Push mehr, nur Outbox-Anreicherung
        try{
          if (Array.isArray(window.__outboxQueue)){
            window.__outboxQueue.forEach(function(job){
              if (job && !job.opId) job.opId = uuid();
            });
            window.__outboxQueue = combineQtyOps(window.__outboxQueue);
          }
        }catch(_){}
        return orig.apply(this, arguments);
      };
      window[fnName].__v63_outbox = true;
    }

    ['cloudPushAll','processOutbox','manualSync'].forEach(patchOutboxSender);

  }catch(e){ /* niemals blockieren */ }
})();</script>


<script>
/* v64 – Additiver Rebase nach Pull (Mehrbenutzer) */
(function(){
  try{
    function ensureAppliedSetOnItem(it){
      if (!it) return;
      if (!Array.isArray(it.appliedOpIds)) it.appliedOpIds = [];
    }
    function rebaseItems(items){
      if (!Array.isArray(items)) return 0;
      var changes = 0;
      for (var i=0;i<items.length;i++){
        var it = items[i];
        if (!it) continue;
        ensureAppliedSetOnItem(it);
        var applied = new Set(it.appliedOpIds);
        if (!Array.isArray(it.log)) continue;
        for (var j=0;j<it.log.length;j++){
          var e = it.log[j];
          if (!e || e.type !== 'qty') continue;
          var d = Number(e.delta||0);
          if (!e.opId || d===0) continue;
          if (!applied.has(e.opId)){
            var n = Number(it.qty||0); if (!isFinite(n)) n = 0;
            it.qty = n + d;
            it.appliedOpIds.push(e.opId);
            applied.add(e.opId);
            changes++;
          }
        }
      }
      return changes;
    }

    function attemptReadItems(){
      try{ if (Array.isArray(window.items)) return window.items; }catch(_){}
      try{
        for (var i=0;i<localStorage.length;i++){
          var k = localStorage.key(i)||'';
          if (/lagerverwaltung.*items/i.test(k)){
            var txt = localStorage.getItem(k);
            try{
              var parsed = JSON.parse(txt);
              if (Array.isArray(parsed)) return parsed;
              if (parsed && Array.isArray(parsed.items)) return parsed.items;
            }catch(_){}
          }
        }
      }catch(_){}
      return null;
    }

    async function rebaseAfterPull(){
      try{
        var items = attemptReadItems();
        if (!items) return;
        var changed = rebaseItems(items);
        if (changed > 0){
          if (typeof window.saveJson === 'function'){
            try{
              if (Array.isArray(window.items)){
                await window.saveJson('lagerverwaltung_items', window.items);
              } else {
                await window.saveJson('lagerverwaltung_items', {items: items});
              }
            }catch(_){}
          } else {
            try{
              for (var i=0;i<localStorage.length;i++){
                var k = localStorage.key(i)||'';
                if (/lagerverwaltung.*items/i.test(k)){
                  var obj = {items: items};
                  try{
                    var txt = localStorage.getItem(k);
                    var parsed = JSON.parse(txt);
                    if (Array.isArray(parsed)) obj = items;
                    else if (parsed && Array.isArray(parsed.items)) obj = {items: items};
                  }catch(_){}
                  localStorage.setItem(k, JSON.stringify(obj));
                  break;
                }
              }
            }catch(_){}
          }
        }
      }catch(_){}
    }

    if (typeof window.cloudPullAll === 'function' && !window.cloudPullAll__v64){
      var _pull = window.cloudPullAll;
      window.cloudPullAll__v64 = true;
      window.cloudPullAll = async function(){
        var res = await _pull.apply(this, arguments);
        try{ await rebaseAfterPull(); }catch(_){}
        return res;
      };
    }

    function patchOutboxSender(fnName){
      var f = window[fnName];
      if (typeof f !== 'function' || f.__v64_sync) return;
      var orig = f;
      window[fnName] = async function(){
        // Kein zusätzliches Pull-vor-Push mehr; Rebase läuft nur an expliziten Pulls
        return orig.apply(this, arguments);
      };
      window[fnName].__v64_sync = true;
    }
    
['cloudPushAll','processOutbox','manualSync'].forEach(patchOutboxSender);

  }catch(e){ /* niemals blockieren */ }
})();</script>


<script>
/* v65 – Persistente PendingOps + stabiler Mehrbenutzer-Rebase */
(function(){
  try{
    var PENDING_KEY = 'lv_pending_ops';

    function uuid(){
      try{ if (crypto && crypto.randomUUID) return crypto.randomUUID(); }catch(_){}
      var d = Date.now();
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c){
        var r = (d + Math.random()*16)%16 | 0; d = Math.floor(d/16);
        return (c==='x' ? r : (r&0x3|0x8)).toString(16);
      });
    }

    function loadPending(){
      try{
        var raw = localStorage.getItem(PENDING_KEY);
        if (!raw) return [];
        var arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return [];
        // Einmalige Aufräum-Logik: nur gültige Pending-Einträge behalten
        var cleaned = arr.filter(function(op){
          return op && typeof op === 'object' && (op.opId || op.itemId || op.sku);
        });
        if (cleaned.length !== arr.length){
          try{ localStorage.setItem(PENDING_KEY, JSON.stringify(cleaned)); }catch(_){}
        }
        return cleaned;
      }catch(_){}
      return [];
    }
    function savePending(arr){
      try{ localStorage.setItem(PENDING_KEY, JSON.stringify(arr||[])); }catch(_){}
    }
    function addPending(op){
      var p = loadPending();
      p.push(op);
      savePending(p);
    }
    function removePendingByIds(ids){
      if (!ids || !ids.length) return;
      var set = {};
      ids.forEach(function(id){ if(id) set[id]=true; });
      var p = loadPending().filter(function(o){ return !set[o.opId]; });
      savePending(p);
    }

    // ---- Logger-Ergänzung: qty→Pending ----
    function tagQtyAndQueuePending(entry){
      if (!entry || typeof entry !== 'object') return;
      if (entry.type === 'qty'){
        var d = Number(entry.delta||0);
        if (d !== 0){
          if (!entry.opId) entry.opId = uuid();
          if (!entry.ts) entry.ts = Date.now();
          // itemId bevorzugt aus entry.itemId, sonst aus entry.sku
          var itemId = entry.itemId || null;
          if (!itemId && entry.sku){ itemId = entry.sku; }
          if (itemId && !entry.itemId){ entry.itemId = itemId; }
          addPending({ opId: entry.opId, itemId: itemId || null, delta: d, ts: entry.ts });
          // Optional: ItemOps-Outbox befüllen über sku/itemId
          if (typeof enqueueOutbox === 'function'){
            var fakeItem = { id: itemId || null, sku: entry.sku || itemId || '' };
            try{ enqueueOutbox(fakeItem, entry); }catch(_){}
          }
        }
      }
    }
    ['addItemLog','logChange','logBooking','pushLog','appendLog','writeLog','addLog'].forEach(function(fn){
      var f = window[fn];
      if (typeof f === 'function' && !f.__v65_pending){
        var orig = f;
        window[fn] = function(){
          for (var i=0;i<arguments.length;i++) tagQtyAndQueuePending(arguments[i]);
          return orig.apply(this, arguments);
        };
        window[fn].__v65_pending = true;
      }
    });

    // ---- Rebase nutzt jetzt Pending-ops als Quelle ----
// ---- Rebase nutzt jetzt Pending-ops als Quelle ----
    function ensureAppliedSetOnItem(it){
      if (!it) return;
      if (!Array.isArray(it.appliedOpIds)) it.appliedOpIds = [];
    }
    function ensureLog(it){ if (!Array.isArray(it.log)) it.log = []; }
    function findOrCreateQtyLog(it, op){
      ensureLog(it);
      for (var i=0;i<it.log.length;i++){
        var e = it.log[i]; if (e && e.opId === op.opId) return e;
      }
      var entry = { ts: op.ts, type: 'qty', delta: op.delta, opId: op.opId };
      it.log.push(entry);
      return entry;
    }
    function rebaseWithPending(items){
      var pending = loadPending();
      if (!Array.isArray(items) || !pending.length) return 0;
      var changes = 0;
      var byId = {};
      for (var i=0;i<items.length;i++){
        var it = items[i]; if (!it) continue;
        var key = String(it.id || it.sku || it.code || i);
        byId[key] = it;
        ensureAppliedSetOnItem(it);
      }
      for (var j=0;j<pending.length;j++){
        var op = pending[j];
        if (!op || !op.opId) continue;
        var target = byId[String(op.itemId)] || null;
        if (!target) continue; // unbekanntes Item (z. B. gefiltert) – ignorieren
        var applied = target.appliedOpIds.indexOf(op.opId) !== -1;
        if (!applied){
          // qty additiv erhöhen
          var n = Number(target.qty||0); if (!isFinite(n)) n = 0;
          target.qty = n + Number(op.delta||0);
          // Log sicherstellen
          findOrCreateQtyLog(target, op);
          // opId als angewendet markieren
          target.appliedOpIds.push(op.opId);
          changes++;
        }
      }
      return changes;
    }

    async function persistItems(items){
      if (!items) return;
      if (typeof window.saveJson === 'function'){
        try{
          if (Array.isArray(window.items)){
            await window.saveJson('lagerverwaltung_items', window.items);
          } else {
            await window.saveJson('lagerverwaltung_items', {items: items});
          }
        }catch(_){}
      } else {
        try{
          for (var i=0;i<localStorage.length;i++){
            var k = localStorage.key(i)||'';
            if (/lagerverwaltung.*items/i.test(k)){
              var obj = {items: items};
              try{
                var txt = localStorage.getItem(k);
                var parsed = JSON.parse(txt);
                if (Array.isArray(parsed)) obj = items;
                else if (parsed && Array.isArray(parsed.items)) obj = {items: items};
              }catch(_){}
              localStorage.setItem(k, JSON.stringify(obj));
              break;
            }
          }
        }catch(_){}
      }
    }

    function getItems(){
      try{ if (Array.isArray(window.items)) return window.items; }catch(_){}
      try{
        for (var i=0;i<localStorage.length;i++){
          var k = localStorage.key(i)||'';
          if (/lagerverwaltung.*items/i.test(k)){
            var txt = localStorage.getItem(k);
            try{
              var parsed = JSON.parse(txt);
              if (Array.isArray(parsed)) return parsed;
              if (parsed && Array.isArray(parsed.items)) return parsed.items;
            }catch(_){}
          }
        }
      }catch(_){}
      return null;
    }

    async function rebaseAfterPull(){
      var items = getItems();
      if (!items) return;
      var changed = rebaseWithPending(items);
      if (changed > 0){ await persistItems(items); }
    }

    // Wrap cloudPullAll → danach Rebase
    if (typeof window.cloudPullAll === 'function' && !window.cloudPullAll__v65){
      var _pull = window.cloudPullAll;
      window.cloudPullAll__v65 = true;
      window.cloudPullAll = async function(){
        var res = await _pull.apply(this, arguments);
        try{ await rebaseAfterPull(); }catch(_){}
        return res;
      };
    }

    // Vor Push: sicherstellen Pull→Rebase, Nach Push: Pending entfernen (optimistisch)
    function patchOutboxSender(fnName){
      var f = window[fnName];
      if (typeof f !== 'function' || f.__v65_sync) return;
      var orig = f;
      window[fnName] = async function(){
        var before = loadPending().map(function(x){ return x.opId; });
        var res = await orig.apply(this, arguments);
        // Nach Erfolg: lokal Pending leeren (die serverseitig übernommen sein sollten)
        // (optimistic clear; wenn Server ablehnt, entstehen neue Pending-Einträge beim nächsten Buchen)
        removePendingByIds(before);
        return res;
      };
      window[fnName].__v65_sync = true;
    }
    
['cloudPushAll','processOutbox','manualSync'].forEach(patchOutboxSender);

  }catch(e){ /* niemals blockieren */ }
})();

// Step1: unified delta logging with opId (minimal, non-invasive)
function appendQtyOp(item, delta, reason){
  try{
    var d = Number(String(delta).toString().replace(',', '.'))||0;
    var opId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('op_'+Date.now()+'_'+Math.random().toString(16).slice(2));
    var L = { type:'qty', delta:d, reason:(reason||''), ts: Date.now(), opId: opId };
    item.log = item.log || [];
    item.log.push(L);
    try{ if(window.enqueueOutbox) enqueueOutbox(item, L); }catch(_){ /* outbox hook added in later steps */ }
  }catch(e){ console.warn('appendQtyOp failed', e); }
}
</script>


<script>
// Step2: Outbox + Push (idempotent via opId)
function getClientId(){
  try{
    var k = 'lagerverwaltung_client_id';
    var v = localStorage.getItem(k);
    if(v && v.trim()) return v;
    var nid = (crypto && crypto.randomUUID) ? crypto.randomUUID() : ('cli_'+Date.now()+'_'+Math.random().toString(16).slice(2));
    localStorage.setItem(k, nid);
    return nid;
  }catch(_){ return 'cli_'+Date.now() }
}
</script>


<script>
var outboxKey  = "lagerverwaltung_outbox_v1";
function loadOutbox(){
  try{
    var raw = localStorage.getItem(outboxKey) || '[]';
    var arr = JSON.parse(raw);
    if (!Array.isArray(arr)) return [];
    // Einmalige Aufräum-Logik: nur gültige Outbox-Jobs behalten
    var cleaned = arr.filter(function(j){
      if (!j || typeof j !== 'object') return false;
      // mindestens eine Identifikation (opId / itemId / sku)
      if (!j.opId && !j.itemId && !j.sku) return false;
      // delta muss eine endliche Zahl sein
      if (typeof j.delta !== 'number' || !isFinite(j.delta)) return false;
      return true;
    });
    if (cleaned.length !== arr.length){
      try{ localStorage.setItem(outboxKey, JSON.stringify(cleaned)); }catch(_){}
    }
    return cleaned;
  }catch(_){
    return [];
  }
}
function saveOutbox(arr){ try{ localStorage.setItem(outboxKey, JSON.stringify(arr)); }catch(_){} }

function updateOutboxUi(){
  try{
    var box = loadOutbox();
    var count = Array.isArray(box) ? box.length : 0;
    var el = document.getElementById('outboxStatus');
    if (el){ el.textContent = 'Outbox: ' + count + ' offene Vorgänge'; }
  }catch(_){}
}

function enqueueOutbox(item, L){
  try{
    var job = {
      opId: String(L.opId||''),
      sku: String(item && item.sku || ''),
      itemId: String(item && item.id || ''),
      delta: Number(L.delta||0),
      ts: Number(L.ts||Date.now()),
      reason: String(L.reason||''),
      clientId: String(getClientId())
    };
    var box = loadOutbox();
    // avoid duplicates by opId
    if(job.opId && !box.some(function(j){return j.opId===job.opId;})){
      box.push(job);
      saveOutbox(box);
    }
  }catch(e){ console.warn('enqueueOutbox failed', e); }
}
</script>


<script>
function readBrConfig(){
  try{
    return {
      url:       lsGetMigrate(sbUrlKey, brUrlKey, ''),
      token:     lsGetMigrate(sbTokenKey, brTokenKey, ''),
      tblItems:  lsGetMigrate(sbTblItemsKey, brTblItemsKey, ''),
      tblGroups: lsGetMigrate(sbTblGroupsKey, brTblGroupsKey, ''),
      tblMembers:lsGetMigrate(sbTblMembersKey, brTblMembersKey, ''),
      tblBackups:lsGetMigrate(sbTblBackupsKey, brTblBackupsKey, ''),
      tblAppSettings: lsGetMigrate(sbTblAppSettingsKey, brTblAppSettingsKey, ''),
      tblItemOps: lsGetMigrate(sbTblItemOpsKey, brTblItemOpsKey, ''),
      skuField:  lsGetMigrate(sbSkuFieldKey, brSkuFieldKey, 'sku'),
      autoSync:  lsGetMigrate(sbAutoSyncKey, 'lagerverwaltung_baserow_autosync', '0')
    };
  }catch(_){
    return { url:'', token:'', tblItems:'', tblGroups:'', tblMembers:'', tblBackups:'', tblAppSettings:'', tblItemOps:'', skuField:'sku', autoSync:'0' };
  }
}

async function brPostRow(tblName, data, cfg){
  cfg = cfg || (typeof readBrConfig === 'function' ? readBrConfig() : null);
  if (!cfg || !cfg.url || !cfg.token){
    throw new Error('Supabase nicht konfiguriert (für brPostRow)');
  }
  var base = String(cfg.url || '').replace(/\/+$/,'');
  var url  = base + '/' + encodeURIComponent(tblName);

  var headers = {
    apikey       : cfg.token,
    Authorization: 'Bearer ' + cfg.token,
    'Content-Type': 'application/json',
    Accept       : 'application/json',
    Prefer       : 'return=minimal'
  };

  var res = await fetch(url, {
    method : 'POST',
    headers: headers,
    body   : JSON.stringify(data || {})
  });
  if (!res.ok){
    var t = '';
    try{ t = await res.text(); }catch(_){}
    throw new Error('Supabase POST failed: ' + res.status + ' ' + t);
  }
  return true;
}

async function processOutbox(){
  try{
    var cfg = readBrConfig();
    if (!cfg || !cfg.url || !cfg.token || !cfg.tblItemOps){
      if (typeof toast === 'function'){ toast('Cloud-Konfig unvollständig'); }
      return;
    }
    var box = loadOutbox();
    if (!box.length){
      if (typeof toast === 'function'){ toast('Outbox leer'); }
      return;
    }
    var sent = 0, kept = [];
    for (var i = 0; i < box.length; i++){
      var j = box[i];
      try{
        var row = {};
        row[cfg.skuField || 'sku'] = j.sku || j.itemId || '';
        row.delta    = j.delta;
        row.opId     = j.opId;
        row.ts       = j.ts;
        row.reason   = j.reason;
        row.clientId = j.clientId;
        await brPostRow(cfg.tblItemOps, row, cfg); // idempotent serverseitig (opId unique in Supabase)
        sent++;
      }catch(e){
        kept.push(j);
      }
    }
    saveOutbox(kept);
    if (typeof render === 'function'){
      try{ render(); }catch(_){}
    }
    if (typeof toast === 'function'){
      toast('Outbox: ' + sent + ' gesendet, ' + kept.length + ' offen');
    }
  }catch(e){
    console.error(e);
    if (typeof toast === 'function'){
      toast('Outbox-Fehler: ' + e.message);
    }
  }
}
</script>


<script>
function queueTask(name){
  try{
    if(name==='pushAll'){
      try{
        var cfg = (typeof readBrConfig==='function') ? readBrConfig() : null;
        if(cfg && cfg.autoSync){
          // Auto‑Sync EIN → sofort senden
          processOutbox();
        }else{
          // Auto‑Sync AUS → nur Status aktualisieren (Warteschlange sichtbar lassen)
          try{ if (typeof render==='function') render(); }catch(_){}
        }
      }catch(_){}
      return;
    }
  }catch(e){ console.warn('queueTask error', e); }
}
</script>

<script>
if (typeof queueTask === 'function'){
  const __orig_qt__ = queueTask;
  window.queueTask = function(name){
    try{
      if(name==='pullAll'){ cloudPullAll(); return; }
    }catch(e){ console.warn(e); }
    try{ return __orig_qt__.apply(this, arguments); }catch(_){}
  };
}
</script>

<script>
// v73 – ItemOpsLocal: qty-Buchungen lokal protokollieren (nur lokale Speicherung, keine Änderung der Bestände)
(function(){
  try{
    function persistItemOpsLocal(){
      try{
        if (typeof itemOpsLocalKey === 'undefined') return;
        if (typeof itemOpsLocal === 'undefined' || !Array.isArray(itemOpsLocal)){
          itemOpsLocal = [];
        }
        localStorage.setItem(itemOpsLocalKey, JSON.stringify(itemOpsLocal));
      }catch(_){}
    }

    if (typeof window.addLog === 'function' && !window.addLog.__lvItemOpsWrapped){
      var origAddLog = window.addLog;
      window.addLog = function itemOpsAddLogWrapper(item, entry){
        var result = origAddLog.apply(this, arguments);
        try{
          var it = item || {};
          var e  = entry || {};
          var sku = it.sku || it.SKU || it.id || null;
          var delta = (typeof e.delta === 'number') ? e.delta :
                      (typeof e.qty === 'number')   ? e.qty   : null;
          var ts = e.ts || e.time || e.date || new Date().toISOString();
          var type = e.type || e.t || null;

          if (sku && (delta !== null || type)){
            if (!Array.isArray(itemOpsLocal)) itemOpsLocal = [];
            itemOpsLocal.push({
              sku  : String(sku),
              ts   : ts,
              type : type || 'log',
              delta: delta,
              source: 'addLog'
            });
            persistItemOpsLocal();
          }
        }catch(_){}
        return result;
      };
      window.addLog.__lvItemOpsWrapped = true;
      window.addLog.__lvItemOpsOrig = origAddLog;
    }
  }catch(_){}
})();</script>


<script>
// v74 – cloudPullItemOps: ItemOps aus Supabase laden (nur lokal speichern, keine Bestandsänderung)
(function(){
  try{
    var itemOpsCloudKey = 'lv_item_ops_cloud';

    async function cloudPullItemOps(options){
      options = options || {};
      var silent = !!options.silent;
      var cfg;
      try{
        if (typeof readBrConfig !== 'function'){
          if (!silent && typeof toast === 'function'){
            try{ toast('Cloud-Konfiguration nicht verfügbar'); }catch(_){}
          }
          return [];
        }
        cfg = readBrConfig();
      }catch(e){
        if (!silent && typeof toast === 'function'){
          try{ toast('Cloud-Konfiguration ungültig'); }catch(_){}
        }
        throw e;
      }

      if (!cfg || !cfg.url || !cfg.token || !cfg.tblItemOps){
        if (!silent && typeof toast === 'function'){
          try{ toast('Cloud: Tabelle „itemops“ ist nicht konfiguriert'); }catch(_){}
        }
        return [];
      }

      if (!silent){
        try{
          var statusEl = document.getElementById('itemOpsStatus');
          if (statusEl){ statusEl.textContent = 'ItemOps: Laden aus Cloud ...'; }
        }catch(_){}
      }

      var all = [];
      try{
        if (typeof brListAll !== 'function'){
          throw new Error('brListAll nicht verfügbar');
        }
        all = await brListAll(cfg.tblItemOps, { order_by: 'ts' });
      }catch(e){
        if (!silent && typeof toast === 'function'){
          try{ toast('Fehler beim Laden der ItemOps aus Supabase'); }catch(_){}
        }
        throw e;
      }

      try{
        localStorage.setItem(itemOpsCloudKey, JSON.stringify(all));
      }catch(_){}

      if (!silent){
        var msg = 'ItemOps aus Cloud geladen: ' + all.length + ' Einträge';
        try{
          if (typeof toast === 'function'){ toast(msg); }
          var el = document.getElementById('itemOpsStatus');
          if (el){ el.textContent = msg; }
        }catch(_){}
      }
      return all;
    }

    if (typeof window.cloudPullItemOps !== 'function'){
      window.cloudPullItemOps = cloudPullItemOps;
    }

    document.addEventListener('DOMContentLoaded', function(){
      if (!window.lvDebugItemOps){ return; }
      try{
        var sec = document.getElementById('secCloud');
        if (!sec){ return; }

        var rows = sec.querySelectorAll('.row');
        var targetRow = rows[1] || rows[0] || null;
        if (targetRow && !document.getElementById('btnItemOpsPull')){
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn';
          btn.id = 'btnItemOpsPull';
          btn.textContent = 'ItemOps laden (Test)';
          btn.addEventListener('click', function(){
            cloudPullItemOps().catch(function(err){
              try{
                if (window.console && console.error){ console.error(err); }
                if (typeof toast === 'function'){ toast('Fehler beim Laden der ItemOps'); }
              }catch(_){}
            });
          });
          targetRow.insertBefore(btn, targetRow.firstChild);
        }

        if (!document.getElementById('itemOpsStatus')){
          var info = document.createElement('div');
          info.id = 'itemOpsStatus';
          info.className = 'hint';
          info.style.marginTop = '4px';
          info.textContent = 'ItemOps: noch keine Daten aus der Cloud geladen.';
          sec.appendChild(info);
        }
      }catch(_){}
    });
  }catch(_){}
})();
;
</script>

<script>
// v75 – ItemOps-Simulation (Dry-Run, keine Bestandsänderung)
(function(){
  try{
    function loadJsonSafe(key, fallback){
      try{
        var raw = localStorage.getItem(key);
        if(!raw) return fallback;
        var data = JSON.parse(raw);
        return (data === null || typeof data === 'undefined') ? fallback : data;
      }catch(_){ return fallback; }
    }

    function buildItemIndex(){
      var list = [];
      try{
        if(!Array.isArray(items)) return list;
      }catch(_){ return list; }
      for(var i=0;i<items.length;i++){
        var it = items[i];
        if(!it) continue;
        var k = "";
        try{
          if(it.sku) k = String(it.sku);
          else if(it.code) k = String(it.code);
          else if(it.id != null) k = String(it.id);
        }catch(_){}
        if(!k) continue;

        var applied = {};
        try{
          if(Array.isArray(it.appliedOpIds)){
            for(var j=0;j<it.appliedOpIds.length;j++){
              var oid = it.appliedOpIds[j];
              if(!oid) continue;
              applied[String(oid)] = true;
            }
          }
        }catch(_){}
        try{
          if(Array.isArray(it.log)){
            for(var j=0;j<it.log.length;j++){
              var le = it.log[j];
              if(le && le.type === 'qty' && le.opId){
                applied[String(le.opId)] = true;
              }
            }
          }
        }catch(_){}
        list.push({ item: it, key: k, applied: applied });
      }
      return list;
    }

    function getBrConfigSafe(){
      try{
        if(typeof readBrConfig === 'function'){
          return readBrConfig();
        }
      }catch(_){}
      return {};
    }

    function collectItemOps(){
      var cfg = getBrConfigSafe() || {};
      var skuFieldName = cfg.skuField || 'sku';
      var localOps = loadJsonSafe('lv_item_ops_local', []);
      var cloudOps = loadJsonSafe('lv_item_ops_cloud', []);
      var ops = [];

      if(Array.isArray(localOps)){
        for(var i=0;i<localOps.length;i++){
          var op = localOps[i];
          if(!op) continue;
          var delta = Number(op.delta || 0);
          if(!delta) continue;
          var sku = "";
          try{
            sku = op.sku || op.itemId || "";
            if(sku) sku = String(sku);
          }catch(_){}
          if(!sku) continue;
          var opId = "";
          try{ if(op.opId) opId = String(op.opId); }catch(_){}
          var ts = 0;
          try{ ts = Number(op.ts || 0) || 0; }catch(_){}
          ops.push({
            source: 'local',
            sku: sku,
            opId: opId,
            delta: delta,
            ts: ts
          });
        }
      }

      if(Array.isArray(cloudOps)){
        for(var i=0;i<cloudOps.length;i++){
          var row = cloudOps[i];
          if(!row) continue;
          var delta2 = 0;
          try{ delta2 = Number(row.delta || 0) || 0; }catch(_){}
          if(!delta2) continue;
          var sku2 = "";
          try{
            if(row[skuFieldName]) sku2 = String(row[skuFieldName]);
            else if(row.sku) sku2 = String(row.sku);
          }catch(_){}
          if(!sku2) continue;
          var opId2 = "";
          try{ if(row.opId) opId2 = String(row.opId); }catch(_){}
          var ts2 = 0;
          try{ ts2 = Number(row.ts || 0) || 0; }catch(_){}
          ops.push({
            source: 'cloud',
            sku: sku2,
            opId: opId2,
            delta: delta2,
            ts: ts2
          });
        }
      }
      return ops;
    }

    function simulateItemOps(){
      var index = buildItemIndex();
      if(!index.length) return [];
      var ops = collectItemOps();
      if(!ops.length) return [];
      var bySku = {};
      for(var i=0;i<index.length;i++){
        var e = index[i];
        bySku[e.key] = e;
      }
      var resultMap = {};
      for(var k=0;k<ops.length;k++){
        var op = ops[k];
        var idx = bySku[op.sku];
        if(!idx) continue;
        if(op.opId && idx.applied && idx.applied[op.opId]) continue;
        var item = idx.item;
        var resKey = item.id != null ? String(item.id) : idx.key;
        var r = resultMap[resKey];
        if(!r){
          r = {
            item: item,
            sku: op.sku,
            name: item.name || "",
            currentQty: Number(item.qty || 0),
            pendingDelta: 0,
            opCount: 0,
            localCount: 0,
            cloudCount: 0
          };
          resultMap[resKey] = r;
        }
        r.pendingDelta += op.delta;
        r.opCount++;
        if(op.source === 'local') r.localCount++;
        if(op.source === 'cloud') r.cloudCount++;
      }
      var out = [];
      for(var key in resultMap){
        if(!Object.prototype.hasOwnProperty.call(resultMap, key)) continue;
        var r = resultMap[key];
        r.simQty = r.currentQty + r.pendingDelta;
        out.push(r);
      }
      out.sort(function(a,b){
        var da = Math.abs(a.pendingDelta);
        var db = Math.abs(b.pendingDelta);
        if(db !== da) return db - da;
        var na = (a.name||"") + " " + (a.sku||"");
        var nb = (b.name||"") + " " + (b.sku||"");
        return na.localeCompare(nb);
      });
      return out;
    }

    function renderItemOpsSimulation(){
      var dlg = document.getElementById('itemOpsSimDlg');
      if(!dlg) return;
      var tbody = dlg.querySelector('tbody');
      var emptyMsg = dlg.querySelector('.emptyMsg');
      if(!tbody) return;
      while(tbody.firstChild){ tbody.removeChild(tbody.firstChild); }

      var rows;
      try{
        rows = simulateItemOps();
      }catch(e){
        rows = [];
        try{
          if(window.console && console.error) console.error(e);
          if(typeof toast === 'function') toast('Fehler bei der Simulation');
        }catch(_){}
      }

      if(!rows || !rows.length){
        if(emptyMsg) emptyMsg.style.display = '';
        return;
      }
      if(emptyMsg) emptyMsg.style.display = 'none';

      for(var i=0;i<rows.length;i++){
        var r = rows[i];
        var tr = document.createElement('tr');

        var tdName = document.createElement('td');
        tdName.textContent = r.name || '—';
        tr.appendChild(tdName);

        var tdSku = document.createElement('td');
        tdSku.textContent = r.sku || '—';
        tr.appendChild(tdSku);

        var tdCur = document.createElement('td');
        tdCur.textContent = String(r.currentQty);
        tr.appendChild(tdCur);

        var tdDelta = document.createElement('td');
        var sign = r.pendingDelta > 0 ? '+' : '';
        tdDelta.textContent = sign + String(r.pendingDelta);
        tr.appendChild(tdDelta);

        var tdSim = document.createElement('td');
        tdSim.textContent = String(r.simQty);
        tr.appendChild(tdSim);

        var tdOps = document.createElement('td');
        tdOps.textContent = r.opCount + ' (' + r.localCount + ' lokal, ' + r.cloudCount + ' Cloud)';
        tr.appendChild(tdOps);

        tbody.appendChild(tr);
      }
    }

    function ensureItemOpsSimDialog(){
      var dlg = document.getElementById('itemOpsSimDlg');
      if(dlg) return dlg;
      dlg = document.createElement('dialog');
      dlg.id = 'itemOpsSimDlg';
      dlg.className = 'modal';
      dlg.innerHTML =
        "<header>" +
          "<strong>ItemOps‑Simulation (Trockenlauf)</strong>" +
          "<button class='btn' id='btnItemOpsSimClose' type='button' style='padding:8px 12px'>Schließen</button>" +
        "</header>" +
        "<div class='content'>" +
          "<div class='table-wrap'>" +
            "<table class='list'>" +
              "<thead>" +
                "<tr>" +
                  "<th>Artikel</th>" +
                  "<th>SKU</th>" +
                  "<th>Aktuell</th>" +
                  "<th>Pendend</th>" +
                  "<th>Simuliert</th>" +
                  "<th>Ops</th>" +
                "</tr>" +
              "</thead>" +
              "<tbody></tbody>" +
            "</table>" +
          "</div>" +
          "<p class='hint emptyMsg'>Keine offenen ItemOps, die hier noch nicht angewendet wurden.</p>" +
        "</div>" +
        "<footer>" +
          "<span class='grow'></span>" +
          "<button class='btn primary' id='btnItemOpsSimOk' type='button'>OK</button>" +
        "</footer>";
      document.body.appendChild(dlg);

      var closeBtn = dlg.querySelector('#btnItemOpsSimClose');
      var okBtn = dlg.querySelector('#btnItemOpsSimOk');
      function closeDlg(){
        try{ dlg.close(); }catch(_){}
      }
      if(closeBtn) closeBtn.addEventListener('click', closeDlg);
      if(okBtn) okBtn.addEventListener('click', closeDlg);

      return dlg;
    }

    function setupItemOpsSimUI(){
      var dlg = ensureItemOpsSimDialog();

      var sec = document.getElementById('secCloud');
      if(!sec) return;

      var btn = document.getElementById('btnItemOpsSim');
      if(!btn){
        btn = document.createElement('button');
        btn.type = 'button';
        btn.id = 'btnItemOpsSim';
        btn.className = 'btn';
        btn.textContent = 'ItemOps‑Simulation';
        try{
          var testBtn = document.getElementById('btnItemOpsPull');
          if(testBtn && testBtn.parentNode){
            if(testBtn.nextSibling){
              testBtn.parentNode.insertBefore(btn, testBtn.nextSibling);
            }else{
              testBtn.parentNode.appendChild(btn);
            }
          }else{
            sec.appendChild(btn);
          }
        }catch(_){
          sec.appendChild(btn);
        }
      }

      btn.addEventListener('click', function(){
        renderItemOpsSimulation();
        try{ dlg.showModal(); }catch(_){}
      });
    }

    document.addEventListener('DOMContentLoaded', function(){
      if(!window.lvDebugItemOps) return;
      try{ setupItemOpsSimUI(); }catch(_){}
    });

    window.lvItemOpsSim = {
      simulate: simulateItemOps,
      render: renderItemOpsSimulation
    };

  }catch(_){}
})();</script>

<script>
// v82 – ItemOps-Rebase-Hook (lokaler Abgleich, ohne Bestandsänderung)
// Dieser Hook wird nach einem Cloud-Pull im zentralen Sync-Ablauf aufgerufen.
// Schritt 2: einfache Konfliktlösung nur auf ItemOps-Ebene.
// Lokale ItemOps, deren opId bereits in der Cloud-Tabelle vorhanden ist,
// werden aus lv_item_ops_local entfernt, damit sie nicht doppelt als „offen“ gezählt werden.
(function(){
  try{
    function loadJsonSafeLocal(key){
      try{
        var raw = localStorage.getItem(key);
        if(!raw) return [];
        var data = JSON.parse(raw);
        return Array.isArray(data) ? data : [];
      }catch(_){ return []; }
    }

    async function lvItemOpsRebaseAfterPull(){
      try{
        // 1) Trockenlauf-Simulation (nur für Debug / Logging)
        var sim = (window.lvItemOpsSim && typeof window.lvItemOpsSim.simulate === 'function')
          ? window.lvItemOpsSim.simulate
          : null;
        var rows = [];
        if(sim){
          try{ rows = sim() || []; }catch(_){ rows = []; }
        }

        if(window.lvDebugItemOps && window.console && typeof console.log === 'function'){
          var withDelta = 0;
          for(var i=0;i<rows.length;i++){
            var rr = rows[i] || {};
            if(typeof rr.pendingDelta === 'number' && rr.pendingDelta !== 0) withDelta++;
          }
          console.log('[lvItemOpsRebaseAfterPull] Start: %d Artikel mit offenen Deltas', withDelta);
        }

        // 2) Lokaler Abgleich lv_item_ops_local vs. lv_item_ops_cloud
        var localOps = loadJsonSafeLocal('lv_item_ops_local');
        var cloudOps = loadJsonSafeLocal('lv_item_ops_cloud');

        if(!localOps.length || !cloudOps.length){
          return;
        }

        var cloudOpIds = {};
        for(var i=0;i<cloudOps.length;i++){
          var row = cloudOps[i];
          if(!row) continue;
          var oid = '';
          try{
            if(row.opId) oid = String(row.opId);
          }catch(_){}
          if(!oid) continue;
          cloudOpIds[oid] = true;
        }
        if(!Object.keys(cloudOpIds).length){
          return;
        }

        var newLocal = [];
        var removed = 0;
        for(var j=0;j<localOps.length;j++){
          var op = localOps[j];
          if(!op){
            continue;
          }
          var oidLocal = '';
          try{
            if(op.opId) oidLocal = String(op.opId);
          }catch(_){}
          if(oidLocal && cloudOpIds[oidLocal]){
            removed++;
            continue;
          }
          newLocal.push(op);
        }

        if(removed > 0){
          try{
            localStorage.setItem('lv_item_ops_local', JSON.stringify(newLocal));
          }catch(_){}
          if(window.lvDebugItemOps && window.console && typeof console.log === 'function'){
            console.log('[lvItemOpsRebaseAfterPull] Lokaler Abgleich: %d ItemOps als in Cloud vorhanden erkannt und entfernt. Verbleibend lokal: %d', removed, newLocal.length);
          }
        }
      }catch(e){
        try{ console.error('lvItemOpsRebaseAfterPull error', e); }catch(_){}
      }
    }

    // Nur registrieren, wenn noch nicht vorhanden, um andere Implementierungen nicht zu überschreiben.
    if(typeof window.lvItemOpsRebaseAfterPull !== 'function'){
      window.lvItemOpsRebaseAfterPull = lvItemOpsRebaseAfterPull;
    }
  }catch(_){}
})();</script>

<script>
// v81 – Zentraler Sync-Ablauf (runFullSync) – noch nicht automatisch verwendet
(function(){
  try{
    async function runFullSync(options){
      options = options || {};
      var mode = (options.mode || 'full').toString().toLowerCase();
      var silent = !!options.silent;

      // 'standard' verhält sich wie 'full' – für Auto‑Sync und manuellen Sync
      var isFullLike = (mode === 'full' || mode === 'standard');
      var doPull = (isFullLike || mode === 'pull' || mode === 'pullonly');
      var doPush = (isFullLike || mode === 'push' || mode === 'pushonly');

      try{
        // 1) Pull aller Kern-Daten (Items, Gruppen, Mitglieder) – inkl. Pending-Rebase, wie bisher
        if(doPull && typeof cloudPullAll === 'function'){
          if(!silent && typeof toast === 'function'){
            try{ toast('Sync: Cloud-Pull läuft ...'); }catch(_){}
          }
          await cloudPullAll();
        }

        // 2) ItemOps aus der Cloud nachladen (optional, falls konfiguriert)
        if(doPull && typeof cloudPullItemOps === 'function'){
          try{ await cloudPullItemOps({silent: true}); }catch(_){}
        }

        // 3) ItemOps-Rebase (falls vorhanden/aktiv)
        if(doPull && typeof lvItemOpsRebaseAfterPull === 'function'){
          try{ await lvItemOpsRebaseAfterPull(); }catch(_){}
        }

        // 4) Push aller Kern-Daten
        if(doPush && typeof cloudPushAll === 'function'){
          if(!silent && typeof toast === 'function'){
            try{ toast('Sync: Cloud-Push läuft ...'); }catch(_){}
          }
          await cloudPushAll();
        }

        // 5) Outbox verarbeiten (falls vorhanden)
        if(doPush && typeof processOutbox === 'function'){
          try{ await processOutbox(); }catch(_){}
        }

        if(!silent && typeof toast === 'function'){
          try{ toast('Sync: abgeschlossen'); }catch(_){}
        }


      }catch(e){
        try{
          if(window.console && console.error) console.error('runFullSync error', e);
          if(!silent && typeof toast === 'function'){
            toast('Sync: Fehler (Details in Konsole)');
          }
        }catch(_){}
        throw e;
      }
    }

    if(typeof window.runFullSync !== 'function'){
      window.runFullSync = runFullSync;
    }
  }catch(_){}
})();</script>

<script>
// v90 – Sync beim Beenden (optionale Sicherheitsfunktion)
(function(){
  try{
    var SYNC_ON_EXIT_KEY = 'lv_sync_on_exit_enabled';
    var SYNC_ON_EXIT_FLAG = 'lv_sync_on_exit_pending';

    function isSyncOnExitEnabled(){
      try{ return localStorage.getItem(SYNC_ON_EXIT_KEY) === '1'; }catch(_){ return false; }
    }
    function setSyncOnExitEnabled(on){
      try{ localStorage.setItem(SYNC_ON_EXIT_KEY, on ? '1' : '0'); }catch(_){}
    }
    function markSyncOnNextStart(){
      try{ localStorage.setItem(SYNC_ON_EXIT_FLAG, String(Date.now())); }catch(_){}
    }
    function clearSyncOnNextStart(){
      try{ localStorage.removeItem(SYNC_ON_EXIT_FLAG); }catch(_){}
    }
    function hasPendingSyncFlag(){
      try{ return !!localStorage.getItem(SYNC_ON_EXIT_FLAG); }catch(_){ return false; }
    }

    // Best-Effort-Sync, wenn die Seite verlassen wird (App darf sich trotzdem schließen)
    function setupSyncOnExitHandler(){
      if (window.__lvSyncOnExitHandlerInstalled) return;
      window.__lvSyncOnExitHandlerInstalled = true;

      window.addEventListener('beforeunload', function(){
        if(!isSyncOnExitEnabled()) return;
        // Merken, dass wir beim nächsten Start ggf. noch einmal synchronisieren wollen
        markSyncOnNextStart();
        try{
          if(typeof runFullSync === 'function'){
            // Best-Effort: wir starten den Sync, ohne auf das Ergebnis zu warten
            runFullSync({mode:'full', silent:true});
          }else if(typeof cloudPushAll === 'function'){
            cloudPushAll().catch(function(){ /* Fehler sind hier erwartbar, App schließt trotzdem */ });
          }
        }catch(_){}
        // WICHTIG: kein preventDefault, Tab darf ganz normal schließen
      });
    }

    // Beim Start: falls beim letzten Beenden ein Sync angefordert war, noch einmal versuchen
    async function runPendingStartupSync(){
      if(!hasPendingSyncFlag()) return;
      clearSyncOnNextStart();
      try{
        if(typeof runFullSync === 'function'){
          await runFullSync({mode:'full', silent:true});
        }else if(typeof cloudPullAll === 'function' || typeof cloudPushAll === 'function'){
          // Minimal-Variante, falls runFullSync nicht existiert
          if(typeof cloudPullAll === 'function'){
            try{ await cloudPullAll(); }catch(_){}
          }
          if(typeof cloudPushAll === 'function'){
            try{ await cloudPushAll(); }catch(_){}
          }
        }
      }catch(_){}
    }

    document.addEventListener('DOMContentLoaded', function(){
      try{
        setupSyncOnExitHandler();

        var sec = document.getElementById('secCloud');
        if(!sec) return;

        var chk = document.getElementById('chkSyncOnExit');
        var auto = document.getElementById('autoSyncChk');
        var autoRow = auto && auto.parentNode ? auto.parentNode : null;

        // Gemeinsame Zeile für beide Auto-Sync-Optionen unterhalb der Hauptzeile
        var combinedRow = document.createElement('div');
        combinedRow.className = 'row';
        combinedRow.style.marginTop = '8px';
        combinedRow.style.flexWrap = 'wrap';
        combinedRow.style.gap = '10px';
        combinedRow.style.alignItems = 'center';

        // Auto-Sync nach Aktionen nach unten verschieben
        if(autoRow && autoRow.parentNode){
          autoRow.parentNode.removeChild(autoRow);
          combinedRow.appendChild(autoRow);
        }

        // Checkbox „Auto-Sync beim Schließen“ erstellen, falls noch nicht vorhanden
        if(!chk){
          chk = document.createElement('input');
          chk.type = 'checkbox';
          chk.id = 'chkSyncOnExit';
        }

        var label = chk.parentNode && chk.parentNode.tagName && chk.parentNode.tagName.toLowerCase() === 'label'
          ? chk.parentNode
          : null;

        if(!label){
          label = document.createElement('label');
          label.htmlFor = 'chkSyncOnExit';
          label.appendChild(document.createTextNode(' Auto-Sync beim Schließen'));
        }else{
          // Beschriftung aktualisieren, falls schon vorhanden
          label.htmlFor = 'chkSyncOnExit';
          label.textContent = '';
          label.appendChild(document.createTextNode(' Auto-Sync beim Schließen'));
        }

        // Sicherstellen, dass die Checkbox im Label steckt
        if(chk.parentNode !== label){
          if(chk.parentNode) chk.parentNode.removeChild(chk);
          label.insertBefore(chk, label.firstChild || null);
        }

        // Optik dem Auto-Sync-nach-Aktionen-Block anpassen
        label.style.display = 'inline-flex';
        label.style.alignItems = 'center';
        label.style.gap = '6px';

        combinedRow.appendChild(label);
        sec.appendChild(combinedRow);

        chk.checked = isSyncOnExitEnabled();
        chk.addEventListener('change', function(){
          setSyncOnExitEnabled(chk.checked);
          try{
            if(typeof toast === 'function'){
              toast(chk.checked ? 'Auto-Sync beim Schließen: aktiviert' : 'Auto-Sync beim Schließen: deaktiviert');
            }
          }catch(_){}
        });

        // Start-Sync nur still im Hintergrund ausführen
        runPendingStartupSync();
      }catch(_){}
    });
  }catch(_){}
})();</script>

<script>
// v93 – Push-Diagnose: zeige Status/Fehlertexte bei fehlgeschlagenem Cloud-Push (ohne neue Buttons)
(function(){
  try{
    function toastSafe(msg){
      try{ if(typeof toast==='function') toast(msg); }catch(_){}
    }
    // Wrap cloudPushAll, falls vorhanden, um detaillierte Fehler anzuzeigen
    if (typeof window.cloudPushAll === 'function' && !window.cloudPushAll.__lvDiagWrapped){
      var _origPushAll = window.cloudPushAll;
      window.cloudPushAll = async function(){
        try{
          return await _origPushAll.apply(this, arguments);
        }catch(e){
          try{
            var status = e && (e.status || e.code || e.name) || 'Fehler';
            var msg = e && (e.message || e.detail || e.toString()) || '';
            toastSafe('Push-Fehler: ' + status);
            try{ console.error('Push-Fehler-Details:', e); }catch(_){}
          }catch(_){}
          throw e;
        }
      };
      window.cloudPushAll.__lvDiagWrapped = true;
    }

    // Zusätzlich: globales Fetch-Monitoring für POST/PATCH/DELETE auf /rows/
    if (!window.__lvFetchDiagInstalled && typeof window.fetch === 'function'){
      window.__lvFetchDiagInstalled = true;
      var _origFetch = window.fetch;
      window.fetch = function(input, init){
        try{
          var url = (typeof input === 'string') ? input : (input && input.url) || '';
          var method = (init && (init.method || '')).toUpperCase() || 'GET';
          var isWriteRows = /\/rows\//.test(url) && method !== 'GET';
          if(isWriteRows){
            return _origFetch(input, init).then(async function(resp){
              if(!resp.ok){
                var bodyText = '';
                try{ bodyText = await resp.text(); }catch(_){}
                var info = 'HTTP ' + resp.status + ' ' + (resp.statusText||'') + '\nURL: ' + url + '\nMethode: ' + method;
                if(bodyText){ info += '\nAntwort: ' + bodyText.slice(0,400); }
                try{ console.error('Supabase Write-Fehler:', info); }catch(_){}
                toastSafe('Supabase: ' + resp.status + ' beim Schreiben (Details in Konsole)');
              }
              return resp;
            });
          }
        }catch(_){}
        return _origFetch(input, init);
      };
    }
  }catch(_){}
})();</script>

<script>
// v96 – Fix: Login unberührt lassen, Push-Button nur per Capture-Layer abfangen (kein DOM-Umbau)
(function(){
  try{
    function toastSafe(msg){ try{ if(typeof toast==='function') toast(msg); }catch(_){ } }
    function $(sel){ return document.querySelector(sel); }

    function installDirectPush(){
      var btn = $('#btnPush');
      if(!btn || btn.__lvDirectPushInstalled) return;
      // Capture-Phase: wir fangen den Klick ab, verhindern die ursprünglichen Handler (die evtl. Pull auslösen)
      btn.addEventListener('click', async function(ev){
        try{
          ev.stopImmediatePropagation();
          ev.preventDefault();
        }catch(_){}
        try{
          if (typeof cloudPushAllInternal === 'function'){
            await cloudPushAllInternal();
            toastSafe('Alle lokalen Daten hochgeladen');
          } else if (typeof cloudPushAll === 'function'){
            await cloudPushAll();
          } else if (typeof runFullSync === 'function'){
            await runFullSync({mode:'push'});
          } else {
            toastSafe('Push-Funktion nicht verfügbar');
          }
        }catch(e){
          try{ console.error('DirectPush error', e); }catch(_){}
          try{
            if(typeof queueTask==='function'){ queueTask('pushAll'); }
            toastSafe('Cloud nicht erreichbar – in Warteschlange abgelegt');
          }catch(_){}
        }
      }, true); // capture
      btn.__lvDirectPushInstalled = true;
    }

    document.addEventListener('DOMContentLoaded', function(){
      try{ installDirectPush(); }catch(_){}
    });
  }catch(_){}
})();</script>

<script>
// v97 – Schreib-Diagnose (nur Beobachtung): zeigt Status jeder Supabase-Schreibanfrage als Toast
(function(){
  try{
    function toastSafe(msg){ try{ if(typeof toast==='function') toast(msg); }catch(_){ } }
    if (!window.__lvWriteDiag97 && typeof window.fetch==='function'){
      window.__lvWriteDiag97 = true;
      var _origFetch = window.fetch;
      window.fetch = function(input, init){
        var url = (typeof input==='string') ? input : (input && input.url) || '';
        var method = (init && (init.method||'GET')).toUpperCase();
        var isWrite = /\/rows\//.test(url) && method !== 'GET';
        if(!isWrite) return _origFetch(input, init);
        return _origFetch(input, init).then(async function(resp){
          try{
            if(resp.ok){
              toastSafe('Supabase: ' + resp.status + ' ' + method + ' OK');
            }else{
              var txt=''; try{ txt = await resp.text(); }catch(_){}
              toastSafe('Supabase: ' + resp.status + ' ' + method + ' (Details in Konsole)');
              try{ console.error('Supabase write error:', resp.status, method, url, txt); }catch(_){}
            }
          }catch(_){}
          return resp;
        });
      };
    }
  }catch(_){}
})();</script>

<script>
// v98 – Log- & Datum-Merge nach Cloud-Pull (verhindert Zurücksetzen)
// Idee: Vor dem Pull lokalen Stand merken, nach dem Pull Logs/Daten mergen.
(function(){
  try{
    function toDate(x){
      try{
        if(!x) return null;
        if(x instanceof Date) return x;
        var d = new Date(x);
        return isNaN(d.getTime()) ? null : d;
      }catch(_){ return null; }
    }
    function maxDate(a,b){
      var da = toDate(a), db = toDate(b);
      if(da && db) return (da > db) ? da.toISOString() : db.toISOString();
      return (da ? da.toISOString() : (db ? db.toISOString() : null));
    }
    function minDate(a,b){
      var da = toDate(a), db = toDate(b);
      if(da && db) return (da < db) ? da.toISOString() : db.toISOString();
      return (da ? da.toISOString() : (db ? db.toISOString() : null));
    }
    function normalizeLogArray(arr){
      if(!Array.isArray(arr)) return [];
      return arr.map(function(e){
        if(!e || typeof e!=='object') return null;
        var n = {
          ts: e.ts || e.time || e.date || null,
          type: e.type || e.t || null,
          delta: (typeof e.delta==='number') ? e.delta : (typeof e.qty==='number'? e.qty : null),
          opId: e.opId || e.id || null,
          note: e.note || e.reason || null,
          user: e.user || null
        };
        return n;
      }).filter(Boolean);
    }
    function uniqueLogs(logsA, logsB){
      var out = [];
      var seen = Object.create(null);
      function keyOf(x){
        return (x.opId ? ('op:'+x.opId) : ('ts:'+ (x.ts||'') + '|d:' + (x.delta==null?'':x.delta) + '|t:' + (x.type||'')));
      }
      function pushUnique(x){
        var k = keyOf(x);
        if(seen[k]) return;
        seen[k] = 1;
        out.push(x);
      }
      logsA.forEach(pushUnique);
      logsB.forEach(pushUnique);
      // sort by ts if possible
      out.sort(function(a,b){
        var da = toDate(a.ts), db = toDate(b.ts);
        if(da && db) return da - db;
        if(da) return -1;
        if(db) return 1;
        return 0;
      });
      return out;
    }

    // Merger-Funktion: vergleicht aktuellen items[] (nach Pull) mit vorherigem Stand
    function lvMergeLogsAndDates(prevBySku){
      try{
        if(!Array.isArray(window.items) || !prevBySku) return;
        for(var i=0;i<window.items.length;i++){
          var it = window.items[i];
          if(!it || !it.sku) continue;
          var prev = prevBySku[it.sku];
          if(!prev) continue;

          // Logs mergen
          var curLogs = normalizeLogArray(it.log);
          var oldLogs = normalizeLogArray(prev.log);
          var mergedLogs = uniqueLogs(oldLogs, curLogs);
          it.log = mergedLogs;

          // created_at: ältestes Datum behalten
          it.created_at = minDate(prev.created_at, it.created_at) || it.created_at || prev.created_at || null;
          // updated_at: neuestes Datum behalten
          it.updated_at = maxDate(prev.updated_at, it.updated_at) || it.updated_at || prev.updated_at || null;
        }
      }catch(e){
        try{ console.error('lvMergeLogsAndDates error', e); }catch(_){}
      }
    }

    // Wrapper für cloudPullAll: vor Pull snapshotten, danach mergen
    if(typeof window.cloudPullAll === 'function' && !window.cloudPullAll.__lvMergeLogsInstalled){
      var _origPullAll = window.cloudPullAll;
      window.cloudPullAll = async function(){
        var snapshot = null;
        try{
          if(Array.isArray(window.items)){
            snapshot = Object.create(null);
            for(var i=0;i<window.items.length;i++){
              var it = window.items[i];
              if(!it || !it.sku) continue;
              snapshot[it.sku] = {
                created_at: it.created_at || null,
                updated_at: it.updated_at || null,
                log: Array.isArray(it.log) ? JSON.parse(JSON.stringify(it.log)) : []
              };
            }
          }
        }catch(_){}
        var res = await _origPullAll.apply(this, arguments);
        try{ lvMergeLogsAndDates(snapshot); }catch(_){}
        return res;
      };
      window.cloudPullAll.__lvMergeLogsInstalled = true;
    }

  }catch(e){
    try{ console.error('v98 merge install error', e); }catch(_){}
  }
})();</script>

<script>
// v99 – Log-Dedupe verbessert: opId priorisieren, sonst Sekundengenauigkeit + Delta/Typ;
// unterdrückt doppelte 'edit'(+0) neben echter Buchung mit gleichem Zeitstempel.
(function(){
  try{
    function toDate(x){
      try{
        if(!x) return null;
        if(x instanceof Date) return x;
        var d = new Date(x);
        return isNaN(d.getTime()) ? null : d;
      }catch(_){ return null; }
    }
    function tsToSec(x){
      var d = toDate(x);
      if(!d) return null;
      return Math.floor(d.getTime()/1000); // Sekundengenauigkeit
    }
    function isoMax(a,b){
      var da = toDate(a), db = toDate(b);
      if(da && db) return (da > db) ? da.toISOString() : db.toISOString();
      return (da ? da.toISOString() : (db ? db.toISOString() : null));
    }
    function isoMin(a,b){
      var da = toDate(a), db = toDate(b);
      if(da && db) return (da < db) ? da.toISOString() : db.toISOString();
      return (da ? da.toISOString() : (db ? db.toISOString() : null));
    }
    function normalizeLogArray(arr){
      if(!Array.isArray(arr)) return [];
      return arr.map(function(e){
        if(!e || typeof e!=='object') return null;
        var type = e.type || e.t || null;
        var delta = (typeof e.delta==='number') ? e.delta : (typeof e.qty==='number'? e.qty : (e.delta===0?0:null));
        var ts = e.ts || e.time || e.date || null;
        var o = {
          ts: ts,
          tsSec: tsToSec(ts),
          type: type,
          delta: delta,
          opId: e.opId || e.id || null,
          note: e.note || e.reason || null,
          user: e.user || null
        };
        return o;
      }).filter(Boolean);
    }
    function uniqueLogs(logsA, logsB){
      // Vereinfachtes Dedupe:
      // - opId hat Vorrang und wird strikt dedupliziert
      // - ohne opId wird nur dedupliziert, wenn alle wesentlichen Felder exakt übereinstimmen
      //   (ts, type, delta, note, user). Damit bleiben getrennte Aktionen auch dann erhalten,
      //   wenn sie in der gleichen Sekunde stattfinden.
      var out = [];
      var seenByOpId = Object.create(null);
      var seenByHash = Object.create(null);

      function hashLog(x){
        if(!x || typeof x !== 'object') return '';
        var ts = (x.ts == null ? '' : String(x.ts));
        var t  = (x.type == null ? '' : String(x.type));
        var d  = (x.delta == null ? '' : String(x.delta));
        var n  = (x.note == null ? '' : String(x.note));
        var u  = (x.user == null ? '' : String(x.user));
        return 'ts:'+ts+'|t:'+t+'|d:'+d+'|n:'+n+'|u:'+u;
      }

      function pushFrom(arr){
        if(!Array.isArray(arr)) return;
        for(var i=0;i<arr.length;i++){
          var x = arr[i];
          if(!x || typeof x !== 'object') continue;
          if(x.opId){
            if(seenByOpId[x.opId]) continue;
            seenByOpId[x.opId] = 1;
            out.push(x);
          }else{
            var h = hashLog(x);
            if(seenByHash[h]) continue;
            seenByHash[h] = 1;
            out.push(x);
          }
        }
      }

      pushFrom(logsA);
      pushFrom(logsB);

      out.sort(function(a,b){
        var da = toDate(a && a.ts), db = toDate(b && b.ts);
        if(da && db) return da - db;
        if(da) return -1;
        if(db) return 1;
        return 0;
      });
      return out;
    }

    function lvMergeLogsAndDates(prevBySku){
      try{
        if(!Array.isArray(window.items) || !prevBySku) return;
        for(var i=0;i<window.items.length;i++){
          var it = window.items[i];
          if(!it || !it.sku) continue;
          var prev = prevBySku[it.sku];
          if(!prev) continue;
          var curLogs = normalizeLogArray(it.log);
          var oldLogs = normalizeLogArray(prev.log);
          it.log = uniqueLogs(oldLogs, curLogs);
          it.created_at = isoMin(prev.created_at, it.created_at) || it.created_at || prev.created_at || null;
          it.updated_at = isoMax(prev.updated_at, it.updated_at) || it.updated_at || prev.updated_at || null;
        }
      }catch(e){
        try{ console.error('lvMergeLogsAndDates v99 error', e); }catch(_){}
      }
    }
    if(typeof window.cloudPullAll === 'function' && !window.cloudPullAll.__lvMergeLogsInstalled99){
      var _origPullAll = window.cloudPullAll;
      window.cloudPullAll = async function(){
        var snapshot = null;
        try{
          if(Array.isArray(window.items)){
            snapshot = Object.create(null);
            for(var i=0;i<window.items.length;i++){
              var it = window.items[i];
              if(!it || !it.sku) continue;
              snapshot[it.sku] = {
                created_at: it.created_at || null,
                updated_at: it.updated_at || null,
                log: Array.isArray(it.log) ? JSON.parse(JSON.stringify(it.log)) : []
              };
            }
          }
        }catch(_){}
        var res = await _origPullAll.apply(this, arguments);
        try{ lvMergeLogsAndDates(snapshot); }catch(_){}
        return res;
      };
      window.cloudPullAll.__lvMergeLogsInstalled99 = true;
    }
  }catch(_){}
})();</script>

<script>
// v100 – Full Sync: Push-first (verhindert Zurücksetzen lokaler Änderungen)
// Verhalten:
// - runFullSync({mode:'full'}) macht jetzt zuerst PUSH, danach PULL.
// - Wenn PUSH fehlschlägt (offline/Fehler): Pull wird bewusst übersprungen, damit lokale Daten nicht überschrieben werden.
// - runFullSync('push') / runFullSync('pull') bleiben unverändert.
(function(){
  try{
    function toastSafe(msg){ try{ if(typeof toast==='function') toast(msg); }catch(_){ }
    }
    if (typeof window.runFullSync === 'function' && !window.runFullSync.__lvPushFirst){
      var _origRunFullSync = window.runFullSync;
      window.runFullSync = async function(options){
        options = options || {};
        var mode = String(options.mode||'full').toLowerCase();
        var silent = !!options.silent;

        // Nur 'full' bekommt das neue Verhalten. Andere Modi bleiben 1:1.
        if(mode !== 'full'){
          return _origRunFullSync.apply(this, arguments);
        }

        // 1) PUSH zuerst
        var pushOk = true;
        try{
          // Achtung: In der aktuellen Supabase‑Variante soll *nicht* mehr das alte
          // Baserow-cloudPushAllInternal verwendet werden, weil es mit Supabase
          // nicht kompatibel ist und u.a. die Meldung "Items‑Tabelle fehlt"
          // auslöst. Deshalb rufen wir hier direkt die öffentliche
          // Supabase‑Funktion cloudPushAll auf und fallen nur noch auf
          // processOutbox() zurück.
          if(typeof cloudPushAll === 'function'){
            await cloudPushAll();
          }else if(typeof processOutbox === 'function'){
            // Fallback: nur Outbox versuchen
            await processOutbox();
          }
        }catch(e){
          pushOk = false;
          try{ console.error('FullSync Push-first: Push failed, skip pull', e); }catch(_){}
          if(!silent){
            toastSafe('Full Sync: Push fehlgeschlagen – Pull übersprungen (offline?)');
          }
        }

        // 2) Wenn Push erfolgreich: Pull nachziehen
        if(pushOk){
          try{
            // Re-use der bestehenden Pull-Logik des Originals
            return await _origRunFullSync.call(this, {mode:'pull', silent: silent});
          }catch(e2){
            try{ console.error('FullSync Push-first: Pull error', e2); }catch(_){}
            if(!silent) toastSafe('Full Sync: Pull-Fehler (Details in Konsole)');
            throw e2;
          }
        }else{
          // Push war nicht ok -> Pull bewusst ausgelassen
          return;
        }
      };
      window.runFullSync.__lvPushFirst = true;
    }
  }catch(_){}
})();</script>

<!-- v19 – Cloud-Persistenz für Warnungen & Mindestbestände + selektiver Sync + Push-first -->
<script>
(function(){
  'use strict';

  function toastSafe(m){ try{ if(typeof toast==='function') toast(m); }catch(_){ } }

  // ===== Sichtbarkeit Sync-Optionen nur mit sync_manage_options =====
  function enforceSyncOptionsVisibility(){
    try{
      var el = document.getElementById('syncOptionsDetails');
      if(!el) return;
      var can = !!(window.currentPerms && window.currentPerms.sync_manage_options);
      el.style.display = can ? '' : 'none';
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', enforceSyncOptionsVisibility);

  // ===== Standard-/Voll-Sync Auswahl lesen =====
  function readSelection(kind){
    try{
      if(kind==='standard'){
        return {
          material: !!(document.getElementById('syncStdMaterialChk') && document.getElementById('syncStdMaterialChk').checked)
        };
      }else{
        return {
          material: !!(document.getElementById('syncFullMaterialChk') && document.getElementById('syncFullMaterialChk').checked),
          groups:   !!(document.getElementById('syncFullGroupsChk') && document.getElementById('syncFullGroupsChk').checked),
          members:  !!(document.getElementById('syncFullMembersChk') && document.getElementById('syncFullMembersChk').checked),
          appcfg:   !!(document.getElementById('syncFullAppCfgChk') && document.getElementById('syncFullAppCfgChk').checked)
        };
      }
    }catch(_){}
    return { material:true };
  }

  async function cloudPushSelected(sel){
    sel = sel || {};
    if(sel.material){
      if(typeof pushItemsOnly==='function'){ await pushItemsOnly(); }
      else if(typeof cloudPushAll==='function'){ await cloudPushAll(); }
      if(typeof processOutbox==='function'){ try{ await processOutbox(); }catch(_){ } }
    }
    if(sel.groups && typeof pushGroupsOnly==='function'){ await pushGroupsOnly(); }
    if(sel.members && typeof pushMembersOnly==='function'){ await pushMembersOnly(); }
    // Warnungs-/Schwellwert-Konfiguration wird immer beim Voll‑Sync mitgeschoben
    if(sel.mode === 'full' && typeof pushAlertsSettings==='function'){ await pushAlertsSettings(); }
  }

  // Auto‑Sync → Stand// Auto‑Sync → Standard-Sync (silent)
  if (typeof window.maybeCloudPushAll === 'function' && !window.maybeCloudPushAll.__lvWrapStd){
    var __origMaybe = window.maybeCloudPushAll;
    window.maybeCloudPushAll = function(){
      try{
        var cfg = readBrConfig();
        if(cfg && cfg.autoSync && typeof window.runFullSync==='function'){
          return window.runFullSync({ mode:'standard', silent:true });
        }
      }catch(_){}
      try{ return __origMaybe.apply(this, arguments); }catch(_){}
    };
    window.maybeCloudPushAll.__lvWrapStd = true;
  }

  // Manuell ⇅ → Standard
  if (typeof window.manualSync === 'function' && !window.manualSync.__lvStd){
    var __origManual = window.manualSync;
    window.manualSync = async function(){
      if (typeof has==='function' && !has('sync_basic')){ toastSafe('Kein Recht für Standard‑Sync (sync_basic)'); return; }
      var b = document.getElementById('btnManualPush'); var prev;
      if(b){ if(b.disabled) return; b.disabled = true; prev = b.textContent; b.textContent = '...'; }
      try{
        await window.runFullSync({ mode:'standard', silent:false });
        toastSafe('Sync abgeschlossen');
      }catch(e){
        toastSafe('Sync fehlgeschlagen');
      }finally{
        if(b){ b.disabled = false; b.textContent = (typeof prev!=='undefined' ? prev : '⇅'); }
      }
    };
    window.manualSync.__lvStd = true;
  }

  // runFullSync Push-first + Auswahl
  if (typeof window.runFullSync === 'function' && !window.runFullSync.__lvSelPushFirst){
    var _origRun = window.runFullSync;
    window.runFullSync = async function(opts){
      opts = opts || {};
      var mode = String(opts.mode||'full').toLowerCase();
      var silent = !!opts.silent;
      var isStandard = (mode==='standard');
      var isFull = (mode==='full');

      var sel = readSelection(isStandard ? 'standard' : 'full');
      var doPush = (isStandard || isFull || mode==='push' || mode==='pushonly');

      // Rechte
      try{
        if(isStandard && typeof has==='function' && !has('sync_basic')){ if(!silent) toastSafe('Kein Recht für Standard‑Sync'); return; }
        if(!isStandard && (isFull || mode==='pull' || mode==='push' || mode==='pullonly' || mode==='pushonly')){
          if(typeof has==='function' && !has('sync_advanced')){ if(!silent) toastSafe('Kein Recht für Voll‑Sync'); return; }
        }
      }catch(_){}

      if(isStandard || isFull){
        var pushOk = true;
        if(doPush){
          try{ await cloudPushSelected(sel); }
          catch(e){ pushOk=false; if(!silent) toastSafe('Push fehlgeschlagen'); try{ console && console.error && console.error(e);}catch(_){ } }
        }
        if(!pushOk && (mode==='push' || mode==='pushonly')){ return; }
        try{ await cloudPullSelected(sel); }catch(_){ }
        return;
      }

      if(mode==='pull' || mode==='pullonly'){ return cloudPullSelected(sel); }
      if(mode==='push' || mode==='pushonly'){ return cloudPushSelected(sel); }

      return _origRun.apply(this, arguments);
    };
    window.runFullSync.__lvSelPushFirst = true;
  }

})();</script>
</script>

<!-- v20 – Alerts: Scope/Owner/GroupMask UI + Cloud-Bindung + Sichtbarkeits-Gating -->
<script>
(function(){
  'use strict';

  function toastSafe(m){ try{ if(typeof toast==='function') toast(m); }catch(_){ } }
  function readLS(k, def){ try{ var r=localStorage.getItem(k); return r?JSON.parse(r):def; }catch(_){ return def; } }
  function readAppCache(){ try{ return JSON.parse(localStorage.getItem('lv_app_settings_cache')||'{}') }catch(_){ return {} } }
  function writeAppCache(obj){ try{ localStorage.setItem('lv_app_settings_cache', JSON.stringify(obj||{})) }catch(_){ } }

  function getGroups(){
    var arr = readLS((typeof groupsKey==='string'?groupsKey:'lagerverwaltung_groups_v3'), []);
    return Array.isArray(arr) ? arr : [];
  }
  function getMembers(){
    var arr = readLS((typeof membersKey==='string'?membersKey:'lagerverwaltung_members_v2'), []);
    return Array.isArray(arr) ? arr : [];
  }

  // === Hydrate UI ===
  function hydrateAlertsOptionsUI(){
    try{
      var ownerSel = document.getElementById('alertsOwner');
      var groupWrap = document.getElementById('alertsGroupMask');
      if(!ownerSel || !groupWrap) return;

      // Owner list from members (username)
      var mem = getMembers();
      ownerSel.innerHTML = '';
      var optDefault = document.createElement('option'); optDefault.value=''; optDefault.textContent='— auswählen —'; ownerSel.appendChild(optDefault);
      mem.forEach(function(m){
        var o = document.createElement('option');
        o.value = (m.username||'').trim();
        o.textContent = (m.username||'').trim() + (m.group_id ? ('  ('+m.group_id+')') : '');
        ownerSel.appendChild(o);
      });

      // Group mask checkboxes (by group name)
      groupWrap.innerHTML = '<div class="hint">Wähle, welche Gruppen Warnungen sehen dürfen.</div>';
      var gr = getGroups();
      gr.forEach(function(g){
        var row = document.createElement('label');
        row.className = 'row perm-row';
        var inp = document.createElement('input');
        inp.type = 'checkbox';
        inp.className = 'perm-chk';
        inp.dataset.group = (g.name||'').trim();
        row.appendChild(inp);
        var span = document.createElement('span'); span.textContent = ' '+(g.name||'—'); row.appendChild(span);
        groupWrap.appendChild(row);
      });

      // Load current values from cache (pulled zuvor durch pullAppSettingsKeys in v19)
      var cache = readAppCache();
      var scope = (cache && cache.alerts_scope) ? String(cache.alerts_scope) : 'global';
      var owner = (cache && cache.alerts_owner) ? String(cache.alerts_owner||'') : (window.currentUserEmail||'');
      var mask = (cache && cache.alerts_group_mask) ? cache.alerts_group_mask : null;
      if(!Array.isArray(mask)){
        // Default: Gruppen mit view_alerts true
        var def = []; (getGroups()||[]).forEach(function(g){
          try{
            var p = g.perms || g.permissions || {};
            if(p.view_alerts) def.push(g.name);
          }catch(_){}
        });
        mask = def;
      }

      // Set radios
      var rLocal = document.getElementById('alertsScopeLocal');
      var rGlobal = document.getElementById('alertsScopeGlobal');
      if(scope==='local'){ rLocal.checked = true; rGlobal.checked=false; }
      else { rGlobal.checked=true; rLocal.checked=false; }
      // Set owner
      ownerSel.value = owner || '';
      // Set group mask
      Array.prototype.slice.call(groupWrap.querySelectorAll('input[type=checkbox]')).forEach(function(cb){
        cb.checked = Array.isArray(mask) ? (mask.indexOf(cb.dataset.group) !== -1) : false;
      });

      // Toggle owner/mask visibility based on scope
      toggleAlertsScopeUi();
    }catch(e){ console && console.warn && console.warn('hydrateAlertsOptionsUI failed', e); }
  }

  // UI toggle
  function toggleAlertsScopeUi(){
    var rLocal = document.getElementById('alertsScopeLocal');
    var ownerRow = document.getElementById('alertsOwnerRow');
    var groupWrap = document.getElementById('alertsGroupMask');
    var localOn = !!(rLocal && rLocal.checked);
    if(ownerRow) ownerRow.style.display = localOn ? '' : 'none';
    if(groupWrap) groupWrap.closest('.grid').style.display = localOn ? 'none' : '';
  }
  document.addEventListener('change', function(e){
    if(e && e.target && (e.target.id==='alertsScopeLocal' || e.target.id==='alertsScopeGlobal')){
      toggleAlertsScopeUi();
    }
  });

  // Save settings via upsertAppSetting()
  async function saveAlertsOptionsFromUI(){
    try{
      var rLocal = document.getElementById('alertsScopeLocal');
      var scope = (rLocal && rLocal.checked) ? 'local' : 'global';
      var owner = (document.getElementById('alertsOwner')||{}).value || (window.currentUserEmail||'');
      var mask = Array.prototype.slice.call(document.querySelectorAll('#alertsGroupMask input[type=checkbox]')).filter(function(cb){ return cb.checked }).map(function(cb){ return cb.dataset.group });

      // Persist to cloud (v19 helpers)
      if(typeof upsertAppSetting === 'function'){
        await upsertAppSetting('alerts_scope', scope);
        await upsertAppSetting('alerts_owner', owner);
        await upsertAppSetting('alerts_group_mask', mask);
      }
      // Update cache
      var cache = readAppCache(); cache.alerts_scope = scope; cache.alerts_owner = owner; cache.alerts_group_mask = mask; writeAppCache(cache);
    }catch(e){ console && console.warn && console.warn('saveAlertsOptionsFromUI failed', e); }
  }

  // Add hooks to Settings open/save
  try{
    var btnMenu = document.getElementById('btnMenu');
    if(btnMenu && !btnMenu.__alertsHydrate){
      btnMenu.addEventListener('click', function(){ try{ hydrateAlertsOptionsUI(); }catch(_){ } }, true);
      btnMenu.__alertsHydrate = true;
    }
  }catch(_){}
  try{
    var btnOk = document.getElementById('btnSettingsOk');
    if(btnOk && !btnOk.__alertsSave){
      btnOk.addEventListener('click', function(){ try{ saveAlertsOptionsFromUI(); }catch(_){ } }, true);
      btnOk.__alertsSave = true;
    }
  }catch(_){}

  // ===== Sichtbarkeits-Gating für Warnungen (Dialog & Popup) =====
  function canSeeAlerts(){
    try{
      // Basic permission
      if (typeof has==='function' && !has('view_alerts')) return false;

      var cache = readAppCache();
      var scope = (cache && cache.alerts_scope) ? String(cache.alerts_scope) : 'global';
      var owner = (cache && cache.alerts_owner) ? String(cache.alerts_owner||'') : '';
      var mask = (cache && cache.alerts_group_mask) ? cache.alerts_group_mask : null;
      var groupName = (window.currentGroupName || '').trim();

      if(scope === 'local'){
        var me = (window.currentUserEmail||'').trim();
        if(owner && me) return me === owner; // nur Besitzer
        return true; // Fallback: wenn kein Owner gesetzt, zeige dem aktuellen Benutzer
      }else{
        // global + Gruppenmaske
        if(Array.isArray(mask) && mask.length){
          if(!groupName) return false;
          return mask.indexOf(groupName) !== -1;
        }
        return true; // keine Maske hinterlegt -> sichtbar
      }
    }catch(_){}
    return true;
  }

  // Wrap openAlerts (Dialog)
  (function(){
    var link = document.getElementById('openAlerts');
    if(link && !link.__alertsGate){
      link.addEventListener('click', function(ev){
        try{
          if(!canSeeAlerts()){
            ev && ev.preventDefault();
            toastSafe('Keine Warnungen für diese Gruppe vorgesehen');
            return false;
          }
        }catch(_){}
      }, true);
      link.__alertsGate = true;
    }
  })();

  // Wrap showWarnPopup (automatische Popup-Warnungen)
  (function(){
    if (typeof window.showWarnPopup === 'function' && !window.showWarnPopup.__alertsGate){
      var _orig = window.showWarnPopup;
      window.showWarnPopup = function(){
        try{
          if(!canSeeAlerts()) return; // Popup komplett unterdrücken
        }catch(_){}
        return _orig.apply(this, arguments);
      };
      window.showWarnPopup.__alertsGate = true;
    }
  })();

  // Optional: Badge/Status etc. anpassen – bewusst weggelassen (reines Gating)

})();</script>

<script>
(function(){
  try{
    var btnMenu = document.getElementById('btnMenu');
    if(btnMenu && !btnMenu.__alertsPullOnOpen){
      btnMenu.addEventListener('click', function(){
        try{
          if(typeof pullAppSettingsKeys === 'function'){
            pullAppSettingsKeys(['alerts_scope','alerts_owner','alerts_group_mask']).then(function(){
              try{ hydrateAlertsOptionsUI(); }catch(_){ }
            });
          }
        }catch(_){ }
      }, true);
      btnMenu.__alertsPullOnOpen = true;
    }
  }catch(_){ }
})();</script>


<script>
(function(){
  try {
    // Toast utility (idempotent)
    function ensureToastContainer(){
      var id = "lv-toast-container";
      var el = document.getElementById(id);
      if(!el){
        el = document.createElement("div");
        el.id = id;
        el.style.position = "fixed";
        el.style.right = "16px";
        el.style.bottom = "16px";
        el.style.zIndex = "99999";
        el.style.maxWidth = "60vw";
        document.body.appendChild(el);
      }
      return el;
    }
    function showToast(msg){
      var cont = ensureToastContainer();
      var n = document.createElement("div");
      n.setAttribute("role","status");
      n.style.padding = "10px 14px";
      n.style.marginTop = "8px";
      n.style.borderRadius = "8px";
      n.style.boxShadow = "0 4px 16px rgba(0,0,0,0.12)";
      n.style.background = "#111";
      n.style.color = "#fff";
      n.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
      n.style.fontSize = "14px";
      n.style.lineHeight = "1.35";
      n.textContent = msg;
      cont.appendChild(n);
      setTimeout(function(){ if(n && n.parentNode){ n.parentNode.removeChild(n); } }, 6000);
    }

    // Only patch once
    if(!window.__lvFullSyncReportPatched){
      window.__lvFullSyncReportPatched = true;
      var _runFullSync = window.runFullSync;
      if(typeof _runFullSync === "function"){
        window.runFullSync = async function(opts){
          opts = opts || {};
          var mode = opts.mode || "standard";
          var silent = !!opts.silent;
          var beforeOutbox = 0;
          try {
            // Try to read current outbox length if helper present
            if (typeof window.getOutboxLength === "function") {
              beforeOutbox = window.getOutboxLength();
            } else if (Array.isArray(window.__lvOutbox)) {
              beforeOutbox = window.__lvOutbox.length;
            }
          } catch(e){ /* ignore */ }

          var res, err;
          try {
            res = await _runFullSync(opts);
          } catch(e) {
            err = e;
          }

          try {
            // Compose report only for non-standard modes & not silent
            if(!silent && (mode === "full" || mode === "push" || mode === "pull")){
              var afterOutbox = beforeOutbox;
              try {
                if (typeof window.getOutboxLength === "function") {
                  afterOutbox = window.getOutboxLength();
                } else if (Array.isArray(window.__lvOutbox)) {
                  afterOutbox = window.__lvOutbox.length;
                }
              } catch(e){ /* ignore */ }
              var pushed = Math.max(0, beforeOutbox - afterOutbox);

              // Pull counters if available
              var itemsCount = (Array.isArray(window.currentItems) ? window.currentItems.length : (window.__items && window.__items.length) || null);
              var groupsCount = (Array.isArray(window.currentGroups) ? window.currentGroups.length : null);
              var membersCount = (Array.isArray(window.currentMembers) ? window.currentMembers.length : null);

              var parts = [];
              parts.push("Push: " + (pushed != null ? pushed : "?"));
              if(itemsCount != null) parts.push("Items: " + itemsCount);
              if(groupsCount != null) parts.push("Gruppen: " + groupsCount);
              if(membersCount != null) parts.push("Benutzer: " + membersCount);

              if(err){
                showToast("Full-Sync fehlgeschlagen – " + (parts.join(" · ") || ""));
              } else {
                showToast("Full-Sync abgeschlossen – " + (parts.join(" · ") || ""));
              }
            }
          } catch(e){ /* toast must not break sync */ }

          if(err) throw err;
          return res;
        };
      }
    }
  } catch(e){ /* last-resort guard */ }
})();</script>

<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var n = document.getElementById('btnGroupNew');
    var d = document.getElementById('btnGroupDelete');
    if (n && !n.__wired){ n.addEventListener('click', createNewGroup); n.__wired = true; }
    if (d && !d.__wired){ d.addEventListener('click', deleteCurrentGroup); d.__wired = true; }
    var allowed = canManageGroups();
    if (n) n.style.display = allowed ? '' : 'none';
    if (d) d.style.display = allowed ? '' : 'none';
  }catch(_){}
});</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var n = document.getElementById('btnGroupNew');
    var d = document.getElementById('btnGroupDelete');
    if (n && !n.__wired){ n.addEventListener('click', createNewGroup); n.__wired = true; }
    if (d && !d.__wired){ d.addEventListener('click', deleteCurrentGroup); d.__wired = true; }
    var allowed = canManageGroups();
    if (n) n.style.display = allowed ? '' : 'none';
    if (d) d.style.display = allowed ? '' : 'none';
  }catch(_){}
});</script>
<script>
// Gate: darf Outbox/Sync auslösen? (sync_basic oder sync_advanced oder Admin/Lokaladmin)
function canSyncBasicOrAdvanced(){
  try{
    if (typeof isAdmin==='function' && isAdmin()) return true;
    if (typeof has==='function' && (has('sync_basic') || has('sync_advanced'))) return true;
    var v = String(localStorage.getItem('lv_admin')||'').toLowerCase();
    if (v==='1' || v==='true' || v==='yes') return true;
  }catch(_){}
  return false;
}
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var retry = document.getElementById('btnRetryOutbox');
    var banner = document.getElementById('queueBanner');
    var sendNow = document.getElementById('queueSendNow');
    var _apply = function(){
      var raw = localStorage.getItem(outboxKey)||'[]'; var arr=[]; try{arr=JSON.parse(raw)}catch(_){arr=[]}
      var outboxCount = Array.isArray(arr)?arr.length:0;
      var can = canSyncBasicOrAdvanced();
      if (retry) retry.style.display = (outboxCount>0 && can) ? '' : 'none';
      if (banner) banner.style.display = (outboxCount>0 && can) ? '' : 'none';
      if (sendNow) sendNow.disabled = !can;
    };
    _apply();
    window.addEventListener('storage', function(e){ if (e && e.key===outboxKey) _apply(); });
  }catch(_){}
});
function queueSendNowClick(){
  if (!canSyncBasicOrAdvanced()){ toast('Keine Berechtigung für Synchronisation'); return; }
  try{ if (typeof processOutbox==='function') processOutbox(); }catch(e){ if(window.console) console.error(e); }
}
</script>
<script>
// Fallback-Delegation: falls Handler verloren geht
document.addEventListener('click', function __grpSaveDelegation(e){
  try{
    var t = e.target;
    if (!t) return;
    if (t.id === 'btnSaveGroup'){
      if (typeof saveCurrentGroup === 'function') saveCurrentGroup();
    }
  }catch(_){}
});</script>
<script>
// --- Buchungs-Schnellsuche (Name/SKU) ---
(function(){
  function nrm(v){ return String(v||'').toLowerCase().trim(); }
  function bookBuildOptions(list){
    try{
      var sel = document.getElementById('bookItem');
      if (!sel) return;
      sel.innerHTML = '';
      (list||[]).forEach(function(it){
        if(!it) return;
        var opt = document.createElement('option');
        opt.value = it.id;
        var qty = Number(it.qty)||0;
        var sku = it.sku ? ' ('+it.sku+')' : '';
        opt.textContent = (it.name||'') + sku + ' · Bestand: ' + qty;
        sel.appendChild(opt);
      });
    }catch(_){}
  }
  function bookApplyFilter(){
    try{
      var q = nrm(document.getElementById('bookSearch') && document.getElementById('bookSearch').value);
      if (!q){ bookBuildOptions(window.items||[]); return; }
      var src = Array.isArray(window.items) ? window.items : [];
      var filtered = src.filter(function(it){
        return nrm(it && it.name).indexOf(q) !== -1
            || nrm(it && it.sku).indexOf(q) !== -1
            || String(it && it.id).indexOf(q) !== -1;
      });
      bookBuildOptions(filtered);
      // First result selected for Enter→focus
      var sel = document.getElementById('bookItem');
      if (sel && sel.options.length){ sel.value = sel.options[0].value; }
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    try{
      var s = document.getElementById('bookSearch');
      var sel = document.getElementById('bookItem');
      if (s){
        s.addEventListener('input', bookApplyFilter);
        s.addEventListener('keydown', function(e){
          if (e.key === 'Enter'){
            e.preventDefault();
            if (sel && sel.options.length){ sel.focus(); }
          }
        });
      }
      // Beim Öffnen des Buchungsdialogs (Buttons) Suchfeld zurücksetzen
      var btnIn = document.getElementById('btnBookIn');
      var btnOut = document.getElementById('btnBookOut');
      var reset = function(){ if(s){ s.value=''; } };
      if (btnIn) btnIn.addEventListener('click', reset);
      if (btnOut) btnOut.addEventListener('click', reset);
    }catch(_){}
  });
  // Exponieren für manuelles Triggern (optional)
  window.bookApplyFilter = bookApplyFilter;
})();</script>

<script id="lv-pw-ux-v006">
(function(){
  'use strict';
  var MIN_PW_LEN = 4;

  function $(id){ return document.getElementById(id); }
  function text(el, s){ if (el) el.textContent = s; }

  // toast fallback (non-intrusive)
  window.lvToast = window.lvToast || function(msg, ms){
    try{
      var el = $('toast');
      if(!el){ alert(String(msg)); return; }
      text(el, String(msg));
      el.classList.add('show');
      setTimeout(function(){ el.classList.remove('show'); }, ms || 1800);
    }catch(e){ try{console.error(e);}catch(_){} }
  };

  function isValidPw(pw){ return String(pw||'').length >= MIN_PW_LEN; }

  // --- LOGIN ---
  function handleLoginClick(e){
    try{
      var u = ($('loginEmail') && $('loginEmail').value || '').trim();
      var p = ($('loginPass') && $('loginPass').value || '');
      if(!u){
        e.preventDefault(); e.stopImmediatePropagation();
        lvToast('Bitte Benutzernamen eingeben.');
        if($('loginEmail')) $('loginEmail').focus();
        return;
      }
      if(!isValidPw(p)){
        e.preventDefault(); e.stopImmediatePropagation();
        lvToast('Passwort zu kurz (min. 4 Zeichen).');
        if($('loginPass')){ $('loginPass').focus(); $('loginPass').select && $('loginPass').select(); }
        return;
      }
      // ansonsten: durchlassen zum bestehenden Handler
    }catch(err){ try{console.error(err)}catch(_){} }
  }

  function bindLogin(){
    var btn = $('btnLoginGo');
    if(btn && !btn._lv_pw_guard){
      btn.addEventListener('click', handleLoginClick, true); // capture: vor evtl. bestehendem Handler
      btn._lv_pw_guard = true;
    }
    var le = $('loginEmail'), lp = $('loginPass');
    function onEnter(ev){
      if(ev && ev.key === 'Enter'){
        ev.preventDefault();
        var b = $('btnLoginGo');
        if(b) b.click();
      }
    }
    if(le && !le._lv_enter){ le.addEventListener('keydown', onEnter); le._lv_enter = true; }
    if(lp && !lp._lv_enter){ lp.addEventListener('keydown', onEnter); lp._lv_enter = true; }
  }

  // --- Konto: eigenes Passwort ändern ---
  function bindAccountPw(){
    var pw1 = $('accPwNew');
    var pw2 = $('accPwRepeat');
    var show = $('accPwShow');
    var gen = $('accPwGen');
    var save = $('accPwSave');

    if(show && !show._lv_bind){
      show.addEventListener('change', function(){
        var t = show.checked ? 'text' : 'password';
        if(pw1) pw1.type = t;
        if(pw2) pw2.type = t;
      });
      show._lv_bind = true;
    }

    if(gen && !gen._lv_bind){
      gen.addEventListener('click', function(){
        var s = Math.random().toString(36).slice(2, 10) + Math.random().toString(36).slice(2, 6);
        if(pw1) pw1.value = s;
        if(pw2) pw2.value = s;
        if(pw1) pw1.focus();
        lvToast('Passwort vorgeschlagen – bitte speichern.');
      });
      gen._lv_bind = true;
    }

    function onSave(e){
      var a = (pw1 && pw1.value) || '';
      var b = (pw2 && pw2.value) || '';
      if(!isValidPw(a)){
        e.preventDefault(); e.stopImmediatePropagation();
        lvToast('Neues Passwort ist zu kurz (min. 4 Zeichen).');
        if(pw1){ pw1.focus(); pw1.select && pw1.select(); }
        return;
      }
      if(a !== b){
        e.preventDefault(); e.stopImmediatePropagation();
        lvToast('Passwörter stimmen nicht überein.');
        if(pw2){ pw2.focus(); pw2.select && pw2.select(); }
        return;
      }
    }

    if(save && !save._lv_pw_guard){
      save.addEventListener('click', onSave, true); // capture: vor bestehendem Handler
      save._lv_pw_guard = true;
    }
  }

  // --- Optional: "Benutzer-Passwort setzen" (im Mitgliederbereich), falls vorhanden ---
  function bindMemberPw(){
    var btns = document.querySelectorAll('[data-action="member-set-password"], #btnMemberSetPw');
    if(!btns || !btns.length) return;
    btns.forEach(function(btn){
      if(btn._lv_pw_guard) return;
      btn.addEventListener('click', function(e){
        // Erwartetes Muster: es gibt zwei Inputs mit IDs/Names wie memberPwNew / memberPwRepeat – tolerant suchen.
        var p1 = document.querySelector('#memberPwNew, [name="memberPwNew"]');
        var p2 = document.querySelector('#memberPwRepeat, [name="memberPwRepeat"]');
        var a = (p1 && p1.value) || '';
        var b = (p2 && p2.value) || '';
        if(!isValidPw(a)){
          e.preventDefault(); e.stopImmediatePropagation();
          lvToast('Benutzer-Passwort ist zu kurz (min. 4 Zeichen).');
          if(p1){ p1.focus(); p1.select && p1.select(); }
          return;
        }
        if(a !== b){
          e.preventDefault(); e.stopImmediatePropagation();
          lvToast('Benutzer-Passwörter stimmen nicht überein.');
          if(p2){ p2.focus(); p2.select && p2.select(); }
          return;
        }
      }, true);
      btn._lv_pw_guard = true;
    });
  }

  document.addEventListener('DOMContentLoaded', function(){
    bindLogin();
    bindAccountPw();
    bindMemberPw();
  });
})();</script>


<script id="lv-login-ux-v007">
(function(){
  'use strict';
  function $(id){ return document.getElementById(id); }

  function focusLoginFields(){
    try{
      var email = $('loginEmail');
      var pass  = $('loginPass');
      if(!email && !pass) return;
      var u = (email && (email.value||'').trim()) || '';
      if(email && !u){ email.focus(); return; }
      if(pass){ pass.focus(); try{ pass.select && pass.select(); }catch(_){ } }
    }catch(e){ try{console.error(e);}catch(_){ } }
  }

  function bindDialogEnter(){
    var dlg = $('pwDlg');
    if(!dlg || dlg._lv_enter_bound) return;

    dlg.addEventListener('keydown', function(ev){
      if(ev.key !== 'Enter') return;
      var tag = (ev.target && ev.target.tagName || '').toLowerCase();
      if(tag === 'textarea') return;
      var btn = $('btnLoginGo');
      if(btn){
        ev.preventDefault();
        btn.click();
      }
    });
    dlg._lv_enter_bound = true;
  }

  function preventDoubleClick(){
    var btn = $('btnLoginGo');
    if(!btn || btn._lv_dbl_guard) return;
    btn.addEventListener('click', function(ev){
      if(btn.disabled){ ev.preventDefault(); ev.stopImmediatePropagation(); return; }
      btn.disabled = true;
      setTimeout(function(){ btn.disabled = false; }, 1200);
    }, true); // capture, frühzeitig
    btn._lv_dbl_guard = true;
  }

  // Observe dialog visibility to focus on open
  function isVisible(el){
    if(!el) return false;
    var style = window.getComputedStyle(el);
    var visible = (style.display !== 'none') && (style.visibility !== 'hidden') && el.offsetParent !== null;
    if(el.classList && el.classList.contains('lv-visible')) visible = true;
    return visible;
  }

  function observeLoginOpen(){
    var dlg = $('pwDlg');
    if(!dlg) return;
    if(!dlg._lv_obs){
      var mo = new MutationObserver(function(){
        if(isVisible(dlg)) setTimeout(focusLoginFields, 0);
      });
      mo.observe(dlg, { attributes:true, attributeFilter:['class','style'] });
      dlg._lv_obs = mo;
    }
    // initial
    if(isVisible(dlg)) setTimeout(focusLoginFields, 0);
  }

  document.addEventListener('DOMContentLoaded', function(){
    bindDialogEnter();
    preventDoubleClick();
    observeLoginOpen();
    // Falls der Dialog programmgesteuert nachträglich in den DOM gehängt wird:
    setTimeout(function(){ bindDialogEnter(); preventDoubleClick(); observeLoginOpen(); }, 300);
  });
})();</script>


<script id="lv-outbox-gate-v008">
(function(){
  'use strict';
  function $(id){ return document.getElementById(id); }
  function toastSafe(msg){
    try{ if (typeof toast==='function') toast(msg); else alert(String(msg)); }catch(_){ alert(String(msg)); }
  }
  function canSync(){
    try{
      if (typeof canSyncBasicOrAdvanced==='function') return !!canSyncBasicOrAdvanced();
      if (typeof isAdmin==='function' && isAdmin()) return true;
      if (typeof has==='function' && (has('sync_basic') || has('sync_advanced'))) return true;
      var v = String(localStorage.getItem('lv_admin')||'').toLowerCase();
      return (v==='1'||v==='true'||v==='yes');
    }catch(_){ return false; }
  }
  function outboxCount(){
    try{ var raw = localStorage.getItem(outboxKey)||'[]'; var arr = JSON.parse(raw); return Array.isArray(arr)?arr.length:0; }catch(_){ return 0; }
  }
  function applyOutboxUI(){
    try{
      var retry = $('btnRetryOutbox');
      var sendNow = $('queueSendNow');
      var count = outboxCount();
      var can = canSync();
      // Retry-Button bleibt an Outbox + Rechten gekoppelt
      if (retry){ retry.style.display = (count>0 && can) ? '' : 'none'; }
      // Button "Jetzt senden" bleibt sauber an Berechtigung gekoppelt
      if (sendNow){ sendNow.disabled = !can; }
      // Sichtbarkeit & Text des Warteschlangen-Banners werden ausschließlich
      // von updateQueueStatus() gesteuert, um Flackern zu vermeiden.
    }catch(_){}
  }
  function applyManualSyncUI(){
    try{
      var btn = $('btnManualPush');
      if(!btn) return;
      // Falls die bestehende Logik bereits entscheidet, nicht überschreiben – nur absichern
      var cfg = (typeof readBrConfig === 'function') ? readBrConfig() : {};
      var auto = !!(cfg && cfg.autoSync);
      if (auto || !canSync()){ btn.setAttribute('aria-disabled','true'); }
      else { btn.removeAttribute('aria-disabled'); }
    }catch(_){}
  }

  // Click guards (capture) – verhindern Ausführung auch bei fremden Bindings
  document.addEventListener('click', function(ev){
    var t = ev.target;
    if(!t) return;
    var el = t.closest ? t.closest('#btnRetryOutbox, #queueSendNow, #btnManualPush') : null;
    if(!el) return;
    if (el.id === 'btnManualPush'){
      if (!canSync()){
        ev.preventDefault(); ev.stopImmediatePropagation();
        toastSafe('Keine Berechtigung für Synchronisation.');
      }
      return;
    }
    // For outbox actions
    if (el.id === 'btnRetryOutbox' || el.id === 'queueSendNow'){
      if (!canSync()){
        ev.preventDefault(); ev.stopImmediatePropagation();
        toastSafe('Keine Berechtigung für Synchronisation.');
        return;
      }
      if (outboxCount()<=0){
        ev.preventDefault(); ev.stopImmediatePropagation();
        toastSafe('Keine Einträge in der Warteschlange.');
        return;
      }
    }
  }, true);

  // Initial & reactive apply
  document.addEventListener('DOMContentLoaded', function(){
    applyOutboxUI();
    applyManualSyncUI();
  });
  window.addEventListener('storage', function(e){
    if (e && e.key===outboxKey){ applyOutboxUI(); }
    if (e && (e.key==='lv_admin' || e.key==='lv_session')){ applyOutboxUI(); applyManualSyncUI(); }
  });
  // Fallback: periodisch leichtgewichtig prüfen (sehr selten)
  setInterval(function(){ applyOutboxUI(); }, 3000);
})();</script>


<script id="lv-outbox-banner-v009">
(function(){
  'use strict';
  function $(id){ return document.getElementById(id); }
  function canSync(){
    try{
      if (typeof canSyncBasicOrAdvanced==='function') return !!canSyncBasicOrAdvanced();
      if (typeof isAdmin==='function' && isAdmin()) return true;
      if (typeof has==='function' && (has('sync_basic') || has('sync_advanced'))) return true;
      var v = String(localStorage.getItem('lv_admin')||'').toLowerCase();
      return (v==='1'||v==='true'||v==='yes');
    }catch(_){ return false; }
  }
  function outboxCount(){
    try{ var raw = localStorage.getItem(outboxKey)||'[]'; var arr = JSON.parse(raw); return Array.isArray(arr)?arr.length:0; }catch(_){ return 0; }
  }
  function ensureBadges(){
    var banner = $('queueBanner');
    if(!banner) return null;
    // Create a small inline badge row if not present
    var row = banner.querySelector('.lv-badge-row');
    if(!row){
      row = document.createElement('div');
      row.className = 'lv-badge-row';
      row.style.display = 'flex';
      row.style.gap = '8px';
      row.style.alignItems = 'center';
      row.style.marginTop = '6px';
      banner.appendChild(row);
    }
    var bCount = $('queueBadgeCount');
    if(!bCount){
      bCount = document.createElement('span');
      bCount.id = 'queueBadgeCount';
      bCount.className = 'badge';
      bCount.style.display = 'inline-block';
      bCount.style.padding = '2px 6px';
      bCount.style.borderRadius = '999px';
      bCount.style.fontSize = '11px';
      bCount.style.lineHeight = '14px';
      bCount.style.border = '1px solid currentColor';
      row.appendChild(bCount);
    }
    var bPerm = $('queueBadgePerm');
    if(!bPerm){
      bPerm = document.createElement('span');
      bPerm.id = 'queueBadgePerm';
      bPerm.className = 'badge';
      bPerm.style.display = 'inline-block';
      bPerm.style.padding = '2px 6px';
      bPerm.style.borderRadius = '999px';
      bPerm.style.fontSize = '11px';
      bPerm.style.lineHeight = '14px';
      bPerm.style.border = '1px solid currentColor';
      row.appendChild(bPerm);
    }
    return { row: row, bCount: bCount, bPerm: bPerm };
  }
  function applyBadges(){
    var parts = ensureBadges();
    if(!parts) return;
    var count = outboxCount();
    var can = canSync();
    parts.bCount.textContent = (count>0 ? (count+' in Warteschlange') : 'leer');
    parts.bCount.setAttribute('aria-label', 'Outbox: ' + parts.bCount.textContent);
    parts.bPerm.textContent = can ? 'berechtigt' : 'kein Recht';
    parts.bPerm.setAttribute('aria-label', 'Sync-Recht: ' + parts.bPerm.textContent);
  }
  function applyTitle(){
    var banner = $('queueBanner');
    if(!banner) return;
    var count = outboxCount();
    var can = canSync();
    var title = (count>0 ? (count+' wartende Einträge. ') : 'Keine wartenden Einträge. ')
              + (can ? 'Berechtigung vorhanden.' : 'Keine Berechtigung.');
    banner.setAttribute('title', title);
  }
  function applyAll(){ applyBadges(); applyTitle(); }
  document.addEventListener('DOMContentLoaded', applyAll);
  window.addEventListener('storage', function(e){
    if(!e) return;
    if(e.key===outboxKey || e.key==='lv_admin' || e.key==='lv_session'){ applyAll(); }
  });
  setInterval(applyAll, 3000);
})();</script>


<script id="lv-cat-normalize-v010">
(function(){
  'use strict';
  // safe helpers
  function $(sel){ return document.querySelector(sel) }
  function $all(sel){ return Array.prototype.slice.call(document.querySelectorAll(sel) || []); }
  function norm(v){
    try{
      if (typeof normalizeCategory === 'function') return normalizeCategory(v);
    }catch(_){}
    return (v==null?'':String(v));
  }
  function catShort(uiName){
    try{
      if (typeof CAT_SHORT === 'object' && CAT_SHORT && CAT_SHORT[uiName]) return CAT_SHORT[uiName];
    }catch(_){}
    return '';
  }

  // 1) Rendering: patch category chip/label after list renders
  function patchRenderedCategoryChips(){
    try{
      // Heuristik: Elemente mit data-cat oder [data-field="category"]
      var nodes = $all('[data-cat], [data-field="category"]');
      nodes.forEach(function(el){
        var raw = el.getAttribute('data-cat') || el.textContent || '';
        var ui = norm(raw);
        // Textinhalt angleichen
        if (ui && el.childElementCount===0 && (el.hasAttribute('data-cat') || el.getAttribute('data-field')==='category')){ if (ui !== (el.textContent||'')) el.textContent = ui; }
        // data-short für Badge
        var sc = catShort(ui);
        if (sc){ el.setAttribute('data-short', sc); }
      });
    }catch(_){}
  }

  // 2) Filter: normalize both sides before compare
  // Hook: wenn es ein Kategoriefilter-Select gibt (#catFilter / #filterCategory), patchen wir dessen Change-Handler leicht.
  function patchCategoryFilter(){
    var sel = $('#catFilter') || $('#filterCategory');
    if (!sel) return;
    if (sel._lv_norm_bound) return;
    sel.addEventListener('change', function(){
      try{ patchRenderedCategoryChips(); }catch(_){}
    });
    sel._lv_norm_bound = true;
  }

  // 3) Monkey-patch: wrap a common compare util if vorhanden
  // nrm(): häufige Utility; wir ergänzen nrmCat(v) = nrm(normalizeCategory(v))
  if (!window.nrmCat){
    window.nrmCat = function(v){
      try{
        var s = (typeof normalizeCategory === 'function') ? normalizeCategory(v) : (v||'');
        if (typeof nrm === 'function') return nrm(s);
        return String(s||'').trim().toLowerCase();
      }catch(_){
        try{ return String(v||'').trim().toLowerCase(); }catch(_){ return '' }
      }
    };
  }

  // 4) Patch: wenn es eine Funktion buildFilter/renderOverview gibt, wickeln wir deren Vergleich vorsichtig
  // Wir hängen keine Logik um, sondern stellen nur nrmCat(...) bereit und lassen bestehende Vergleiche davon profitieren.
  // (Viele Stellen rufen bereits nrm(...) auf – durch nrmCat erhalten sie Normalisierung gratis, wenn sie es nutzen.)
  // Leichtes After-render-Hook für die üblichen Render-Einstiegspunkte:
  function hookAfterRender(){
    try{
      patchRenderedCategoryChips();
    }catch(_){}
  }
  // global leichte Hooks, ohne bestehende Implementierungen anzutasten
  document.addEventListener('DOMContentLoaded', function(){
    try{ patchCategoryFilter(); hookAfterRender(); }catch(_){}
  });
  window.addEventListener('storage', function(e){
    if (e && e.key && e.key.indexOf('items')>=0){
      try{ hookAfterRender(); }catch(_){}
    }
  });
  // periodisch sanft aktualisieren (kollisionsarm)
  setInterval(patchRenderedCategoryChips, 2500);
})();</script>


<script id="lv-cat-save-v011">
(function(){
  'use strict';
  function $(id){ return document.getElementById(id); }
  function getCatInput(){
    var el = document.getElementById('category');
    if (el) return el;
    try{ el = document.querySelector('[name="category"]'); }catch(_){}
    return el || null;
  }
  function enabled(){
    try{
      var v = String(localStorage.getItem('lv_cat_save_normalize')||'1').toLowerCase();
      return !(v==='0' || v==='false' || v==='no');
    }catch(_){ return true; }
  }
  function onSaveCapture(ev){
    if (!enabled()) return;
    try{
      var cat = getCatInput();
      if (!cat) return;
      var val = (cat.value==null?'':String(cat.value));
      if (typeof normalizeCategory === 'function'){
        var ui = normalizeCategory(val);
        if (ui && ui !== val){ cat.value = ui; }
      }
    }catch(_){ /* no-op */ }
  }
  document.addEventListener('DOMContentLoaded', function(){
    var btn = $('btnSave');
    if (btn && !btn._lv_cat_bind){
      btn.addEventListener('click', onSaveCapture, true);
      btn._lv_cat_bind = true;
    }
  });
})();</script>


<script id="lv-v015-selftest-status">
(function(){
  'use strict';
  function $(id){ return document.getElementById(id); }

  // --- Cloud-Status: einheitliche Anzeige ---
  window.setCloudStatus = window.setCloudStatus || function(state){
    try{
      var pill = $('statusCloud');
      var hint = $('cloudStatus');
      var txt = 'Cloud: ' + (state==='online' ? 'online' : (state==='fehler' ? 'Fehler' : 'offline'));
      if(pill) pill.textContent = txt;
      if(hint) hint.textContent = 'Status: ' + (state==='online' ? 'online' : (state==='fehler' ? 'Fehler' : 'offline'));
    }catch(_){}
  };

  // --- Kopplung Outbox-Zähler ↔ Status-Pill ---
  function outboxCount(){
    try{
      var raw = localStorage.getItem(outboxKey) || '[]';
      var arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr.length : 0;
    }catch(_){ return 0; }
  }
  function applyStatusQueue(){
    // Ab V70 steuert updateQueueStatus() die Anzeige und den Text
    // für die Status-Pill „Sync ausstehend“, inklusive Pending-ops
    // und Outbox-Bestand. Diese Funktion delegiert nur noch dorthin,
    // um widersprüchliche Updates und Flackern zu vermeiden.
    try{
      if (typeof updateQueueStatus === 'function'){
        updateQueueStatus();
        return;
      }
    }catch(_){}
    // Fallback: alte Logik (nur Outbox) – wird normalerweise nicht mehr benötigt
    var pill = $('statusQueue');
    if(!pill) return;
    var n = outboxCount();
    if(n>0){
      pill.style.display='inline-block';
      pill.textContent = 'Sync ausstehend: ' + n;
    }else{
      pill.style.display='none';
    }
  }
  document.addEventListener('DOMContentLoaded', applyStatusQueue);
  window.addEventListener('storage', function(e){
    if(e && e.key===outboxKey){ applyStatusQueue(); }
  });
  setInterval(applyStatusQueue, 2500);

  // --- Selftest: Ergebnis auf Cloud-Status mappen (best-effort, nicht invasiv) ---
  // Wir dekorieren cloudSelftest minimal, ohne es neu zu schreiben.
  if (typeof window.cloudSelftest === 'function' && !window._lv_v015_wrap) {
    var orig = window.cloudSelftest;
    window.cloudSelftest = function(){
      try{
        var resEl = $('cloudSelftestResult');
        if(resEl) resEl.setAttribute('data-start', Date.now());
      }catch(_){}
      var p = orig.apply(this, arguments);
      // p kann Promise sein – wir versuchen, nach DOM-Update den Status zu lesen
      setTimeout(function(){
        try{
          var box = $('cloudSelftestResult');
          if(!box){ return; }
          var html = box.innerHTML || '';
          if (html.indexOf('lv-dot-err') < 0 && html.trim().length){ setCloudStatus('online'); }
        }catch(_){}
      }, 400);
      return p;
    };
    window._lv_v015_wrap = true;
  }
})();</script>


<script id="lv-v018-history-usernames">
(function(){
  'use strict';
  function $(q){ return document.querySelector(q); }
  function $all(q){ return Array.prototype.slice.call(document.querySelectorAll(q)||[]); }
  function isLocalAdmin(){
    try{
      var v = String(localStorage.getItem('lv_admin')||'').toLowerCase();
      return (v==='1'||v==='true'||v==='yes');
    }catch(_){ return false; }
  }
  function has(p){
    try{ return (typeof window.has==='function') ? window.has(p) : false; }catch(_){ return false; }
  }
  function isAdminSafe(){
    try{ return (typeof window.isAdmin==='function') ? window.isAdmin() : false; }catch(_){ return false; }
  }
  function canSeeHistoryUsernames(){
    // explicit perm first
    try{ if (has('view_history_usernames')) return true; }catch(_){}
    // admin helpers
    if (isAdminSafe()) return true;
    if (isLocalAdmin()) return true;
    // currentPerms fallback (if exposed globally)
    try{
      var cp = window.currentPerms || window.perms || {};
      if (cp && (cp.admin === true || cp.is_admin === true || String(cp.role||'').toLowerCase()==='admin')) return true;
    }catch(_){}
    return false;
  }
  window.canSeeHistoryUsernames = canSeeHistoryUsernames;

  // Hide/Show Benutzer column in the global History dialog
  function applyHistoryUserColumn(){
    var tbody = $('#historyTable tbody');
    var thead = $('#historyTable thead');
    if(!tbody || !thead) return;
    var show = canSeeHistoryUsernames();
    // Benutzer column index is 1 (0=Zeitpunkt,1=Benutzer,...)
    var idx = 1;
    // header
    var ths = thead.querySelectorAll('th');
    if (ths && ths[idx]) ths[idx].style.display = show ? '' : 'none';
    // rows
    $all('#historyTable tbody tr').forEach(function(tr){
      var cell = tr.cells && tr.cells[idx];
      if (cell){ cell.style.display = show ? '' : 'none'; }
    });
  }

  // Forward helper (not wired): attach current user to a history entry object
  window.stampHistoryUser = function(entry){
    try{
      var e = entry || {};
      var sess = {};
      try{ sess = JSON.parse(localStorage.getItem('lv_session')||'{}'); }catch(_){}
      var name = sess && (sess.userName || sess.username || sess.user || sess.email || sess.name) || '';
      var uid  = sess && (sess.userId || sess.user_id || sess.memberId || sess.member_id || '') || '';
      if (name) e.user = String(name);
      if (uid)  e.user_id = String(uid);
      return e;
    }catch(_){ return entry; }
  };

  document.addEventListener('DOMContentLoaded', applyHistoryUserColumn);
  // Re-apply when history might be (re)rendered
  ['click','input','change','toggle'].forEach(function(ev){
    document.addEventListener(ev, function(e){
      if ((e.target && (e.target.id==='openHistory' || e.target.id==='btnHistoryOk' || e.target.id==='btnHistoryExport')) ||
          (e.target && (e.target.id==='histSearch' || e.target.id==='histType' || e.target.id==='histFrom' || e.target.id==='histTo'))){
        setTimeout(applyHistoryUserColumn, 50);
      }
    }, true);
  });
  window.addEventListener('storage', function(e){
    if(e && e.key==='lv_session'){ setTimeout(applyHistoryUserColumn, 50); }
  });
  // periodic light safeguard
  setInterval(applyHistoryUserColumn, 2000);
})();</script>


<script id="lv-v020-stamp-helper">
(function(){
  'use strict';
  if (!window.stampHistoryUser) {
    window.stampHistoryUser = function(entry){
      try{
        var e = entry || {};
        var sess = {};
        try{ sess = JSON.parse(localStorage.getItem('lv_session')||'{}'); }catch(_){}
        var name = sess && (sess.userName || sess.username || sess.user || sess.email || sess.name) || '';
        var uid  = sess && (sess.userId || sess.user_id || sess.memberId || sess.member_id || '') || '';
        if (name) e.user = String(name);
        if (uid)  e.user_id = String(uid);
        try{
          var m = e.meta && typeof e.meta==='object' ? e.meta : {};
          if (name && !m.user) m.user = e.user;
          if (uid && !m.user_id) m.user_id = e.user_id;
          e.meta = m;
        }catch(_){}
        return e;
      }catch(_){ return entry; }
    };
  }
})();</script>


<script>
// v021 – DOM-basierte Textsuche im globalen History-Dialog (vorsichtig, Anzeige-only)
(function(){
  try{
    function applyHistTextFilter(){
      var dlg = document.getElementById('historyDlg');
      var table = document.getElementById('historyTable');
      var input = document.getElementById('histSearch');
      var countEl = document.getElementById('histCount');
      if (!dlg || !table || !input) return;
      var q = (input.value || '').toString().trim().toLowerCase();
      var rows = table.tBodies && table.tBodies[0] ? table.tBodies[0].rows : null;
      if (!rows) return;
      var visible = 0;
      for (var i=0;i<rows.length;i++){
        var row = rows[i];
        var txt = (row.textContent || row.innerText || '').toLowerCase();
        var show = !q || txt.indexOf(q) >= 0;
        row.style.display = show ? '' : 'none';
        if (show) visible++;
      }
      if (countEl){
        try{
          countEl.textContent = visible + ' Einträge';
        }catch(_){}
      }
    }

    function wireHistSearch(){
      var input = document.getElementById('histSearch');
      if (!input || input.__lvHistWired) return;
      input.__lvHistWired = true;
      input.addEventListener('input', function(){
        try{ applyHistTextFilter(); }catch(_){}
      });
    }

    // beim Öffnen der Historie Suchfeld leeren + Filter neu anwenden
    if (typeof window.openHistory === 'function' && !window.openHistory.__lvHistWrap){
      var _origOpenHistory = window.openHistory;
      window.openHistory = function(){
        var rv = _origOpenHistory.apply(this, arguments);
        try{
          wireHistSearch();
          var input = document.getElementById('histSearch');
          if (input){
            input.value = '';
            applyHistTextFilter();
          }
        }catch(_){}
        return rv;
      };
      window.openHistory.__lvHistWrap = true;
    }

    // Fallback: nach DOM-Ready verdrahten, falls Dialog bereits offen
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){
        try{ wireHistSearch(); }catch(_){}
      });
    } else {
      wireHistSearch();
    }

    // optional: bei erneutem Anzeigen nach pageshow verdrahten
    window.addEventListener('pageshow', function(){
      try{ wireHistSearch(); }catch(_){}
    });
  }catch(_){}
})();</script>


<script>
(function(){
  'use strict';

  // Lokaler Storage-Key + App-Settings-Key
  var START_NOTICE_KEY      = 'lv_start_notice';
  var START_NOTICE_APP_KEY  = 'start_notice';

  function readStartNotice(){
    var cfg = {
      enabled: false,
      text: '',
      onLogin: true,
      onSync: false,
      targetGroupId: 'ALL'
    };
    var hasFlags = false;

    // 1) Lokale Konfiguration lesen
    try {
      var local = null;
      if (typeof loadJson === 'function') {
        local = loadJson(START_NOTICE_KEY, null);
      } else if (typeof localStorage !== 'undefined') {
        var raw = localStorage.getItem(START_NOTICE_KEY);
        local = raw ? JSON.parse(raw) : null;
      }
      if (local && typeof local === 'object') {
        if (typeof local.enabled === 'boolean') cfg.enabled = local.enabled;
        if (typeof local.text === 'string')    cfg.text    = local.text;
        if ('onLogin' in local || 'onSync' in local) {
          hasFlags = true;
          if (typeof local.onLogin === 'boolean') cfg.onLogin = local.onLogin;
          if (typeof local.onSync === 'boolean')  cfg.onSync  = local.onSync;
        }
        if (typeof local.targetGroupId === 'string' && local.targetGroupId) {
          cfg.targetGroupId = local.targetGroupId;
        }
      }
    } catch(_){}

    // 2) Cloud/AppSettings-Overlay (falls vorhanden)
    try {
      var api   = (typeof window !== 'undefined') ? window.lvAppSettings : null;
      var cache = api && typeof api.readCache === 'function' ? api.readCache() : null;
      var cloud = cache && cache[START_NOTICE_APP_KEY];
      if (cloud && typeof cloud === 'object') {
        if (typeof cloud.enabled === 'boolean') cfg.enabled = cloud.enabled;
        if (typeof cloud.text === 'string')    cfg.text    = cloud.text;
        if ('onLogin' in cloud || 'onSync' in cloud) {
          hasFlags = true;
          if (typeof cloud.onLogin === 'boolean') cfg.onLogin = cloud.onLogin;
          if (typeof cloud.onSync === 'boolean')  cfg.onSync  = cloud.onSync;
        }
        if (typeof cloud.targetGroupId === 'string' && cloud.targetGroupId) {
          cfg.targetGroupId = cloud.targetGroupId;
        }
      }
    } catch(_){}

    // Fallback für alte Konfiguration ohne Flags
    if (!hasFlags) {
      cfg.onLogin = !!cfg.enabled;
      cfg.onSync  = false;
    }
    cfg.enabled = !!(cfg.onLogin || cfg.onSync);
    if (!cfg.targetGroupId) cfg.targetGroupId = 'ALL';

    return cfg;
  }

  function writeStartNotice(cfg){
    cfg = cfg || {};
    var targetGroupId = (typeof cfg.targetGroupId === 'string' && cfg.targetGroupId)
      ? cfg.targetGroupId
      : 'ALL';

    var out = {
      enabled: !!(cfg.enabled || cfg.onLogin || cfg.onSync),
      text: (cfg.text || '').toString(),
      onLogin: (typeof cfg.onLogin === 'boolean') ? cfg.onLogin : true,
      onSync: !!cfg.onSync,
      targetGroupId: targetGroupId
    };

    // Lokal speichern
    try {
      if (typeof saveJson === 'function') {
        saveJson(START_NOTICE_KEY, out);
      } else if (typeof localStorage !== 'undefined') {
        localStorage.setItem(START_NOTICE_KEY, JSON.stringify(out));
      }
    } catch(_){}

    // In AppSettings (Cloud) spiegeln
    try {
      var api = (typeof window !== 'undefined') ? window.lvAppSettings : null;
      if (api && typeof api.upsert === 'function') {
        api.upsert(START_NOTICE_APP_KEY, out);
      }
    } catch(_){}
  }

  function populateStartNoticeGroupSelect(cfg){
    try{
      var sel = document.getElementById('startNoticeTargetGroup');
      if (!sel) return;

      var groupsList = Array.isArray(window.groups) ? window.groups : [];
      var current = (cfg && cfg.targetGroupId) ? String(cfg.targetGroupId) : 'ALL';

      while (sel.firstChild) sel.removeChild(sel.firstChild);

      var optAll = document.createElement('option');
      optAll.value = 'ALL';
      optAll.textContent = 'Alle Gruppen';
      sel.appendChild(optAll);

      for (var i = 0; i < groupsList.length; i++) {
        var g = groupsList[i];
        if (!g) continue;
        var o = document.createElement('option');
        o.value = String(g.id || '');
        o.textContent = g.name || g.id || '';
        sel.appendChild(o);
      }

      if (!current) current = 'ALL';
      var found = false;
      for (var j = 0; j < sel.options.length; j++) {
        if (sel.options[j].value === current) { found = true; break; }
      }
      sel.value = found ? current : 'ALL';
    }catch(_){}
  }

  function initStartNoticeUI(){
    try{
      var sec = document.getElementById('secStartNotice');
      if (sec){
        var can = false;
        try{
          if (typeof has === 'function'){
            can = !!(has('manage_start_notice') || has('manage_settings'));
          }else if (window.currentPerms){
            var p = window.currentPerms;
            can = !!(p.manage_start_notice || p.manage_settings);
          }
        }catch(_){}
        sec.style.display = can ? 'block' : 'none';
      }

      var cfg = readStartNotice();
      var boxLogin = document.getElementById('startNoticeOnLogin');
      var boxSync  = document.getElementById('startNoticeOnSync');
      var txt      = document.getElementById('startNoticeText');
      var legacyBox = document.getElementById('startNoticeEnabled');

      populateStartNoticeGroupSelect(cfg);

      if (boxLogin || boxSync){
        if (boxLogin) boxLogin.checked = !!cfg.onLogin;
        if (boxSync)  boxSync.checked  = !!cfg.onSync;
      }else if (legacyBox){
        legacyBox.checked = !!cfg.enabled;
      }
      if (txt) txt.value = cfg.text || '';
    }catch(_){}
  }

  function saveStartNoticeFromUI(){
    try{
      var boxLogin = document.getElementById('startNoticeOnLogin');
      var boxSync  = document.getElementById('startNoticeOnSync');
      var txt      = document.getElementById('startNoticeText');
      var legacyBox = document.getElementById('startNoticeEnabled');
      var selGroup = document.getElementById('startNoticeTargetGroup');
      if (!boxLogin && !boxSync && !legacyBox && !txt && !selGroup) return;

      var cfg = readStartNotice();
      if (boxLogin || boxSync){
        if (boxLogin) cfg.onLogin = !!boxLogin.checked;
        if (boxSync)  cfg.onSync  = !!boxSync.checked;
        cfg.enabled = !!(cfg.onLogin || cfg.onSync);
      }else if (legacyBox){
        cfg.enabled = !!legacyBox.checked;
        cfg.onLogin = !!cfg.enabled;
        cfg.onSync  = false;
      }
      if (txt) cfg.text = String(txt.value || '');

      if (selGroup){
        var val = selGroup.value || 'ALL';
        if (!val) val = 'ALL';
        cfg.targetGroupId = val;
      }

      writeStartNotice(cfg);
    }catch(_){}
  }

  function maybeShowStartNotice(context){
    try{
      var cfg = readStartNotice();
      if (!cfg.enabled) return;
      var mode = String(context || 'login');
      if (mode === 'login' && !cfg.onLogin) return;
      if (mode === 'sync'  && !cfg.onSync)  return;

      // Zielgruppe prüfen
      var target = cfg.targetGroupId || 'ALL';
      if (target && target !== 'ALL'){
        var gid = null;
        try { gid = window.currentGroupId || null; } catch(_){}

        if (!gid){
          try{
            var emailNorm = String(window.currentUserEmail || '').toLowerCase();
            var mems = Array.isArray(window.members) ? window.members : [];
            for (var i = 0; i < mems.length; i++){
              var m = mems[i];
              if (String(m.username || '').toLowerCase() === emailNorm){
                gid = m.group_id || null;
                break;
              }
            }
          }catch(_){}
        }

        if (!gid || String(gid) !== String(target)) return;
      }

      var txt = (cfg.text || '').trim();
      if (!txt) return;

      var dlg  = document.getElementById('startNoticeDlg');
      var body = document.getElementById('startNoticeBody');
      if (!dlg){
        alert(txt);
        return;
      }
      if (body) body.textContent = txt;
      try{ dlg.showModal(); }catch(_){ dlg.open = true; }
    }catch(_){}
  }

  window.readStartNotice        = readStartNotice;
  window.writeStartNotice       = writeStartNotice;
  window.initStartNoticeUI      = initStartNoticeUI;
  window.saveStartNoticeFromUI  = saveStartNoticeFromUI;
  window.maybeShowStartNotice   = maybeShowStartNotice;

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initStartNoticeUI);
  }else{
    initStartNoticeUI();
  }

  document.addEventListener('DOMContentLoaded', function(){
    try{
      var btnOk = document.getElementById('btnSettingsOk');
      if (btnOk && !btnOk.__startNoticeSave){
        btnOk.addEventListener('click', function(){
          saveStartNoticeFromUI();
        }, true);
        btnOk.__startNoticeSave = true;
      }
    }catch(_){}
  });

  document.addEventListener('DOMContentLoaded', function(){
    try{
      if (typeof window.setSession === 'function' && !window.setSession.__startNoticeWrap){
        var orig = window.setSession;
        window.setSession = function(email, persist){
          var res = orig.apply(this, arguments);
          try{
            var api = (typeof window !== 'undefined') ? window.lvAppSettings : null;
            if (api && typeof api.pullKeys === 'function'){
              api.pullKeys([START_NOTICE_APP_KEY])
                .then(function(){ try{ maybeShowStartNotice('login'); }catch(_){ } })
                .catch(function(){ try{ maybeShowStartNotice('login'); }catch(_){ } });
            }else{
              maybeShowStartNotice('login');
            }
          }catch(_){}
          return res;
        };
        window.setSession.__startNoticeWrap = true;

        // Nach dem ersten Seitenstart einmalig prüfen, ob bereits eine Sitzung aktiv ist
        // (z.B. durch „angemeldet bleiben“) und dann ggf. den Hinweis anzeigen.
        try{
          var api2 = (typeof window !== 'undefined') ? window.lvAppSettings : null;
          if (api2 && typeof api2.pullKeys === 'function'){
            api2.pullKeys([START_NOTICE_APP_KEY])
              .then(function(){ try{ maybeShowStartNotice('login'); }catch(_){ } })
              .catch(function(){ try{ maybeShowStartNotice('login'); }catch(_){ } });
          }else{
            setTimeout(function(){
              try{ maybeShowStartNotice('login'); }catch(_){}
            }, 500);
          }
        }catch(_){}
      }else{
        setTimeout(function(){
          try{ maybeShowStartNotice('login'); }catch(_){}
        }, 2000);
      }
    }catch(_){}
  });

})();</script>




<!-- v101 – Respect AutoSync flag: only push automatically if AutoSync is enabled -->
<script>
(function(){
  try{
    if (typeof window.queueTask === 'function' && !window.queueTask.__lvAutoSyncGuard){
      var __orig_qt__ = window.queueTask;
      window.queueTask = function(name){
        try{
          if (name === 'pushAll'){
            var auto = false;
            try{
              // Prefer config flag if available
              var cfg = (typeof readBrConfig === 'function') ? readBrConfig() : null;
              if (cfg && typeof cfg.autoSync !== 'undefined') auto = !!cfg.autoSync;
            }catch(_){}
            try{
              // Fallback: read raw localStorage key
              if (!auto && typeof localStorage !== 'undefined'){
                var k = (typeof autoSyncKey !== 'undefined') ? autoSyncKey : 'lagerverwaltung_supabase_autosync';
                auto = (localStorage.getItem(k) === '1' || localStorage.getItem(k) === 'true');
              }
            }catch(_){}
            if (auto){
              try{ if (typeof processOutbox === 'function') { processOutbox(); } }catch(e){ console.warn(e); }
            }else{
              // AutoSync aus -> NICHT senden, nur Rückgabe (Queue bleibt bestehen)
              // Optional: UI aktualisieren
              try{ if (typeof render === 'function') render(); }catch(_){}
            }
            return;
          }
        }catch(e){ console.warn('queueTask autosync guard error', e); }
        try{ return __orig_qt__.apply(this, arguments); }catch(_){}
      };
      window.queueTask.__lvAutoSyncGuard = true;
    }
  }catch(_){}
})();</script>

<!-- v046 – History-Append Guard & Tail Clean -->
<script>
(function(){
  try{
    function deepClone(o){ try{ return JSON.parse(JSON.stringify(o)); }catch(_){ return o; } }
    if (typeof window.addLog === 'function' && !window.addLog.__v046_wrapped){
      var __orig = window.addLog;
      window.addLog = function(it, entry){
        try{ if(!it) return __orig.apply(this, arguments); }catch(_){}
        try{ if(!Array.isArray(it.log)) it.log = []; }catch(_){}
        var e = deepClone(entry||{});
        var now = Date.now();
        var ts  = Number(e.ts||now); if(!isFinite(ts)||ts<=0) ts = now;
        var lastTs = 0; try{ if(it.log.length) lastTs = Number(it.log[it.log.length-1].ts)||0; }catch(_){}
        if (ts <= lastTs) ts = lastTs + 1; // strictly increasing to avoid overwrite/merge
        e.ts = ts;
        try{
          if (e.type==='qty' && Number(e.delta||0)!==0 && !e.opId){
            e.opId = (crypto&&crypto.randomUUID?crypto.randomUUID():('op_'+ts+'_'+Math.random().toString(16).slice(2)));
          }
        }catch(_){ e.opId = 'op_'+ts+'_'+Math.random().toString(16).slice(2); }
        return __orig.call(this, it, e);
      };
      window.addLog.__v046_wrapped = true;
    }
  }catch(e){}
})();
</script>

</body>
</html>